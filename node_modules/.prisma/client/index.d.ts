
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model user
 * 
 */
export type user = {
  userId: number
  email: string
  employeeNumber: number
  joinDate: string
  userName: string
  affiliation: string
  businessSituation: string
  password: string
  confirmPassword: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model skill
 * 
 */
export type skill = {
  skillId: number
  userId: number
  InherentName: string
  InherentDescription: string
  numericalNumber: number
  numericalExplain: string
  updatedAt: Date
}

/**
 * Model skillPoint
 * 
 */
export type skillPoint = {
  skillPointId: number
  userId: number
  FR: number
  BK: number
  DB: number
  SBR: number
  AR: number
  TS: number
  COM: number
}

/**
 * Model spaecialAbility
 * 
 */
export type spaecialAbility = {
  spaecialAbilityId: number
  userId: number
  skillList: string
  skillSelection: boolean
}

/**
 * Model spec
 * 
 */
export type spec = {
  specId: number
  userId: number
  github: string
  offHours: string
  createdAt: Date
}

/**
 * Model portfolio
 * 
 */
export type portfolio = {
  portfolioId: number
  specId: number
  heading: string
  url: string
}

/**
 * Model skillSummary
 * 
 */
export type skillSummary = {
  skillSummaryId: number
  specId: number
  autoCalibrationId: number
}

/**
 * Model sellingPoint
 * 
 */
export type sellingPoint = {
  sellingPointId: number
  specId: number
  title: string
  content: string
}

/**
 * Model qualification
 * 
 */
export type qualification = {
  qualificationId: number
  specId: number
  credential: string
  acquisitionDate: string
}

/**
 * Model previousWork
 * 
 */
export type previousWork = {
  previousWorkId: number
  specId: number
  industry: string
  occupation: string
  JobDuties: string
}

/**
 * Model developmentExperience
 * 
 */
export type developmentExperience = {
  developmentExperienceId: number
  specId: number
  startDate: string
  duration: string
  assignedTask: string
  teamSize: string
  totalProjectHeadcount: string
  projectName: string
  jobDuties: string
  img: string
  autoCalibrationId: number
}

/**
 * Model autoCalibration
 * 
 */
export type autoCalibration = {
  autoCalibrationId: number
  skill: string
  membership: number
  category: number
  FR: number
  CL: number
  ML: number
  QA: number
  JAVA: number
  PHP: number
}

/**
 * Model request
 * 
 */
export type request = {
  applicationId: number
  userId: number
  status: number
  adminComment: string
  engineerComment: string
  adminId: number
  createdAt: Date
  resultedAt: Date
}

/**
 * Model admin
 * 
 */
export type admin = {
  adminId: number
  email: string
  password: string
  name: string
  createdAt: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<GlobalReject>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.skillDelegate<GlobalReject>;

  /**
   * `prisma.skillPoint`: Exposes CRUD operations for the **skillPoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillPoints
    * const skillPoints = await prisma.skillPoint.findMany()
    * ```
    */
  get skillPoint(): Prisma.skillPointDelegate<GlobalReject>;

  /**
   * `prisma.spaecialAbility`: Exposes CRUD operations for the **spaecialAbility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpaecialAbilities
    * const spaecialAbilities = await prisma.spaecialAbility.findMany()
    * ```
    */
  get spaecialAbility(): Prisma.spaecialAbilityDelegate<GlobalReject>;

  /**
   * `prisma.spec`: Exposes CRUD operations for the **spec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specs
    * const specs = await prisma.spec.findMany()
    * ```
    */
  get spec(): Prisma.specDelegate<GlobalReject>;

  /**
   * `prisma.portfolio`: Exposes CRUD operations for the **portfolio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Portfolios
    * const portfolios = await prisma.portfolio.findMany()
    * ```
    */
  get portfolio(): Prisma.portfolioDelegate<GlobalReject>;

  /**
   * `prisma.skillSummary`: Exposes CRUD operations for the **skillSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillSummaries
    * const skillSummaries = await prisma.skillSummary.findMany()
    * ```
    */
  get skillSummary(): Prisma.skillSummaryDelegate<GlobalReject>;

  /**
   * `prisma.sellingPoint`: Exposes CRUD operations for the **sellingPoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellingPoints
    * const sellingPoints = await prisma.sellingPoint.findMany()
    * ```
    */
  get sellingPoint(): Prisma.sellingPointDelegate<GlobalReject>;

  /**
   * `prisma.qualification`: Exposes CRUD operations for the **qualification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qualifications
    * const qualifications = await prisma.qualification.findMany()
    * ```
    */
  get qualification(): Prisma.qualificationDelegate<GlobalReject>;

  /**
   * `prisma.previousWork`: Exposes CRUD operations for the **previousWork** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreviousWorks
    * const previousWorks = await prisma.previousWork.findMany()
    * ```
    */
  get previousWork(): Prisma.previousWorkDelegate<GlobalReject>;

  /**
   * `prisma.developmentExperience`: Exposes CRUD operations for the **developmentExperience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DevelopmentExperiences
    * const developmentExperiences = await prisma.developmentExperience.findMany()
    * ```
    */
  get developmentExperience(): Prisma.developmentExperienceDelegate<GlobalReject>;

  /**
   * `prisma.autoCalibration`: Exposes CRUD operations for the **autoCalibration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoCalibrations
    * const autoCalibrations = await prisma.autoCalibration.findMany()
    * ```
    */
  get autoCalibration(): Prisma.autoCalibrationDelegate<GlobalReject>;

  /**
   * `prisma.request`: Exposes CRUD operations for the **request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requests
    * const requests = await prisma.request.findMany()
    * ```
    */
  get request(): Prisma.requestDelegate<GlobalReject>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.0
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    skill: 'skill',
    skillPoint: 'skillPoint',
    spaecialAbility: 'spaecialAbility',
    spec: 'spec',
    portfolio: 'portfolio',
    skillSummary: 'skillSummary',
    sellingPoint: 'sellingPoint',
    qualification: 'qualification',
    previousWork: 'previousWork',
    developmentExperience: 'developmentExperience',
    autoCalibration: 'autoCalibration',
    request: 'request',
    admin: 'admin'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    skills: number
    skillPoints: number
    specialAbilities: number
    specs: number
    requests: number
  }

  export type UserCountOutputTypeSelect = {
    skills?: boolean
    skillPoints?: boolean
    specialAbilities?: boolean
    specs?: boolean
    requests?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type SpecCountOutputType
   */


  export type SpecCountOutputType = {
    portfolios: number
    skillSummaries: number
    sellingPoints: number
    qualifications: number
    previousWorks: number
    developmentExperiences: number
  }

  export type SpecCountOutputTypeSelect = {
    portfolios?: boolean
    skillSummaries?: boolean
    sellingPoints?: boolean
    qualifications?: boolean
    previousWorks?: boolean
    developmentExperiences?: boolean
  }

  export type SpecCountOutputTypeGetPayload<S extends boolean | null | undefined | SpecCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SpecCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SpecCountOutputTypeArgs)
    ? SpecCountOutputType 
    : S extends { select: any } & (SpecCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SpecCountOutputType ? SpecCountOutputType[P] : never
  } 
      : SpecCountOutputType




  // Custom InputTypes

  /**
   * SpecCountOutputType without action
   */
  export type SpecCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SpecCountOutputType
     */
    select?: SpecCountOutputTypeSelect | null
  }



  /**
   * Count Type AutoCalibrationCountOutputType
   */


  export type AutoCalibrationCountOutputType = {
    skillSummaries: number
    developmentExperiences: number
  }

  export type AutoCalibrationCountOutputTypeSelect = {
    skillSummaries?: boolean
    developmentExperiences?: boolean
  }

  export type AutoCalibrationCountOutputTypeGetPayload<S extends boolean | null | undefined | AutoCalibrationCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AutoCalibrationCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AutoCalibrationCountOutputTypeArgs)
    ? AutoCalibrationCountOutputType 
    : S extends { select: any } & (AutoCalibrationCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AutoCalibrationCountOutputType ? AutoCalibrationCountOutputType[P] : never
  } 
      : AutoCalibrationCountOutputType




  // Custom InputTypes

  /**
   * AutoCalibrationCountOutputType without action
   */
  export type AutoCalibrationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AutoCalibrationCountOutputType
     */
    select?: AutoCalibrationCountOutputTypeSelect | null
  }



  /**
   * Count Type AdminCountOutputType
   */


  export type AdminCountOutputType = {
    requests: number
  }

  export type AdminCountOutputTypeSelect = {
    requests?: boolean
  }

  export type AdminCountOutputTypeGetPayload<S extends boolean | null | undefined | AdminCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AdminCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AdminCountOutputTypeArgs)
    ? AdminCountOutputType 
    : S extends { select: any } & (AdminCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AdminCountOutputType ? AdminCountOutputType[P] : never
  } 
      : AdminCountOutputType




  // Custom InputTypes

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model user
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    userId: number | null
    employeeNumber: number | null
  }

  export type UserSumAggregateOutputType = {
    userId: number | null
    employeeNumber: number | null
  }

  export type UserMinAggregateOutputType = {
    userId: number | null
    email: string | null
    employeeNumber: number | null
    joinDate: string | null
    userName: string | null
    affiliation: string | null
    businessSituation: string | null
    password: string | null
    confirmPassword: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    userId: number | null
    email: string | null
    employeeNumber: number | null
    joinDate: string | null
    userName: string | null
    affiliation: string | null
    businessSituation: string | null
    password: string | null
    confirmPassword: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    userId: number
    email: number
    employeeNumber: number
    joinDate: number
    userName: number
    affiliation: number
    businessSituation: number
    password: number
    confirmPassword: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    userId?: true
    employeeNumber?: true
  }

  export type UserSumAggregateInputType = {
    userId?: true
    employeeNumber?: true
  }

  export type UserMinAggregateInputType = {
    userId?: true
    email?: true
    employeeNumber?: true
    joinDate?: true
    userName?: true
    affiliation?: true
    businessSituation?: true
    password?: true
    confirmPassword?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    userId?: true
    email?: true
    employeeNumber?: true
    joinDate?: true
    userName?: true
    affiliation?: true
    businessSituation?: true
    password?: true
    confirmPassword?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    userId?: true
    email?: true
    employeeNumber?: true
    joinDate?: true
    userName?: true
    affiliation?: true
    businessSituation?: true
    password?: true
    confirmPassword?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: userWhereInput
    orderBy?: Enumerable<userOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    userId: number
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect = {
    userId?: boolean
    email?: boolean
    employeeNumber?: boolean
    joinDate?: boolean
    userName?: boolean
    affiliation?: boolean
    businessSituation?: boolean
    password?: boolean
    confirmPassword?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skills?: boolean | user$skillsArgs
    skillPoints?: boolean | user$skillPointsArgs
    specialAbilities?: boolean | user$specialAbilitiesArgs
    specs?: boolean | user$specsArgs
    requests?: boolean | user$requestsArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type userInclude = {
    skills?: boolean | user$skillsArgs
    skillPoints?: boolean | user$skillPointsArgs
    specialAbilities?: boolean | user$specialAbilitiesArgs
    specs?: boolean | user$specsArgs
    requests?: boolean | user$requestsArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type userGetPayload<S extends boolean | null | undefined | userArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? user :
    S extends undefined ? never :
    S extends { include: any } & (userArgs | userFindManyArgs)
    ? user  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'skills' ? Array < skillGetPayload<S['include'][P]>>  :
        P extends 'skillPoints' ? Array < skillPointGetPayload<S['include'][P]>>  :
        P extends 'specialAbilities' ? Array < spaecialAbilityGetPayload<S['include'][P]>>  :
        P extends 'specs' ? Array < specGetPayload<S['include'][P]>>  :
        P extends 'requests' ? Array < requestGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (userArgs | userFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'skills' ? Array < skillGetPayload<S['select'][P]>>  :
        P extends 'skillPoints' ? Array < skillPointGetPayload<S['select'][P]>>  :
        P extends 'specialAbilities' ? Array < spaecialAbilityGetPayload<S['select'][P]>>  :
        P extends 'specs' ? Array < specGetPayload<S['select'][P]>>  :
        P extends 'requests' ? Array < requestGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof user ? user[P] : never
  } 
      : user


  type userCountArgs = 
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user'> extends True ? Prisma__userClient<userGetPayload<T>> : Prisma__userClient<userGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user'> extends True ? Prisma__userClient<userGetPayload<T>> : Prisma__userClient<userGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userWithUserIdOnly = await prisma.user.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends userFindManyArgs>(
      args?: SelectSubset<T, userFindManyArgs>
    ): Prisma.PrismaPromise<Array<userGetPayload<T>>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs>(
      args: SelectSubset<T, userCreateArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs>(
      args?: SelectSubset<T, userCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs>(
      args: SelectSubset<T, userDeleteArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs>(
      args: SelectSubset<T, userUpdateArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs>(
      args?: SelectSubset<T, userDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs>(
      args: SelectSubset<T, userUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs>(
      args: SelectSubset<T, userUpsertArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    skills<T extends user$skillsArgs= {}>(args?: Subset<T, user$skillsArgs>): Prisma.PrismaPromise<Array<skillGetPayload<T>>| Null>;

    skillPoints<T extends user$skillPointsArgs= {}>(args?: Subset<T, user$skillPointsArgs>): Prisma.PrismaPromise<Array<skillPointGetPayload<T>>| Null>;

    specialAbilities<T extends user$specialAbilitiesArgs= {}>(args?: Subset<T, user$specialAbilitiesArgs>): Prisma.PrismaPromise<Array<spaecialAbilityGetPayload<T>>| Null>;

    specs<T extends user$specsArgs= {}>(args?: Subset<T, user$specsArgs>): Prisma.PrismaPromise<Array<specGetPayload<T>>| Null>;

    requests<T extends user$requestsArgs= {}>(args?: Subset<T, user$requestsArgs>): Prisma.PrismaPromise<Array<requestGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user base type for findUnique actions
   */
  export type userFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUnique
   */
  export interface userFindUniqueArgs extends userFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user base type for findFirst actions
   */
  export type userFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * user findFirst
   */
  export interface userFindFirstArgs extends userFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user findMany
   */
  export type userFindManyArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user create
   */
  export type userCreateArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs = {
    /**
     * The data used to create many users.
     */
    data: Enumerable<userCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.skills
   */
  export type user$skillsArgs = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillInclude | null
    where?: skillWhereInput
    orderBy?: Enumerable<skillOrderByWithRelationInput>
    cursor?: skillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SkillScalarFieldEnum>
  }


  /**
   * user.skillPoints
   */
  export type user$skillPointsArgs = {
    /**
     * Select specific fields to fetch from the skillPoint
     */
    select?: skillPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillPointInclude | null
    where?: skillPointWhereInput
    orderBy?: Enumerable<skillPointOrderByWithRelationInput>
    cursor?: skillPointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SkillPointScalarFieldEnum>
  }


  /**
   * user.specialAbilities
   */
  export type user$specialAbilitiesArgs = {
    /**
     * Select specific fields to fetch from the spaecialAbility
     */
    select?: spaecialAbilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: spaecialAbilityInclude | null
    where?: spaecialAbilityWhereInput
    orderBy?: Enumerable<spaecialAbilityOrderByWithRelationInput>
    cursor?: spaecialAbilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SpaecialAbilityScalarFieldEnum>
  }


  /**
   * user.specs
   */
  export type user$specsArgs = {
    /**
     * Select specific fields to fetch from the spec
     */
    select?: specSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: specInclude | null
    where?: specWhereInput
    orderBy?: Enumerable<specOrderByWithRelationInput>
    cursor?: specWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SpecScalarFieldEnum>
  }


  /**
   * user.requests
   */
  export type user$requestsArgs = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
    where?: requestWhereInput
    orderBy?: Enumerable<requestOrderByWithRelationInput>
    cursor?: requestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RequestScalarFieldEnum>
  }


  /**
   * user without action
   */
  export type userArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
  }



  /**
   * Model skill
   */


  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillAvgAggregateOutputType = {
    skillId: number | null
    userId: number | null
    numericalNumber: number | null
  }

  export type SkillSumAggregateOutputType = {
    skillId: number | null
    userId: number | null
    numericalNumber: number | null
  }

  export type SkillMinAggregateOutputType = {
    skillId: number | null
    userId: number | null
    InherentName: string | null
    InherentDescription: string | null
    numericalNumber: number | null
    numericalExplain: string | null
    updatedAt: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    skillId: number | null
    userId: number | null
    InherentName: string | null
    InherentDescription: string | null
    numericalNumber: number | null
    numericalExplain: string | null
    updatedAt: Date | null
  }

  export type SkillCountAggregateOutputType = {
    skillId: number
    userId: number
    InherentName: number
    InherentDescription: number
    numericalNumber: number
    numericalExplain: number
    updatedAt: number
    _all: number
  }


  export type SkillAvgAggregateInputType = {
    skillId?: true
    userId?: true
    numericalNumber?: true
  }

  export type SkillSumAggregateInputType = {
    skillId?: true
    userId?: true
    numericalNumber?: true
  }

  export type SkillMinAggregateInputType = {
    skillId?: true
    userId?: true
    InherentName?: true
    InherentDescription?: true
    numericalNumber?: true
    numericalExplain?: true
    updatedAt?: true
  }

  export type SkillMaxAggregateInputType = {
    skillId?: true
    userId?: true
    InherentName?: true
    InherentDescription?: true
    numericalNumber?: true
    numericalExplain?: true
    updatedAt?: true
  }

  export type SkillCountAggregateInputType = {
    skillId?: true
    userId?: true
    InherentName?: true
    InherentDescription?: true
    numericalNumber?: true
    numericalExplain?: true
    updatedAt?: true
    _all?: true
  }

  export type SkillAggregateArgs = {
    /**
     * Filter which skill to aggregate.
     */
    where?: skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: Enumerable<skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs = {
    where?: skillWhereInput
    orderBy?: Enumerable<skillOrderByWithAggregationInput>
    by: SkillScalarFieldEnum[]
    having?: skillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _avg?: SkillAvgAggregateInputType
    _sum?: SkillSumAggregateInputType
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }


  export type SkillGroupByOutputType = {
    skillId: number
    userId: number
    InherentName: string
    InherentDescription: string
    numericalNumber: number
    numericalExplain: string
    updatedAt: Date
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type skillSelect = {
    skillId?: boolean
    userId?: boolean
    InherentName?: boolean
    InherentDescription?: boolean
    numericalNumber?: boolean
    numericalExplain?: boolean
    updatedAt?: boolean
    user?: boolean | userArgs
  }


  export type skillInclude = {
    user?: boolean | userArgs
  }

  export type skillGetPayload<S extends boolean | null | undefined | skillArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? skill :
    S extends undefined ? never :
    S extends { include: any } & (skillArgs | skillFindManyArgs)
    ? skill  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (skillArgs | skillFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof skill ? skill[P] : never
  } 
      : skill


  type skillCountArgs = 
    Omit<skillFindManyArgs, 'select' | 'include'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface skillDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Skill that matches the filter.
     * @param {skillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends skillFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, skillFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'skill'> extends True ? Prisma__skillClient<skillGetPayload<T>> : Prisma__skillClient<skillGetPayload<T> | null, null>

    /**
     * Find one Skill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {skillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends skillFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, skillFindUniqueOrThrowArgs>
    ): Prisma__skillClient<skillGetPayload<T>>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends skillFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, skillFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'skill'> extends True ? Prisma__skillClient<skillGetPayload<T>> : Prisma__skillClient<skillGetPayload<T> | null, null>

    /**
     * Find the first Skill that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends skillFindFirstOrThrowArgs>(
      args?: SelectSubset<T, skillFindFirstOrThrowArgs>
    ): Prisma__skillClient<skillGetPayload<T>>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `skillId`
     * const skillWithSkillIdOnly = await prisma.skill.findMany({ select: { skillId: true } })
     * 
    **/
    findMany<T extends skillFindManyArgs>(
      args?: SelectSubset<T, skillFindManyArgs>
    ): Prisma.PrismaPromise<Array<skillGetPayload<T>>>

    /**
     * Create a Skill.
     * @param {skillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
    **/
    create<T extends skillCreateArgs>(
      args: SelectSubset<T, skillCreateArgs>
    ): Prisma__skillClient<skillGetPayload<T>>

    /**
     * Create many Skills.
     *     @param {skillCreateManyArgs} args - Arguments to create many Skills.
     *     @example
     *     // Create many Skills
     *     const skill = await prisma.skill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends skillCreateManyArgs>(
      args?: SelectSubset<T, skillCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Skill.
     * @param {skillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
    **/
    delete<T extends skillDeleteArgs>(
      args: SelectSubset<T, skillDeleteArgs>
    ): Prisma__skillClient<skillGetPayload<T>>

    /**
     * Update one Skill.
     * @param {skillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends skillUpdateArgs>(
      args: SelectSubset<T, skillUpdateArgs>
    ): Prisma__skillClient<skillGetPayload<T>>

    /**
     * Delete zero or more Skills.
     * @param {skillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends skillDeleteManyArgs>(
      args?: SelectSubset<T, skillDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends skillUpdateManyArgs>(
      args: SelectSubset<T, skillUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill.
     * @param {skillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
    **/
    upsert<T extends skillUpsertArgs>(
      args: SelectSubset<T, skillUpsertArgs>
    ): Prisma__skillClient<skillGetPayload<T>>

    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends skillCountArgs>(
      args?: Subset<T, skillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__skillClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * skill base type for findUnique actions
   */
  export type skillFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillInclude | null
    /**
     * Filter, which skill to fetch.
     */
    where: skillWhereUniqueInput
  }

  /**
   * skill findUnique
   */
  export interface skillFindUniqueArgs extends skillFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skill findUniqueOrThrow
   */
  export type skillFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillInclude | null
    /**
     * Filter, which skill to fetch.
     */
    where: skillWhereUniqueInput
  }


  /**
   * skill base type for findFirst actions
   */
  export type skillFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillInclude | null
    /**
     * Filter, which skill to fetch.
     */
    where?: skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: Enumerable<skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: Enumerable<SkillScalarFieldEnum>
  }

  /**
   * skill findFirst
   */
  export interface skillFindFirstArgs extends skillFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skill findFirstOrThrow
   */
  export type skillFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillInclude | null
    /**
     * Filter, which skill to fetch.
     */
    where?: skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: Enumerable<skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: Enumerable<SkillScalarFieldEnum>
  }


  /**
   * skill findMany
   */
  export type skillFindManyArgs = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillInclude | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: Enumerable<skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skills.
     */
    cursor?: skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    distinct?: Enumerable<SkillScalarFieldEnum>
  }


  /**
   * skill create
   */
  export type skillCreateArgs = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillInclude | null
    /**
     * The data needed to create a skill.
     */
    data: XOR<skillCreateInput, skillUncheckedCreateInput>
  }


  /**
   * skill createMany
   */
  export type skillCreateManyArgs = {
    /**
     * The data used to create many skills.
     */
    data: Enumerable<skillCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * skill update
   */
  export type skillUpdateArgs = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillInclude | null
    /**
     * The data needed to update a skill.
     */
    data: XOR<skillUpdateInput, skillUncheckedUpdateInput>
    /**
     * Choose, which skill to update.
     */
    where: skillWhereUniqueInput
  }


  /**
   * skill updateMany
   */
  export type skillUpdateManyArgs = {
    /**
     * The data used to update skills.
     */
    data: XOR<skillUpdateManyMutationInput, skillUncheckedUpdateManyInput>
    /**
     * Filter which skills to update
     */
    where?: skillWhereInput
  }


  /**
   * skill upsert
   */
  export type skillUpsertArgs = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillInclude | null
    /**
     * The filter to search for the skill to update in case it exists.
     */
    where: skillWhereUniqueInput
    /**
     * In case the skill found by the `where` argument doesn't exist, create a new skill with this data.
     */
    create: XOR<skillCreateInput, skillUncheckedCreateInput>
    /**
     * In case the skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skillUpdateInput, skillUncheckedUpdateInput>
  }


  /**
   * skill delete
   */
  export type skillDeleteArgs = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillInclude | null
    /**
     * Filter which skill to delete.
     */
    where: skillWhereUniqueInput
  }


  /**
   * skill deleteMany
   */
  export type skillDeleteManyArgs = {
    /**
     * Filter which skills to delete
     */
    where?: skillWhereInput
  }


  /**
   * skill without action
   */
  export type skillArgs = {
    /**
     * Select specific fields to fetch from the skill
     */
    select?: skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillInclude | null
  }



  /**
   * Model skillPoint
   */


  export type AggregateSkillPoint = {
    _count: SkillPointCountAggregateOutputType | null
    _avg: SkillPointAvgAggregateOutputType | null
    _sum: SkillPointSumAggregateOutputType | null
    _min: SkillPointMinAggregateOutputType | null
    _max: SkillPointMaxAggregateOutputType | null
  }

  export type SkillPointAvgAggregateOutputType = {
    skillPointId: number | null
    userId: number | null
    FR: number | null
    BK: number | null
    DB: number | null
    SBR: number | null
    AR: number | null
    TS: number | null
    COM: number | null
  }

  export type SkillPointSumAggregateOutputType = {
    skillPointId: number | null
    userId: number | null
    FR: number | null
    BK: number | null
    DB: number | null
    SBR: number | null
    AR: number | null
    TS: number | null
    COM: number | null
  }

  export type SkillPointMinAggregateOutputType = {
    skillPointId: number | null
    userId: number | null
    FR: number | null
    BK: number | null
    DB: number | null
    SBR: number | null
    AR: number | null
    TS: number | null
    COM: number | null
  }

  export type SkillPointMaxAggregateOutputType = {
    skillPointId: number | null
    userId: number | null
    FR: number | null
    BK: number | null
    DB: number | null
    SBR: number | null
    AR: number | null
    TS: number | null
    COM: number | null
  }

  export type SkillPointCountAggregateOutputType = {
    skillPointId: number
    userId: number
    FR: number
    BK: number
    DB: number
    SBR: number
    AR: number
    TS: number
    COM: number
    _all: number
  }


  export type SkillPointAvgAggregateInputType = {
    skillPointId?: true
    userId?: true
    FR?: true
    BK?: true
    DB?: true
    SBR?: true
    AR?: true
    TS?: true
    COM?: true
  }

  export type SkillPointSumAggregateInputType = {
    skillPointId?: true
    userId?: true
    FR?: true
    BK?: true
    DB?: true
    SBR?: true
    AR?: true
    TS?: true
    COM?: true
  }

  export type SkillPointMinAggregateInputType = {
    skillPointId?: true
    userId?: true
    FR?: true
    BK?: true
    DB?: true
    SBR?: true
    AR?: true
    TS?: true
    COM?: true
  }

  export type SkillPointMaxAggregateInputType = {
    skillPointId?: true
    userId?: true
    FR?: true
    BK?: true
    DB?: true
    SBR?: true
    AR?: true
    TS?: true
    COM?: true
  }

  export type SkillPointCountAggregateInputType = {
    skillPointId?: true
    userId?: true
    FR?: true
    BK?: true
    DB?: true
    SBR?: true
    AR?: true
    TS?: true
    COM?: true
    _all?: true
  }

  export type SkillPointAggregateArgs = {
    /**
     * Filter which skillPoint to aggregate.
     */
    where?: skillPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillPoints to fetch.
     */
    orderBy?: Enumerable<skillPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skillPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skillPoints
    **/
    _count?: true | SkillPointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillPointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillPointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillPointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillPointMaxAggregateInputType
  }

  export type GetSkillPointAggregateType<T extends SkillPointAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillPoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillPoint[P]>
      : GetScalarType<T[P], AggregateSkillPoint[P]>
  }




  export type SkillPointGroupByArgs = {
    where?: skillPointWhereInput
    orderBy?: Enumerable<skillPointOrderByWithAggregationInput>
    by: SkillPointScalarFieldEnum[]
    having?: skillPointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillPointCountAggregateInputType | true
    _avg?: SkillPointAvgAggregateInputType
    _sum?: SkillPointSumAggregateInputType
    _min?: SkillPointMinAggregateInputType
    _max?: SkillPointMaxAggregateInputType
  }


  export type SkillPointGroupByOutputType = {
    skillPointId: number
    userId: number
    FR: number
    BK: number
    DB: number
    SBR: number
    AR: number
    TS: number
    COM: number
    _count: SkillPointCountAggregateOutputType | null
    _avg: SkillPointAvgAggregateOutputType | null
    _sum: SkillPointSumAggregateOutputType | null
    _min: SkillPointMinAggregateOutputType | null
    _max: SkillPointMaxAggregateOutputType | null
  }

  type GetSkillPointGroupByPayload<T extends SkillPointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SkillPointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillPointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillPointGroupByOutputType[P]>
            : GetScalarType<T[P], SkillPointGroupByOutputType[P]>
        }
      >
    >


  export type skillPointSelect = {
    skillPointId?: boolean
    userId?: boolean
    FR?: boolean
    BK?: boolean
    DB?: boolean
    SBR?: boolean
    AR?: boolean
    TS?: boolean
    COM?: boolean
    user?: boolean | userArgs
  }


  export type skillPointInclude = {
    user?: boolean | userArgs
  }

  export type skillPointGetPayload<S extends boolean | null | undefined | skillPointArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? skillPoint :
    S extends undefined ? never :
    S extends { include: any } & (skillPointArgs | skillPointFindManyArgs)
    ? skillPoint  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (skillPointArgs | skillPointFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof skillPoint ? skillPoint[P] : never
  } 
      : skillPoint


  type skillPointCountArgs = 
    Omit<skillPointFindManyArgs, 'select' | 'include'> & {
      select?: SkillPointCountAggregateInputType | true
    }

  export interface skillPointDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SkillPoint that matches the filter.
     * @param {skillPointFindUniqueArgs} args - Arguments to find a SkillPoint
     * @example
     * // Get one SkillPoint
     * const skillPoint = await prisma.skillPoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends skillPointFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, skillPointFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'skillPoint'> extends True ? Prisma__skillPointClient<skillPointGetPayload<T>> : Prisma__skillPointClient<skillPointGetPayload<T> | null, null>

    /**
     * Find one SkillPoint that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {skillPointFindUniqueOrThrowArgs} args - Arguments to find a SkillPoint
     * @example
     * // Get one SkillPoint
     * const skillPoint = await prisma.skillPoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends skillPointFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, skillPointFindUniqueOrThrowArgs>
    ): Prisma__skillPointClient<skillPointGetPayload<T>>

    /**
     * Find the first SkillPoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillPointFindFirstArgs} args - Arguments to find a SkillPoint
     * @example
     * // Get one SkillPoint
     * const skillPoint = await prisma.skillPoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends skillPointFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, skillPointFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'skillPoint'> extends True ? Prisma__skillPointClient<skillPointGetPayload<T>> : Prisma__skillPointClient<skillPointGetPayload<T> | null, null>

    /**
     * Find the first SkillPoint that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillPointFindFirstOrThrowArgs} args - Arguments to find a SkillPoint
     * @example
     * // Get one SkillPoint
     * const skillPoint = await prisma.skillPoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends skillPointFindFirstOrThrowArgs>(
      args?: SelectSubset<T, skillPointFindFirstOrThrowArgs>
    ): Prisma__skillPointClient<skillPointGetPayload<T>>

    /**
     * Find zero or more SkillPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillPointFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillPoints
     * const skillPoints = await prisma.skillPoint.findMany()
     * 
     * // Get first 10 SkillPoints
     * const skillPoints = await prisma.skillPoint.findMany({ take: 10 })
     * 
     * // Only select the `skillPointId`
     * const skillPointWithSkillPointIdOnly = await prisma.skillPoint.findMany({ select: { skillPointId: true } })
     * 
    **/
    findMany<T extends skillPointFindManyArgs>(
      args?: SelectSubset<T, skillPointFindManyArgs>
    ): Prisma.PrismaPromise<Array<skillPointGetPayload<T>>>

    /**
     * Create a SkillPoint.
     * @param {skillPointCreateArgs} args - Arguments to create a SkillPoint.
     * @example
     * // Create one SkillPoint
     * const SkillPoint = await prisma.skillPoint.create({
     *   data: {
     *     // ... data to create a SkillPoint
     *   }
     * })
     * 
    **/
    create<T extends skillPointCreateArgs>(
      args: SelectSubset<T, skillPointCreateArgs>
    ): Prisma__skillPointClient<skillPointGetPayload<T>>

    /**
     * Create many SkillPoints.
     *     @param {skillPointCreateManyArgs} args - Arguments to create many SkillPoints.
     *     @example
     *     // Create many SkillPoints
     *     const skillPoint = await prisma.skillPoint.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends skillPointCreateManyArgs>(
      args?: SelectSubset<T, skillPointCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SkillPoint.
     * @param {skillPointDeleteArgs} args - Arguments to delete one SkillPoint.
     * @example
     * // Delete one SkillPoint
     * const SkillPoint = await prisma.skillPoint.delete({
     *   where: {
     *     // ... filter to delete one SkillPoint
     *   }
     * })
     * 
    **/
    delete<T extends skillPointDeleteArgs>(
      args: SelectSubset<T, skillPointDeleteArgs>
    ): Prisma__skillPointClient<skillPointGetPayload<T>>

    /**
     * Update one SkillPoint.
     * @param {skillPointUpdateArgs} args - Arguments to update one SkillPoint.
     * @example
     * // Update one SkillPoint
     * const skillPoint = await prisma.skillPoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends skillPointUpdateArgs>(
      args: SelectSubset<T, skillPointUpdateArgs>
    ): Prisma__skillPointClient<skillPointGetPayload<T>>

    /**
     * Delete zero or more SkillPoints.
     * @param {skillPointDeleteManyArgs} args - Arguments to filter SkillPoints to delete.
     * @example
     * // Delete a few SkillPoints
     * const { count } = await prisma.skillPoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends skillPointDeleteManyArgs>(
      args?: SelectSubset<T, skillPointDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillPointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillPoints
     * const skillPoint = await prisma.skillPoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends skillPointUpdateManyArgs>(
      args: SelectSubset<T, skillPointUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkillPoint.
     * @param {skillPointUpsertArgs} args - Arguments to update or create a SkillPoint.
     * @example
     * // Update or create a SkillPoint
     * const skillPoint = await prisma.skillPoint.upsert({
     *   create: {
     *     // ... data to create a SkillPoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillPoint we want to update
     *   }
     * })
    **/
    upsert<T extends skillPointUpsertArgs>(
      args: SelectSubset<T, skillPointUpsertArgs>
    ): Prisma__skillPointClient<skillPointGetPayload<T>>

    /**
     * Count the number of SkillPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillPointCountArgs} args - Arguments to filter SkillPoints to count.
     * @example
     * // Count the number of SkillPoints
     * const count = await prisma.skillPoint.count({
     *   where: {
     *     // ... the filter for the SkillPoints we want to count
     *   }
     * })
    **/
    count<T extends skillPointCountArgs>(
      args?: Subset<T, skillPointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillPointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillPointAggregateArgs>(args: Subset<T, SkillPointAggregateArgs>): Prisma.PrismaPromise<GetSkillPointAggregateType<T>>

    /**
     * Group by SkillPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillPointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillPointGroupByArgs['orderBy'] }
        : { orderBy?: SkillPointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillPointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillPointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for skillPoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__skillPointClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * skillPoint base type for findUnique actions
   */
  export type skillPointFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the skillPoint
     */
    select?: skillPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillPointInclude | null
    /**
     * Filter, which skillPoint to fetch.
     */
    where: skillPointWhereUniqueInput
  }

  /**
   * skillPoint findUnique
   */
  export interface skillPointFindUniqueArgs extends skillPointFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skillPoint findUniqueOrThrow
   */
  export type skillPointFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the skillPoint
     */
    select?: skillPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillPointInclude | null
    /**
     * Filter, which skillPoint to fetch.
     */
    where: skillPointWhereUniqueInput
  }


  /**
   * skillPoint base type for findFirst actions
   */
  export type skillPointFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the skillPoint
     */
    select?: skillPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillPointInclude | null
    /**
     * Filter, which skillPoint to fetch.
     */
    where?: skillPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillPoints to fetch.
     */
    orderBy?: Enumerable<skillPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skillPoints.
     */
    cursor?: skillPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skillPoints.
     */
    distinct?: Enumerable<SkillPointScalarFieldEnum>
  }

  /**
   * skillPoint findFirst
   */
  export interface skillPointFindFirstArgs extends skillPointFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skillPoint findFirstOrThrow
   */
  export type skillPointFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the skillPoint
     */
    select?: skillPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillPointInclude | null
    /**
     * Filter, which skillPoint to fetch.
     */
    where?: skillPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillPoints to fetch.
     */
    orderBy?: Enumerable<skillPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skillPoints.
     */
    cursor?: skillPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skillPoints.
     */
    distinct?: Enumerable<SkillPointScalarFieldEnum>
  }


  /**
   * skillPoint findMany
   */
  export type skillPointFindManyArgs = {
    /**
     * Select specific fields to fetch from the skillPoint
     */
    select?: skillPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillPointInclude | null
    /**
     * Filter, which skillPoints to fetch.
     */
    where?: skillPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillPoints to fetch.
     */
    orderBy?: Enumerable<skillPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skillPoints.
     */
    cursor?: skillPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillPoints.
     */
    skip?: number
    distinct?: Enumerable<SkillPointScalarFieldEnum>
  }


  /**
   * skillPoint create
   */
  export type skillPointCreateArgs = {
    /**
     * Select specific fields to fetch from the skillPoint
     */
    select?: skillPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillPointInclude | null
    /**
     * The data needed to create a skillPoint.
     */
    data: XOR<skillPointCreateInput, skillPointUncheckedCreateInput>
  }


  /**
   * skillPoint createMany
   */
  export type skillPointCreateManyArgs = {
    /**
     * The data used to create many skillPoints.
     */
    data: Enumerable<skillPointCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * skillPoint update
   */
  export type skillPointUpdateArgs = {
    /**
     * Select specific fields to fetch from the skillPoint
     */
    select?: skillPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillPointInclude | null
    /**
     * The data needed to update a skillPoint.
     */
    data: XOR<skillPointUpdateInput, skillPointUncheckedUpdateInput>
    /**
     * Choose, which skillPoint to update.
     */
    where: skillPointWhereUniqueInput
  }


  /**
   * skillPoint updateMany
   */
  export type skillPointUpdateManyArgs = {
    /**
     * The data used to update skillPoints.
     */
    data: XOR<skillPointUpdateManyMutationInput, skillPointUncheckedUpdateManyInput>
    /**
     * Filter which skillPoints to update
     */
    where?: skillPointWhereInput
  }


  /**
   * skillPoint upsert
   */
  export type skillPointUpsertArgs = {
    /**
     * Select specific fields to fetch from the skillPoint
     */
    select?: skillPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillPointInclude | null
    /**
     * The filter to search for the skillPoint to update in case it exists.
     */
    where: skillPointWhereUniqueInput
    /**
     * In case the skillPoint found by the `where` argument doesn't exist, create a new skillPoint with this data.
     */
    create: XOR<skillPointCreateInput, skillPointUncheckedCreateInput>
    /**
     * In case the skillPoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skillPointUpdateInput, skillPointUncheckedUpdateInput>
  }


  /**
   * skillPoint delete
   */
  export type skillPointDeleteArgs = {
    /**
     * Select specific fields to fetch from the skillPoint
     */
    select?: skillPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillPointInclude | null
    /**
     * Filter which skillPoint to delete.
     */
    where: skillPointWhereUniqueInput
  }


  /**
   * skillPoint deleteMany
   */
  export type skillPointDeleteManyArgs = {
    /**
     * Filter which skillPoints to delete
     */
    where?: skillPointWhereInput
  }


  /**
   * skillPoint without action
   */
  export type skillPointArgs = {
    /**
     * Select specific fields to fetch from the skillPoint
     */
    select?: skillPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillPointInclude | null
  }



  /**
   * Model spaecialAbility
   */


  export type AggregateSpaecialAbility = {
    _count: SpaecialAbilityCountAggregateOutputType | null
    _avg: SpaecialAbilityAvgAggregateOutputType | null
    _sum: SpaecialAbilitySumAggregateOutputType | null
    _min: SpaecialAbilityMinAggregateOutputType | null
    _max: SpaecialAbilityMaxAggregateOutputType | null
  }

  export type SpaecialAbilityAvgAggregateOutputType = {
    spaecialAbilityId: number | null
    userId: number | null
  }

  export type SpaecialAbilitySumAggregateOutputType = {
    spaecialAbilityId: number | null
    userId: number | null
  }

  export type SpaecialAbilityMinAggregateOutputType = {
    spaecialAbilityId: number | null
    userId: number | null
    skillList: string | null
    skillSelection: boolean | null
  }

  export type SpaecialAbilityMaxAggregateOutputType = {
    spaecialAbilityId: number | null
    userId: number | null
    skillList: string | null
    skillSelection: boolean | null
  }

  export type SpaecialAbilityCountAggregateOutputType = {
    spaecialAbilityId: number
    userId: number
    skillList: number
    skillSelection: number
    _all: number
  }


  export type SpaecialAbilityAvgAggregateInputType = {
    spaecialAbilityId?: true
    userId?: true
  }

  export type SpaecialAbilitySumAggregateInputType = {
    spaecialAbilityId?: true
    userId?: true
  }

  export type SpaecialAbilityMinAggregateInputType = {
    spaecialAbilityId?: true
    userId?: true
    skillList?: true
    skillSelection?: true
  }

  export type SpaecialAbilityMaxAggregateInputType = {
    spaecialAbilityId?: true
    userId?: true
    skillList?: true
    skillSelection?: true
  }

  export type SpaecialAbilityCountAggregateInputType = {
    spaecialAbilityId?: true
    userId?: true
    skillList?: true
    skillSelection?: true
    _all?: true
  }

  export type SpaecialAbilityAggregateArgs = {
    /**
     * Filter which spaecialAbility to aggregate.
     */
    where?: spaecialAbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spaecialAbilities to fetch.
     */
    orderBy?: Enumerable<spaecialAbilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: spaecialAbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spaecialAbilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spaecialAbilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned spaecialAbilities
    **/
    _count?: true | SpaecialAbilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpaecialAbilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpaecialAbilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaecialAbilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaecialAbilityMaxAggregateInputType
  }

  export type GetSpaecialAbilityAggregateType<T extends SpaecialAbilityAggregateArgs> = {
        [P in keyof T & keyof AggregateSpaecialAbility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpaecialAbility[P]>
      : GetScalarType<T[P], AggregateSpaecialAbility[P]>
  }




  export type SpaecialAbilityGroupByArgs = {
    where?: spaecialAbilityWhereInput
    orderBy?: Enumerable<spaecialAbilityOrderByWithAggregationInput>
    by: SpaecialAbilityScalarFieldEnum[]
    having?: spaecialAbilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaecialAbilityCountAggregateInputType | true
    _avg?: SpaecialAbilityAvgAggregateInputType
    _sum?: SpaecialAbilitySumAggregateInputType
    _min?: SpaecialAbilityMinAggregateInputType
    _max?: SpaecialAbilityMaxAggregateInputType
  }


  export type SpaecialAbilityGroupByOutputType = {
    spaecialAbilityId: number
    userId: number
    skillList: string
    skillSelection: boolean
    _count: SpaecialAbilityCountAggregateOutputType | null
    _avg: SpaecialAbilityAvgAggregateOutputType | null
    _sum: SpaecialAbilitySumAggregateOutputType | null
    _min: SpaecialAbilityMinAggregateOutputType | null
    _max: SpaecialAbilityMaxAggregateOutputType | null
  }

  type GetSpaecialAbilityGroupByPayload<T extends SpaecialAbilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SpaecialAbilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaecialAbilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaecialAbilityGroupByOutputType[P]>
            : GetScalarType<T[P], SpaecialAbilityGroupByOutputType[P]>
        }
      >
    >


  export type spaecialAbilitySelect = {
    spaecialAbilityId?: boolean
    userId?: boolean
    skillList?: boolean
    skillSelection?: boolean
    user?: boolean | userArgs
  }


  export type spaecialAbilityInclude = {
    user?: boolean | userArgs
  }

  export type spaecialAbilityGetPayload<S extends boolean | null | undefined | spaecialAbilityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? spaecialAbility :
    S extends undefined ? never :
    S extends { include: any } & (spaecialAbilityArgs | spaecialAbilityFindManyArgs)
    ? spaecialAbility  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (spaecialAbilityArgs | spaecialAbilityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof spaecialAbility ? spaecialAbility[P] : never
  } 
      : spaecialAbility


  type spaecialAbilityCountArgs = 
    Omit<spaecialAbilityFindManyArgs, 'select' | 'include'> & {
      select?: SpaecialAbilityCountAggregateInputType | true
    }

  export interface spaecialAbilityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SpaecialAbility that matches the filter.
     * @param {spaecialAbilityFindUniqueArgs} args - Arguments to find a SpaecialAbility
     * @example
     * // Get one SpaecialAbility
     * const spaecialAbility = await prisma.spaecialAbility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends spaecialAbilityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, spaecialAbilityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'spaecialAbility'> extends True ? Prisma__spaecialAbilityClient<spaecialAbilityGetPayload<T>> : Prisma__spaecialAbilityClient<spaecialAbilityGetPayload<T> | null, null>

    /**
     * Find one SpaecialAbility that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {spaecialAbilityFindUniqueOrThrowArgs} args - Arguments to find a SpaecialAbility
     * @example
     * // Get one SpaecialAbility
     * const spaecialAbility = await prisma.spaecialAbility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends spaecialAbilityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, spaecialAbilityFindUniqueOrThrowArgs>
    ): Prisma__spaecialAbilityClient<spaecialAbilityGetPayload<T>>

    /**
     * Find the first SpaecialAbility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spaecialAbilityFindFirstArgs} args - Arguments to find a SpaecialAbility
     * @example
     * // Get one SpaecialAbility
     * const spaecialAbility = await prisma.spaecialAbility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends spaecialAbilityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, spaecialAbilityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'spaecialAbility'> extends True ? Prisma__spaecialAbilityClient<spaecialAbilityGetPayload<T>> : Prisma__spaecialAbilityClient<spaecialAbilityGetPayload<T> | null, null>

    /**
     * Find the first SpaecialAbility that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spaecialAbilityFindFirstOrThrowArgs} args - Arguments to find a SpaecialAbility
     * @example
     * // Get one SpaecialAbility
     * const spaecialAbility = await prisma.spaecialAbility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends spaecialAbilityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, spaecialAbilityFindFirstOrThrowArgs>
    ): Prisma__spaecialAbilityClient<spaecialAbilityGetPayload<T>>

    /**
     * Find zero or more SpaecialAbilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spaecialAbilityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpaecialAbilities
     * const spaecialAbilities = await prisma.spaecialAbility.findMany()
     * 
     * // Get first 10 SpaecialAbilities
     * const spaecialAbilities = await prisma.spaecialAbility.findMany({ take: 10 })
     * 
     * // Only select the `spaecialAbilityId`
     * const spaecialAbilityWithSpaecialAbilityIdOnly = await prisma.spaecialAbility.findMany({ select: { spaecialAbilityId: true } })
     * 
    **/
    findMany<T extends spaecialAbilityFindManyArgs>(
      args?: SelectSubset<T, spaecialAbilityFindManyArgs>
    ): Prisma.PrismaPromise<Array<spaecialAbilityGetPayload<T>>>

    /**
     * Create a SpaecialAbility.
     * @param {spaecialAbilityCreateArgs} args - Arguments to create a SpaecialAbility.
     * @example
     * // Create one SpaecialAbility
     * const SpaecialAbility = await prisma.spaecialAbility.create({
     *   data: {
     *     // ... data to create a SpaecialAbility
     *   }
     * })
     * 
    **/
    create<T extends spaecialAbilityCreateArgs>(
      args: SelectSubset<T, spaecialAbilityCreateArgs>
    ): Prisma__spaecialAbilityClient<spaecialAbilityGetPayload<T>>

    /**
     * Create many SpaecialAbilities.
     *     @param {spaecialAbilityCreateManyArgs} args - Arguments to create many SpaecialAbilities.
     *     @example
     *     // Create many SpaecialAbilities
     *     const spaecialAbility = await prisma.spaecialAbility.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends spaecialAbilityCreateManyArgs>(
      args?: SelectSubset<T, spaecialAbilityCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpaecialAbility.
     * @param {spaecialAbilityDeleteArgs} args - Arguments to delete one SpaecialAbility.
     * @example
     * // Delete one SpaecialAbility
     * const SpaecialAbility = await prisma.spaecialAbility.delete({
     *   where: {
     *     // ... filter to delete one SpaecialAbility
     *   }
     * })
     * 
    **/
    delete<T extends spaecialAbilityDeleteArgs>(
      args: SelectSubset<T, spaecialAbilityDeleteArgs>
    ): Prisma__spaecialAbilityClient<spaecialAbilityGetPayload<T>>

    /**
     * Update one SpaecialAbility.
     * @param {spaecialAbilityUpdateArgs} args - Arguments to update one SpaecialAbility.
     * @example
     * // Update one SpaecialAbility
     * const spaecialAbility = await prisma.spaecialAbility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends spaecialAbilityUpdateArgs>(
      args: SelectSubset<T, spaecialAbilityUpdateArgs>
    ): Prisma__spaecialAbilityClient<spaecialAbilityGetPayload<T>>

    /**
     * Delete zero or more SpaecialAbilities.
     * @param {spaecialAbilityDeleteManyArgs} args - Arguments to filter SpaecialAbilities to delete.
     * @example
     * // Delete a few SpaecialAbilities
     * const { count } = await prisma.spaecialAbility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends spaecialAbilityDeleteManyArgs>(
      args?: SelectSubset<T, spaecialAbilityDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpaecialAbilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spaecialAbilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpaecialAbilities
     * const spaecialAbility = await prisma.spaecialAbility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends spaecialAbilityUpdateManyArgs>(
      args: SelectSubset<T, spaecialAbilityUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpaecialAbility.
     * @param {spaecialAbilityUpsertArgs} args - Arguments to update or create a SpaecialAbility.
     * @example
     * // Update or create a SpaecialAbility
     * const spaecialAbility = await prisma.spaecialAbility.upsert({
     *   create: {
     *     // ... data to create a SpaecialAbility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpaecialAbility we want to update
     *   }
     * })
    **/
    upsert<T extends spaecialAbilityUpsertArgs>(
      args: SelectSubset<T, spaecialAbilityUpsertArgs>
    ): Prisma__spaecialAbilityClient<spaecialAbilityGetPayload<T>>

    /**
     * Count the number of SpaecialAbilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spaecialAbilityCountArgs} args - Arguments to filter SpaecialAbilities to count.
     * @example
     * // Count the number of SpaecialAbilities
     * const count = await prisma.spaecialAbility.count({
     *   where: {
     *     // ... the filter for the SpaecialAbilities we want to count
     *   }
     * })
    **/
    count<T extends spaecialAbilityCountArgs>(
      args?: Subset<T, spaecialAbilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaecialAbilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpaecialAbility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaecialAbilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaecialAbilityAggregateArgs>(args: Subset<T, SpaecialAbilityAggregateArgs>): Prisma.PrismaPromise<GetSpaecialAbilityAggregateType<T>>

    /**
     * Group by SpaecialAbility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaecialAbilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaecialAbilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaecialAbilityGroupByArgs['orderBy'] }
        : { orderBy?: SpaecialAbilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaecialAbilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaecialAbilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for spaecialAbility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__spaecialAbilityClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * spaecialAbility base type for findUnique actions
   */
  export type spaecialAbilityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the spaecialAbility
     */
    select?: spaecialAbilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: spaecialAbilityInclude | null
    /**
     * Filter, which spaecialAbility to fetch.
     */
    where: spaecialAbilityWhereUniqueInput
  }

  /**
   * spaecialAbility findUnique
   */
  export interface spaecialAbilityFindUniqueArgs extends spaecialAbilityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * spaecialAbility findUniqueOrThrow
   */
  export type spaecialAbilityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the spaecialAbility
     */
    select?: spaecialAbilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: spaecialAbilityInclude | null
    /**
     * Filter, which spaecialAbility to fetch.
     */
    where: spaecialAbilityWhereUniqueInput
  }


  /**
   * spaecialAbility base type for findFirst actions
   */
  export type spaecialAbilityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the spaecialAbility
     */
    select?: spaecialAbilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: spaecialAbilityInclude | null
    /**
     * Filter, which spaecialAbility to fetch.
     */
    where?: spaecialAbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spaecialAbilities to fetch.
     */
    orderBy?: Enumerable<spaecialAbilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spaecialAbilities.
     */
    cursor?: spaecialAbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spaecialAbilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spaecialAbilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spaecialAbilities.
     */
    distinct?: Enumerable<SpaecialAbilityScalarFieldEnum>
  }

  /**
   * spaecialAbility findFirst
   */
  export interface spaecialAbilityFindFirstArgs extends spaecialAbilityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * spaecialAbility findFirstOrThrow
   */
  export type spaecialAbilityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the spaecialAbility
     */
    select?: spaecialAbilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: spaecialAbilityInclude | null
    /**
     * Filter, which spaecialAbility to fetch.
     */
    where?: spaecialAbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spaecialAbilities to fetch.
     */
    orderBy?: Enumerable<spaecialAbilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spaecialAbilities.
     */
    cursor?: spaecialAbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spaecialAbilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spaecialAbilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spaecialAbilities.
     */
    distinct?: Enumerable<SpaecialAbilityScalarFieldEnum>
  }


  /**
   * spaecialAbility findMany
   */
  export type spaecialAbilityFindManyArgs = {
    /**
     * Select specific fields to fetch from the spaecialAbility
     */
    select?: spaecialAbilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: spaecialAbilityInclude | null
    /**
     * Filter, which spaecialAbilities to fetch.
     */
    where?: spaecialAbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spaecialAbilities to fetch.
     */
    orderBy?: Enumerable<spaecialAbilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing spaecialAbilities.
     */
    cursor?: spaecialAbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spaecialAbilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spaecialAbilities.
     */
    skip?: number
    distinct?: Enumerable<SpaecialAbilityScalarFieldEnum>
  }


  /**
   * spaecialAbility create
   */
  export type spaecialAbilityCreateArgs = {
    /**
     * Select specific fields to fetch from the spaecialAbility
     */
    select?: spaecialAbilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: spaecialAbilityInclude | null
    /**
     * The data needed to create a spaecialAbility.
     */
    data: XOR<spaecialAbilityCreateInput, spaecialAbilityUncheckedCreateInput>
  }


  /**
   * spaecialAbility createMany
   */
  export type spaecialAbilityCreateManyArgs = {
    /**
     * The data used to create many spaecialAbilities.
     */
    data: Enumerable<spaecialAbilityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * spaecialAbility update
   */
  export type spaecialAbilityUpdateArgs = {
    /**
     * Select specific fields to fetch from the spaecialAbility
     */
    select?: spaecialAbilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: spaecialAbilityInclude | null
    /**
     * The data needed to update a spaecialAbility.
     */
    data: XOR<spaecialAbilityUpdateInput, spaecialAbilityUncheckedUpdateInput>
    /**
     * Choose, which spaecialAbility to update.
     */
    where: spaecialAbilityWhereUniqueInput
  }


  /**
   * spaecialAbility updateMany
   */
  export type spaecialAbilityUpdateManyArgs = {
    /**
     * The data used to update spaecialAbilities.
     */
    data: XOR<spaecialAbilityUpdateManyMutationInput, spaecialAbilityUncheckedUpdateManyInput>
    /**
     * Filter which spaecialAbilities to update
     */
    where?: spaecialAbilityWhereInput
  }


  /**
   * spaecialAbility upsert
   */
  export type spaecialAbilityUpsertArgs = {
    /**
     * Select specific fields to fetch from the spaecialAbility
     */
    select?: spaecialAbilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: spaecialAbilityInclude | null
    /**
     * The filter to search for the spaecialAbility to update in case it exists.
     */
    where: spaecialAbilityWhereUniqueInput
    /**
     * In case the spaecialAbility found by the `where` argument doesn't exist, create a new spaecialAbility with this data.
     */
    create: XOR<spaecialAbilityCreateInput, spaecialAbilityUncheckedCreateInput>
    /**
     * In case the spaecialAbility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<spaecialAbilityUpdateInput, spaecialAbilityUncheckedUpdateInput>
  }


  /**
   * spaecialAbility delete
   */
  export type spaecialAbilityDeleteArgs = {
    /**
     * Select specific fields to fetch from the spaecialAbility
     */
    select?: spaecialAbilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: spaecialAbilityInclude | null
    /**
     * Filter which spaecialAbility to delete.
     */
    where: spaecialAbilityWhereUniqueInput
  }


  /**
   * spaecialAbility deleteMany
   */
  export type spaecialAbilityDeleteManyArgs = {
    /**
     * Filter which spaecialAbilities to delete
     */
    where?: spaecialAbilityWhereInput
  }


  /**
   * spaecialAbility without action
   */
  export type spaecialAbilityArgs = {
    /**
     * Select specific fields to fetch from the spaecialAbility
     */
    select?: spaecialAbilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: spaecialAbilityInclude | null
  }



  /**
   * Model spec
   */


  export type AggregateSpec = {
    _count: SpecCountAggregateOutputType | null
    _avg: SpecAvgAggregateOutputType | null
    _sum: SpecSumAggregateOutputType | null
    _min: SpecMinAggregateOutputType | null
    _max: SpecMaxAggregateOutputType | null
  }

  export type SpecAvgAggregateOutputType = {
    specId: number | null
    userId: number | null
  }

  export type SpecSumAggregateOutputType = {
    specId: number | null
    userId: number | null
  }

  export type SpecMinAggregateOutputType = {
    specId: number | null
    userId: number | null
    github: string | null
    offHours: string | null
    createdAt: Date | null
  }

  export type SpecMaxAggregateOutputType = {
    specId: number | null
    userId: number | null
    github: string | null
    offHours: string | null
    createdAt: Date | null
  }

  export type SpecCountAggregateOutputType = {
    specId: number
    userId: number
    github: number
    offHours: number
    createdAt: number
    _all: number
  }


  export type SpecAvgAggregateInputType = {
    specId?: true
    userId?: true
  }

  export type SpecSumAggregateInputType = {
    specId?: true
    userId?: true
  }

  export type SpecMinAggregateInputType = {
    specId?: true
    userId?: true
    github?: true
    offHours?: true
    createdAt?: true
  }

  export type SpecMaxAggregateInputType = {
    specId?: true
    userId?: true
    github?: true
    offHours?: true
    createdAt?: true
  }

  export type SpecCountAggregateInputType = {
    specId?: true
    userId?: true
    github?: true
    offHours?: true
    createdAt?: true
    _all?: true
  }

  export type SpecAggregateArgs = {
    /**
     * Filter which spec to aggregate.
     */
    where?: specWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specs to fetch.
     */
    orderBy?: Enumerable<specOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: specWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned specs
    **/
    _count?: true | SpecCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecMaxAggregateInputType
  }

  export type GetSpecAggregateType<T extends SpecAggregateArgs> = {
        [P in keyof T & keyof AggregateSpec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpec[P]>
      : GetScalarType<T[P], AggregateSpec[P]>
  }




  export type SpecGroupByArgs = {
    where?: specWhereInput
    orderBy?: Enumerable<specOrderByWithAggregationInput>
    by: SpecScalarFieldEnum[]
    having?: specScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecCountAggregateInputType | true
    _avg?: SpecAvgAggregateInputType
    _sum?: SpecSumAggregateInputType
    _min?: SpecMinAggregateInputType
    _max?: SpecMaxAggregateInputType
  }


  export type SpecGroupByOutputType = {
    specId: number
    userId: number
    github: string
    offHours: string
    createdAt: Date
    _count: SpecCountAggregateOutputType | null
    _avg: SpecAvgAggregateOutputType | null
    _sum: SpecSumAggregateOutputType | null
    _min: SpecMinAggregateOutputType | null
    _max: SpecMaxAggregateOutputType | null
  }

  type GetSpecGroupByPayload<T extends SpecGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SpecGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecGroupByOutputType[P]>
            : GetScalarType<T[P], SpecGroupByOutputType[P]>
        }
      >
    >


  export type specSelect = {
    specId?: boolean
    userId?: boolean
    github?: boolean
    offHours?: boolean
    createdAt?: boolean
    user?: boolean | userArgs
    portfolios?: boolean | spec$portfoliosArgs
    skillSummaries?: boolean | spec$skillSummariesArgs
    sellingPoints?: boolean | spec$sellingPointsArgs
    qualifications?: boolean | spec$qualificationsArgs
    previousWorks?: boolean | spec$previousWorksArgs
    developmentExperiences?: boolean | spec$developmentExperiencesArgs
    _count?: boolean | SpecCountOutputTypeArgs
  }


  export type specInclude = {
    user?: boolean | userArgs
    portfolios?: boolean | spec$portfoliosArgs
    skillSummaries?: boolean | spec$skillSummariesArgs
    sellingPoints?: boolean | spec$sellingPointsArgs
    qualifications?: boolean | spec$qualificationsArgs
    previousWorks?: boolean | spec$previousWorksArgs
    developmentExperiences?: boolean | spec$developmentExperiencesArgs
    _count?: boolean | SpecCountOutputTypeArgs
  }

  export type specGetPayload<S extends boolean | null | undefined | specArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? spec :
    S extends undefined ? never :
    S extends { include: any } & (specArgs | specFindManyArgs)
    ? spec  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends 'portfolios' ? Array < portfolioGetPayload<S['include'][P]>>  :
        P extends 'skillSummaries' ? Array < skillSummaryGetPayload<S['include'][P]>>  :
        P extends 'sellingPoints' ? Array < sellingPointGetPayload<S['include'][P]>>  :
        P extends 'qualifications' ? Array < qualificationGetPayload<S['include'][P]>>  :
        P extends 'previousWorks' ? Array < previousWorkGetPayload<S['include'][P]>>  :
        P extends 'developmentExperiences' ? Array < developmentExperienceGetPayload<S['include'][P]>>  :
        P extends '_count' ? SpecCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (specArgs | specFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends 'portfolios' ? Array < portfolioGetPayload<S['select'][P]>>  :
        P extends 'skillSummaries' ? Array < skillSummaryGetPayload<S['select'][P]>>  :
        P extends 'sellingPoints' ? Array < sellingPointGetPayload<S['select'][P]>>  :
        P extends 'qualifications' ? Array < qualificationGetPayload<S['select'][P]>>  :
        P extends 'previousWorks' ? Array < previousWorkGetPayload<S['select'][P]>>  :
        P extends 'developmentExperiences' ? Array < developmentExperienceGetPayload<S['select'][P]>>  :
        P extends '_count' ? SpecCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof spec ? spec[P] : never
  } 
      : spec


  type specCountArgs = 
    Omit<specFindManyArgs, 'select' | 'include'> & {
      select?: SpecCountAggregateInputType | true
    }

  export interface specDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Spec that matches the filter.
     * @param {specFindUniqueArgs} args - Arguments to find a Spec
     * @example
     * // Get one Spec
     * const spec = await prisma.spec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends specFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, specFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'spec'> extends True ? Prisma__specClient<specGetPayload<T>> : Prisma__specClient<specGetPayload<T> | null, null>

    /**
     * Find one Spec that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {specFindUniqueOrThrowArgs} args - Arguments to find a Spec
     * @example
     * // Get one Spec
     * const spec = await prisma.spec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends specFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, specFindUniqueOrThrowArgs>
    ): Prisma__specClient<specGetPayload<T>>

    /**
     * Find the first Spec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specFindFirstArgs} args - Arguments to find a Spec
     * @example
     * // Get one Spec
     * const spec = await prisma.spec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends specFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, specFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'spec'> extends True ? Prisma__specClient<specGetPayload<T>> : Prisma__specClient<specGetPayload<T> | null, null>

    /**
     * Find the first Spec that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specFindFirstOrThrowArgs} args - Arguments to find a Spec
     * @example
     * // Get one Spec
     * const spec = await prisma.spec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends specFindFirstOrThrowArgs>(
      args?: SelectSubset<T, specFindFirstOrThrowArgs>
    ): Prisma__specClient<specGetPayload<T>>

    /**
     * Find zero or more Specs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specs
     * const specs = await prisma.spec.findMany()
     * 
     * // Get first 10 Specs
     * const specs = await prisma.spec.findMany({ take: 10 })
     * 
     * // Only select the `specId`
     * const specWithSpecIdOnly = await prisma.spec.findMany({ select: { specId: true } })
     * 
    **/
    findMany<T extends specFindManyArgs>(
      args?: SelectSubset<T, specFindManyArgs>
    ): Prisma.PrismaPromise<Array<specGetPayload<T>>>

    /**
     * Create a Spec.
     * @param {specCreateArgs} args - Arguments to create a Spec.
     * @example
     * // Create one Spec
     * const Spec = await prisma.spec.create({
     *   data: {
     *     // ... data to create a Spec
     *   }
     * })
     * 
    **/
    create<T extends specCreateArgs>(
      args: SelectSubset<T, specCreateArgs>
    ): Prisma__specClient<specGetPayload<T>>

    /**
     * Create many Specs.
     *     @param {specCreateManyArgs} args - Arguments to create many Specs.
     *     @example
     *     // Create many Specs
     *     const spec = await prisma.spec.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends specCreateManyArgs>(
      args?: SelectSubset<T, specCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Spec.
     * @param {specDeleteArgs} args - Arguments to delete one Spec.
     * @example
     * // Delete one Spec
     * const Spec = await prisma.spec.delete({
     *   where: {
     *     // ... filter to delete one Spec
     *   }
     * })
     * 
    **/
    delete<T extends specDeleteArgs>(
      args: SelectSubset<T, specDeleteArgs>
    ): Prisma__specClient<specGetPayload<T>>

    /**
     * Update one Spec.
     * @param {specUpdateArgs} args - Arguments to update one Spec.
     * @example
     * // Update one Spec
     * const spec = await prisma.spec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends specUpdateArgs>(
      args: SelectSubset<T, specUpdateArgs>
    ): Prisma__specClient<specGetPayload<T>>

    /**
     * Delete zero or more Specs.
     * @param {specDeleteManyArgs} args - Arguments to filter Specs to delete.
     * @example
     * // Delete a few Specs
     * const { count } = await prisma.spec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends specDeleteManyArgs>(
      args?: SelectSubset<T, specDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specs
     * const spec = await prisma.spec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends specUpdateManyArgs>(
      args: SelectSubset<T, specUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Spec.
     * @param {specUpsertArgs} args - Arguments to update or create a Spec.
     * @example
     * // Update or create a Spec
     * const spec = await prisma.spec.upsert({
     *   create: {
     *     // ... data to create a Spec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spec we want to update
     *   }
     * })
    **/
    upsert<T extends specUpsertArgs>(
      args: SelectSubset<T, specUpsertArgs>
    ): Prisma__specClient<specGetPayload<T>>

    /**
     * Count the number of Specs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specCountArgs} args - Arguments to filter Specs to count.
     * @example
     * // Count the number of Specs
     * const count = await prisma.spec.count({
     *   where: {
     *     // ... the filter for the Specs we want to count
     *   }
     * })
    **/
    count<T extends specCountArgs>(
      args?: Subset<T, specCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecAggregateArgs>(args: Subset<T, SpecAggregateArgs>): Prisma.PrismaPromise<GetSpecAggregateType<T>>

    /**
     * Group by Spec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecGroupByArgs['orderBy'] }
        : { orderBy?: SpecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for spec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__specClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    portfolios<T extends spec$portfoliosArgs= {}>(args?: Subset<T, spec$portfoliosArgs>): Prisma.PrismaPromise<Array<portfolioGetPayload<T>>| Null>;

    skillSummaries<T extends spec$skillSummariesArgs= {}>(args?: Subset<T, spec$skillSummariesArgs>): Prisma.PrismaPromise<Array<skillSummaryGetPayload<T>>| Null>;

    sellingPoints<T extends spec$sellingPointsArgs= {}>(args?: Subset<T, spec$sellingPointsArgs>): Prisma.PrismaPromise<Array<sellingPointGetPayload<T>>| Null>;

    qualifications<T extends spec$qualificationsArgs= {}>(args?: Subset<T, spec$qualificationsArgs>): Prisma.PrismaPromise<Array<qualificationGetPayload<T>>| Null>;

    previousWorks<T extends spec$previousWorksArgs= {}>(args?: Subset<T, spec$previousWorksArgs>): Prisma.PrismaPromise<Array<previousWorkGetPayload<T>>| Null>;

    developmentExperiences<T extends spec$developmentExperiencesArgs= {}>(args?: Subset<T, spec$developmentExperiencesArgs>): Prisma.PrismaPromise<Array<developmentExperienceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * spec base type for findUnique actions
   */
  export type specFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the spec
     */
    select?: specSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: specInclude | null
    /**
     * Filter, which spec to fetch.
     */
    where: specWhereUniqueInput
  }

  /**
   * spec findUnique
   */
  export interface specFindUniqueArgs extends specFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * spec findUniqueOrThrow
   */
  export type specFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the spec
     */
    select?: specSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: specInclude | null
    /**
     * Filter, which spec to fetch.
     */
    where: specWhereUniqueInput
  }


  /**
   * spec base type for findFirst actions
   */
  export type specFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the spec
     */
    select?: specSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: specInclude | null
    /**
     * Filter, which spec to fetch.
     */
    where?: specWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specs to fetch.
     */
    orderBy?: Enumerable<specOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for specs.
     */
    cursor?: specWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of specs.
     */
    distinct?: Enumerable<SpecScalarFieldEnum>
  }

  /**
   * spec findFirst
   */
  export interface specFindFirstArgs extends specFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * spec findFirstOrThrow
   */
  export type specFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the spec
     */
    select?: specSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: specInclude | null
    /**
     * Filter, which spec to fetch.
     */
    where?: specWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specs to fetch.
     */
    orderBy?: Enumerable<specOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for specs.
     */
    cursor?: specWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of specs.
     */
    distinct?: Enumerable<SpecScalarFieldEnum>
  }


  /**
   * spec findMany
   */
  export type specFindManyArgs = {
    /**
     * Select specific fields to fetch from the spec
     */
    select?: specSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: specInclude | null
    /**
     * Filter, which specs to fetch.
     */
    where?: specWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specs to fetch.
     */
    orderBy?: Enumerable<specOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing specs.
     */
    cursor?: specWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specs.
     */
    skip?: number
    distinct?: Enumerable<SpecScalarFieldEnum>
  }


  /**
   * spec create
   */
  export type specCreateArgs = {
    /**
     * Select specific fields to fetch from the spec
     */
    select?: specSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: specInclude | null
    /**
     * The data needed to create a spec.
     */
    data: XOR<specCreateInput, specUncheckedCreateInput>
  }


  /**
   * spec createMany
   */
  export type specCreateManyArgs = {
    /**
     * The data used to create many specs.
     */
    data: Enumerable<specCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * spec update
   */
  export type specUpdateArgs = {
    /**
     * Select specific fields to fetch from the spec
     */
    select?: specSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: specInclude | null
    /**
     * The data needed to update a spec.
     */
    data: XOR<specUpdateInput, specUncheckedUpdateInput>
    /**
     * Choose, which spec to update.
     */
    where: specWhereUniqueInput
  }


  /**
   * spec updateMany
   */
  export type specUpdateManyArgs = {
    /**
     * The data used to update specs.
     */
    data: XOR<specUpdateManyMutationInput, specUncheckedUpdateManyInput>
    /**
     * Filter which specs to update
     */
    where?: specWhereInput
  }


  /**
   * spec upsert
   */
  export type specUpsertArgs = {
    /**
     * Select specific fields to fetch from the spec
     */
    select?: specSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: specInclude | null
    /**
     * The filter to search for the spec to update in case it exists.
     */
    where: specWhereUniqueInput
    /**
     * In case the spec found by the `where` argument doesn't exist, create a new spec with this data.
     */
    create: XOR<specCreateInput, specUncheckedCreateInput>
    /**
     * In case the spec was found with the provided `where` argument, update it with this data.
     */
    update: XOR<specUpdateInput, specUncheckedUpdateInput>
  }


  /**
   * spec delete
   */
  export type specDeleteArgs = {
    /**
     * Select specific fields to fetch from the spec
     */
    select?: specSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: specInclude | null
    /**
     * Filter which spec to delete.
     */
    where: specWhereUniqueInput
  }


  /**
   * spec deleteMany
   */
  export type specDeleteManyArgs = {
    /**
     * Filter which specs to delete
     */
    where?: specWhereInput
  }


  /**
   * spec.portfolios
   */
  export type spec$portfoliosArgs = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: portfolioInclude | null
    where?: portfolioWhereInput
    orderBy?: Enumerable<portfolioOrderByWithRelationInput>
    cursor?: portfolioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PortfolioScalarFieldEnum>
  }


  /**
   * spec.skillSummaries
   */
  export type spec$skillSummariesArgs = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
    where?: skillSummaryWhereInput
    orderBy?: Enumerable<skillSummaryOrderByWithRelationInput>
    cursor?: skillSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SkillSummaryScalarFieldEnum>
  }


  /**
   * spec.sellingPoints
   */
  export type spec$sellingPointsArgs = {
    /**
     * Select specific fields to fetch from the sellingPoint
     */
    select?: sellingPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sellingPointInclude | null
    where?: sellingPointWhereInput
    orderBy?: Enumerable<sellingPointOrderByWithRelationInput>
    cursor?: sellingPointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SellingPointScalarFieldEnum>
  }


  /**
   * spec.qualifications
   */
  export type spec$qualificationsArgs = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qualificationInclude | null
    where?: qualificationWhereInput
    orderBy?: Enumerable<qualificationOrderByWithRelationInput>
    cursor?: qualificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QualificationScalarFieldEnum>
  }


  /**
   * spec.previousWorks
   */
  export type spec$previousWorksArgs = {
    /**
     * Select specific fields to fetch from the previousWork
     */
    select?: previousWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: previousWorkInclude | null
    where?: previousWorkWhereInput
    orderBy?: Enumerable<previousWorkOrderByWithRelationInput>
    cursor?: previousWorkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PreviousWorkScalarFieldEnum>
  }


  /**
   * spec.developmentExperiences
   */
  export type spec$developmentExperiencesArgs = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
    where?: developmentExperienceWhereInput
    orderBy?: Enumerable<developmentExperienceOrderByWithRelationInput>
    cursor?: developmentExperienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DevelopmentExperienceScalarFieldEnum>
  }


  /**
   * spec without action
   */
  export type specArgs = {
    /**
     * Select specific fields to fetch from the spec
     */
    select?: specSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: specInclude | null
  }



  /**
   * Model portfolio
   */


  export type AggregatePortfolio = {
    _count: PortfolioCountAggregateOutputType | null
    _avg: PortfolioAvgAggregateOutputType | null
    _sum: PortfolioSumAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  export type PortfolioAvgAggregateOutputType = {
    portfolioId: number | null
    specId: number | null
  }

  export type PortfolioSumAggregateOutputType = {
    portfolioId: number | null
    specId: number | null
  }

  export type PortfolioMinAggregateOutputType = {
    portfolioId: number | null
    specId: number | null
    heading: string | null
    url: string | null
  }

  export type PortfolioMaxAggregateOutputType = {
    portfolioId: number | null
    specId: number | null
    heading: string | null
    url: string | null
  }

  export type PortfolioCountAggregateOutputType = {
    portfolioId: number
    specId: number
    heading: number
    url: number
    _all: number
  }


  export type PortfolioAvgAggregateInputType = {
    portfolioId?: true
    specId?: true
  }

  export type PortfolioSumAggregateInputType = {
    portfolioId?: true
    specId?: true
  }

  export type PortfolioMinAggregateInputType = {
    portfolioId?: true
    specId?: true
    heading?: true
    url?: true
  }

  export type PortfolioMaxAggregateInputType = {
    portfolioId?: true
    specId?: true
    heading?: true
    url?: true
  }

  export type PortfolioCountAggregateInputType = {
    portfolioId?: true
    specId?: true
    heading?: true
    url?: true
    _all?: true
  }

  export type PortfolioAggregateArgs = {
    /**
     * Filter which portfolio to aggregate.
     */
    where?: portfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolios to fetch.
     */
    orderBy?: Enumerable<portfolioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: portfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned portfolios
    **/
    _count?: true | PortfolioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortfolioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortfolioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioMaxAggregateInputType
  }

  export type GetPortfolioAggregateType<T extends PortfolioAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolio[P]>
      : GetScalarType<T[P], AggregatePortfolio[P]>
  }




  export type PortfolioGroupByArgs = {
    where?: portfolioWhereInput
    orderBy?: Enumerable<portfolioOrderByWithAggregationInput>
    by: PortfolioScalarFieldEnum[]
    having?: portfolioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioCountAggregateInputType | true
    _avg?: PortfolioAvgAggregateInputType
    _sum?: PortfolioSumAggregateInputType
    _min?: PortfolioMinAggregateInputType
    _max?: PortfolioMaxAggregateInputType
  }


  export type PortfolioGroupByOutputType = {
    portfolioId: number
    specId: number
    heading: string
    url: string
    _count: PortfolioCountAggregateOutputType | null
    _avg: PortfolioAvgAggregateOutputType | null
    _sum: PortfolioSumAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  type GetPortfolioGroupByPayload<T extends PortfolioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PortfolioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
        }
      >
    >


  export type portfolioSelect = {
    portfolioId?: boolean
    specId?: boolean
    heading?: boolean
    url?: boolean
    spec?: boolean | specArgs
  }


  export type portfolioInclude = {
    spec?: boolean | specArgs
  }

  export type portfolioGetPayload<S extends boolean | null | undefined | portfolioArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? portfolio :
    S extends undefined ? never :
    S extends { include: any } & (portfolioArgs | portfolioFindManyArgs)
    ? portfolio  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'spec' ? specGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (portfolioArgs | portfolioFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'spec' ? specGetPayload<S['select'][P]> :  P extends keyof portfolio ? portfolio[P] : never
  } 
      : portfolio


  type portfolioCountArgs = 
    Omit<portfolioFindManyArgs, 'select' | 'include'> & {
      select?: PortfolioCountAggregateInputType | true
    }

  export interface portfolioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Portfolio that matches the filter.
     * @param {portfolioFindUniqueArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends portfolioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, portfolioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'portfolio'> extends True ? Prisma__portfolioClient<portfolioGetPayload<T>> : Prisma__portfolioClient<portfolioGetPayload<T> | null, null>

    /**
     * Find one Portfolio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {portfolioFindUniqueOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends portfolioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, portfolioFindUniqueOrThrowArgs>
    ): Prisma__portfolioClient<portfolioGetPayload<T>>

    /**
     * Find the first Portfolio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioFindFirstArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends portfolioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, portfolioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'portfolio'> extends True ? Prisma__portfolioClient<portfolioGetPayload<T>> : Prisma__portfolioClient<portfolioGetPayload<T> | null, null>

    /**
     * Find the first Portfolio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioFindFirstOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends portfolioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, portfolioFindFirstOrThrowArgs>
    ): Prisma__portfolioClient<portfolioGetPayload<T>>

    /**
     * Find zero or more Portfolios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portfolios
     * const portfolios = await prisma.portfolio.findMany()
     * 
     * // Get first 10 Portfolios
     * const portfolios = await prisma.portfolio.findMany({ take: 10 })
     * 
     * // Only select the `portfolioId`
     * const portfolioWithPortfolioIdOnly = await prisma.portfolio.findMany({ select: { portfolioId: true } })
     * 
    **/
    findMany<T extends portfolioFindManyArgs>(
      args?: SelectSubset<T, portfolioFindManyArgs>
    ): Prisma.PrismaPromise<Array<portfolioGetPayload<T>>>

    /**
     * Create a Portfolio.
     * @param {portfolioCreateArgs} args - Arguments to create a Portfolio.
     * @example
     * // Create one Portfolio
     * const Portfolio = await prisma.portfolio.create({
     *   data: {
     *     // ... data to create a Portfolio
     *   }
     * })
     * 
    **/
    create<T extends portfolioCreateArgs>(
      args: SelectSubset<T, portfolioCreateArgs>
    ): Prisma__portfolioClient<portfolioGetPayload<T>>

    /**
     * Create many Portfolios.
     *     @param {portfolioCreateManyArgs} args - Arguments to create many Portfolios.
     *     @example
     *     // Create many Portfolios
     *     const portfolio = await prisma.portfolio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends portfolioCreateManyArgs>(
      args?: SelectSubset<T, portfolioCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Portfolio.
     * @param {portfolioDeleteArgs} args - Arguments to delete one Portfolio.
     * @example
     * // Delete one Portfolio
     * const Portfolio = await prisma.portfolio.delete({
     *   where: {
     *     // ... filter to delete one Portfolio
     *   }
     * })
     * 
    **/
    delete<T extends portfolioDeleteArgs>(
      args: SelectSubset<T, portfolioDeleteArgs>
    ): Prisma__portfolioClient<portfolioGetPayload<T>>

    /**
     * Update one Portfolio.
     * @param {portfolioUpdateArgs} args - Arguments to update one Portfolio.
     * @example
     * // Update one Portfolio
     * const portfolio = await prisma.portfolio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends portfolioUpdateArgs>(
      args: SelectSubset<T, portfolioUpdateArgs>
    ): Prisma__portfolioClient<portfolioGetPayload<T>>

    /**
     * Delete zero or more Portfolios.
     * @param {portfolioDeleteManyArgs} args - Arguments to filter Portfolios to delete.
     * @example
     * // Delete a few Portfolios
     * const { count } = await prisma.portfolio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends portfolioDeleteManyArgs>(
      args?: SelectSubset<T, portfolioDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends portfolioUpdateManyArgs>(
      args: SelectSubset<T, portfolioUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Portfolio.
     * @param {portfolioUpsertArgs} args - Arguments to update or create a Portfolio.
     * @example
     * // Update or create a Portfolio
     * const portfolio = await prisma.portfolio.upsert({
     *   create: {
     *     // ... data to create a Portfolio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portfolio we want to update
     *   }
     * })
    **/
    upsert<T extends portfolioUpsertArgs>(
      args: SelectSubset<T, portfolioUpsertArgs>
    ): Prisma__portfolioClient<portfolioGetPayload<T>>

    /**
     * Count the number of Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioCountArgs} args - Arguments to filter Portfolios to count.
     * @example
     * // Count the number of Portfolios
     * const count = await prisma.portfolio.count({
     *   where: {
     *     // ... the filter for the Portfolios we want to count
     *   }
     * })
    **/
    count<T extends portfolioCountArgs>(
      args?: Subset<T, portfolioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioAggregateArgs>(args: Subset<T, PortfolioAggregateArgs>): Prisma.PrismaPromise<GetPortfolioAggregateType<T>>

    /**
     * Group by Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for portfolio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__portfolioClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    spec<T extends specArgs= {}>(args?: Subset<T, specArgs>): Prisma__specClient<specGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * portfolio base type for findUnique actions
   */
  export type portfolioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: portfolioInclude | null
    /**
     * Filter, which portfolio to fetch.
     */
    where: portfolioWhereUniqueInput
  }

  /**
   * portfolio findUnique
   */
  export interface portfolioFindUniqueArgs extends portfolioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * portfolio findUniqueOrThrow
   */
  export type portfolioFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: portfolioInclude | null
    /**
     * Filter, which portfolio to fetch.
     */
    where: portfolioWhereUniqueInput
  }


  /**
   * portfolio base type for findFirst actions
   */
  export type portfolioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: portfolioInclude | null
    /**
     * Filter, which portfolio to fetch.
     */
    where?: portfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolios to fetch.
     */
    orderBy?: Enumerable<portfolioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for portfolios.
     */
    cursor?: portfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of portfolios.
     */
    distinct?: Enumerable<PortfolioScalarFieldEnum>
  }

  /**
   * portfolio findFirst
   */
  export interface portfolioFindFirstArgs extends portfolioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * portfolio findFirstOrThrow
   */
  export type portfolioFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: portfolioInclude | null
    /**
     * Filter, which portfolio to fetch.
     */
    where?: portfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolios to fetch.
     */
    orderBy?: Enumerable<portfolioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for portfolios.
     */
    cursor?: portfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of portfolios.
     */
    distinct?: Enumerable<PortfolioScalarFieldEnum>
  }


  /**
   * portfolio findMany
   */
  export type portfolioFindManyArgs = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: portfolioInclude | null
    /**
     * Filter, which portfolios to fetch.
     */
    where?: portfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolios to fetch.
     */
    orderBy?: Enumerable<portfolioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing portfolios.
     */
    cursor?: portfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolios.
     */
    skip?: number
    distinct?: Enumerable<PortfolioScalarFieldEnum>
  }


  /**
   * portfolio create
   */
  export type portfolioCreateArgs = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: portfolioInclude | null
    /**
     * The data needed to create a portfolio.
     */
    data: XOR<portfolioCreateInput, portfolioUncheckedCreateInput>
  }


  /**
   * portfolio createMany
   */
  export type portfolioCreateManyArgs = {
    /**
     * The data used to create many portfolios.
     */
    data: Enumerable<portfolioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * portfolio update
   */
  export type portfolioUpdateArgs = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: portfolioInclude | null
    /**
     * The data needed to update a portfolio.
     */
    data: XOR<portfolioUpdateInput, portfolioUncheckedUpdateInput>
    /**
     * Choose, which portfolio to update.
     */
    where: portfolioWhereUniqueInput
  }


  /**
   * portfolio updateMany
   */
  export type portfolioUpdateManyArgs = {
    /**
     * The data used to update portfolios.
     */
    data: XOR<portfolioUpdateManyMutationInput, portfolioUncheckedUpdateManyInput>
    /**
     * Filter which portfolios to update
     */
    where?: portfolioWhereInput
  }


  /**
   * portfolio upsert
   */
  export type portfolioUpsertArgs = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: portfolioInclude | null
    /**
     * The filter to search for the portfolio to update in case it exists.
     */
    where: portfolioWhereUniqueInput
    /**
     * In case the portfolio found by the `where` argument doesn't exist, create a new portfolio with this data.
     */
    create: XOR<portfolioCreateInput, portfolioUncheckedCreateInput>
    /**
     * In case the portfolio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<portfolioUpdateInput, portfolioUncheckedUpdateInput>
  }


  /**
   * portfolio delete
   */
  export type portfolioDeleteArgs = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: portfolioInclude | null
    /**
     * Filter which portfolio to delete.
     */
    where: portfolioWhereUniqueInput
  }


  /**
   * portfolio deleteMany
   */
  export type portfolioDeleteManyArgs = {
    /**
     * Filter which portfolios to delete
     */
    where?: portfolioWhereInput
  }


  /**
   * portfolio without action
   */
  export type portfolioArgs = {
    /**
     * Select specific fields to fetch from the portfolio
     */
    select?: portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: portfolioInclude | null
  }



  /**
   * Model skillSummary
   */


  export type AggregateSkillSummary = {
    _count: SkillSummaryCountAggregateOutputType | null
    _avg: SkillSummaryAvgAggregateOutputType | null
    _sum: SkillSummarySumAggregateOutputType | null
    _min: SkillSummaryMinAggregateOutputType | null
    _max: SkillSummaryMaxAggregateOutputType | null
  }

  export type SkillSummaryAvgAggregateOutputType = {
    skillSummaryId: number | null
    specId: number | null
    autoCalibrationId: number | null
  }

  export type SkillSummarySumAggregateOutputType = {
    skillSummaryId: number | null
    specId: number | null
    autoCalibrationId: number | null
  }

  export type SkillSummaryMinAggregateOutputType = {
    skillSummaryId: number | null
    specId: number | null
    autoCalibrationId: number | null
  }

  export type SkillSummaryMaxAggregateOutputType = {
    skillSummaryId: number | null
    specId: number | null
    autoCalibrationId: number | null
  }

  export type SkillSummaryCountAggregateOutputType = {
    skillSummaryId: number
    specId: number
    autoCalibrationId: number
    _all: number
  }


  export type SkillSummaryAvgAggregateInputType = {
    skillSummaryId?: true
    specId?: true
    autoCalibrationId?: true
  }

  export type SkillSummarySumAggregateInputType = {
    skillSummaryId?: true
    specId?: true
    autoCalibrationId?: true
  }

  export type SkillSummaryMinAggregateInputType = {
    skillSummaryId?: true
    specId?: true
    autoCalibrationId?: true
  }

  export type SkillSummaryMaxAggregateInputType = {
    skillSummaryId?: true
    specId?: true
    autoCalibrationId?: true
  }

  export type SkillSummaryCountAggregateInputType = {
    skillSummaryId?: true
    specId?: true
    autoCalibrationId?: true
    _all?: true
  }

  export type SkillSummaryAggregateArgs = {
    /**
     * Filter which skillSummary to aggregate.
     */
    where?: skillSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillSummaries to fetch.
     */
    orderBy?: Enumerable<skillSummaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skillSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skillSummaries
    **/
    _count?: true | SkillSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillSummaryMaxAggregateInputType
  }

  export type GetSkillSummaryAggregateType<T extends SkillSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillSummary[P]>
      : GetScalarType<T[P], AggregateSkillSummary[P]>
  }




  export type SkillSummaryGroupByArgs = {
    where?: skillSummaryWhereInput
    orderBy?: Enumerable<skillSummaryOrderByWithAggregationInput>
    by: SkillSummaryScalarFieldEnum[]
    having?: skillSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillSummaryCountAggregateInputType | true
    _avg?: SkillSummaryAvgAggregateInputType
    _sum?: SkillSummarySumAggregateInputType
    _min?: SkillSummaryMinAggregateInputType
    _max?: SkillSummaryMaxAggregateInputType
  }


  export type SkillSummaryGroupByOutputType = {
    skillSummaryId: number
    specId: number
    autoCalibrationId: number
    _count: SkillSummaryCountAggregateOutputType | null
    _avg: SkillSummaryAvgAggregateOutputType | null
    _sum: SkillSummarySumAggregateOutputType | null
    _min: SkillSummaryMinAggregateOutputType | null
    _max: SkillSummaryMaxAggregateOutputType | null
  }

  type GetSkillSummaryGroupByPayload<T extends SkillSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SkillSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], SkillSummaryGroupByOutputType[P]>
        }
      >
    >


  export type skillSummarySelect = {
    skillSummaryId?: boolean
    specId?: boolean
    autoCalibrationId?: boolean
    spec?: boolean | specArgs
    autoCalibration?: boolean | autoCalibrationArgs
  }


  export type skillSummaryInclude = {
    spec?: boolean | specArgs
    autoCalibration?: boolean | autoCalibrationArgs
  }

  export type skillSummaryGetPayload<S extends boolean | null | undefined | skillSummaryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? skillSummary :
    S extends undefined ? never :
    S extends { include: any } & (skillSummaryArgs | skillSummaryFindManyArgs)
    ? skillSummary  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'spec' ? specGetPayload<S['include'][P]> :
        P extends 'autoCalibration' ? autoCalibrationGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (skillSummaryArgs | skillSummaryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'spec' ? specGetPayload<S['select'][P]> :
        P extends 'autoCalibration' ? autoCalibrationGetPayload<S['select'][P]> :  P extends keyof skillSummary ? skillSummary[P] : never
  } 
      : skillSummary


  type skillSummaryCountArgs = 
    Omit<skillSummaryFindManyArgs, 'select' | 'include'> & {
      select?: SkillSummaryCountAggregateInputType | true
    }

  export interface skillSummaryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SkillSummary that matches the filter.
     * @param {skillSummaryFindUniqueArgs} args - Arguments to find a SkillSummary
     * @example
     * // Get one SkillSummary
     * const skillSummary = await prisma.skillSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends skillSummaryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, skillSummaryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'skillSummary'> extends True ? Prisma__skillSummaryClient<skillSummaryGetPayload<T>> : Prisma__skillSummaryClient<skillSummaryGetPayload<T> | null, null>

    /**
     * Find one SkillSummary that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {skillSummaryFindUniqueOrThrowArgs} args - Arguments to find a SkillSummary
     * @example
     * // Get one SkillSummary
     * const skillSummary = await prisma.skillSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends skillSummaryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, skillSummaryFindUniqueOrThrowArgs>
    ): Prisma__skillSummaryClient<skillSummaryGetPayload<T>>

    /**
     * Find the first SkillSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillSummaryFindFirstArgs} args - Arguments to find a SkillSummary
     * @example
     * // Get one SkillSummary
     * const skillSummary = await prisma.skillSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends skillSummaryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, skillSummaryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'skillSummary'> extends True ? Prisma__skillSummaryClient<skillSummaryGetPayload<T>> : Prisma__skillSummaryClient<skillSummaryGetPayload<T> | null, null>

    /**
     * Find the first SkillSummary that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillSummaryFindFirstOrThrowArgs} args - Arguments to find a SkillSummary
     * @example
     * // Get one SkillSummary
     * const skillSummary = await prisma.skillSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends skillSummaryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, skillSummaryFindFirstOrThrowArgs>
    ): Prisma__skillSummaryClient<skillSummaryGetPayload<T>>

    /**
     * Find zero or more SkillSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillSummaryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillSummaries
     * const skillSummaries = await prisma.skillSummary.findMany()
     * 
     * // Get first 10 SkillSummaries
     * const skillSummaries = await prisma.skillSummary.findMany({ take: 10 })
     * 
     * // Only select the `skillSummaryId`
     * const skillSummaryWithSkillSummaryIdOnly = await prisma.skillSummary.findMany({ select: { skillSummaryId: true } })
     * 
    **/
    findMany<T extends skillSummaryFindManyArgs>(
      args?: SelectSubset<T, skillSummaryFindManyArgs>
    ): Prisma.PrismaPromise<Array<skillSummaryGetPayload<T>>>

    /**
     * Create a SkillSummary.
     * @param {skillSummaryCreateArgs} args - Arguments to create a SkillSummary.
     * @example
     * // Create one SkillSummary
     * const SkillSummary = await prisma.skillSummary.create({
     *   data: {
     *     // ... data to create a SkillSummary
     *   }
     * })
     * 
    **/
    create<T extends skillSummaryCreateArgs>(
      args: SelectSubset<T, skillSummaryCreateArgs>
    ): Prisma__skillSummaryClient<skillSummaryGetPayload<T>>

    /**
     * Create many SkillSummaries.
     *     @param {skillSummaryCreateManyArgs} args - Arguments to create many SkillSummaries.
     *     @example
     *     // Create many SkillSummaries
     *     const skillSummary = await prisma.skillSummary.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends skillSummaryCreateManyArgs>(
      args?: SelectSubset<T, skillSummaryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SkillSummary.
     * @param {skillSummaryDeleteArgs} args - Arguments to delete one SkillSummary.
     * @example
     * // Delete one SkillSummary
     * const SkillSummary = await prisma.skillSummary.delete({
     *   where: {
     *     // ... filter to delete one SkillSummary
     *   }
     * })
     * 
    **/
    delete<T extends skillSummaryDeleteArgs>(
      args: SelectSubset<T, skillSummaryDeleteArgs>
    ): Prisma__skillSummaryClient<skillSummaryGetPayload<T>>

    /**
     * Update one SkillSummary.
     * @param {skillSummaryUpdateArgs} args - Arguments to update one SkillSummary.
     * @example
     * // Update one SkillSummary
     * const skillSummary = await prisma.skillSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends skillSummaryUpdateArgs>(
      args: SelectSubset<T, skillSummaryUpdateArgs>
    ): Prisma__skillSummaryClient<skillSummaryGetPayload<T>>

    /**
     * Delete zero or more SkillSummaries.
     * @param {skillSummaryDeleteManyArgs} args - Arguments to filter SkillSummaries to delete.
     * @example
     * // Delete a few SkillSummaries
     * const { count } = await prisma.skillSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends skillSummaryDeleteManyArgs>(
      args?: SelectSubset<T, skillSummaryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillSummaries
     * const skillSummary = await prisma.skillSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends skillSummaryUpdateManyArgs>(
      args: SelectSubset<T, skillSummaryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkillSummary.
     * @param {skillSummaryUpsertArgs} args - Arguments to update or create a SkillSummary.
     * @example
     * // Update or create a SkillSummary
     * const skillSummary = await prisma.skillSummary.upsert({
     *   create: {
     *     // ... data to create a SkillSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillSummary we want to update
     *   }
     * })
    **/
    upsert<T extends skillSummaryUpsertArgs>(
      args: SelectSubset<T, skillSummaryUpsertArgs>
    ): Prisma__skillSummaryClient<skillSummaryGetPayload<T>>

    /**
     * Count the number of SkillSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillSummaryCountArgs} args - Arguments to filter SkillSummaries to count.
     * @example
     * // Count the number of SkillSummaries
     * const count = await prisma.skillSummary.count({
     *   where: {
     *     // ... the filter for the SkillSummaries we want to count
     *   }
     * })
    **/
    count<T extends skillSummaryCountArgs>(
      args?: Subset<T, skillSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillSummaryAggregateArgs>(args: Subset<T, SkillSummaryAggregateArgs>): Prisma.PrismaPromise<GetSkillSummaryAggregateType<T>>

    /**
     * Group by SkillSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillSummaryGroupByArgs['orderBy'] }
        : { orderBy?: SkillSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for skillSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__skillSummaryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    spec<T extends specArgs= {}>(args?: Subset<T, specArgs>): Prisma__specClient<specGetPayload<T> | Null>;

    autoCalibration<T extends autoCalibrationArgs= {}>(args?: Subset<T, autoCalibrationArgs>): Prisma__autoCalibrationClient<autoCalibrationGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * skillSummary base type for findUnique actions
   */
  export type skillSummaryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
    /**
     * Filter, which skillSummary to fetch.
     */
    where: skillSummaryWhereUniqueInput
  }

  /**
   * skillSummary findUnique
   */
  export interface skillSummaryFindUniqueArgs extends skillSummaryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skillSummary findUniqueOrThrow
   */
  export type skillSummaryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
    /**
     * Filter, which skillSummary to fetch.
     */
    where: skillSummaryWhereUniqueInput
  }


  /**
   * skillSummary base type for findFirst actions
   */
  export type skillSummaryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
    /**
     * Filter, which skillSummary to fetch.
     */
    where?: skillSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillSummaries to fetch.
     */
    orderBy?: Enumerable<skillSummaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skillSummaries.
     */
    cursor?: skillSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skillSummaries.
     */
    distinct?: Enumerable<SkillSummaryScalarFieldEnum>
  }

  /**
   * skillSummary findFirst
   */
  export interface skillSummaryFindFirstArgs extends skillSummaryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * skillSummary findFirstOrThrow
   */
  export type skillSummaryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
    /**
     * Filter, which skillSummary to fetch.
     */
    where?: skillSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillSummaries to fetch.
     */
    orderBy?: Enumerable<skillSummaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skillSummaries.
     */
    cursor?: skillSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skillSummaries.
     */
    distinct?: Enumerable<SkillSummaryScalarFieldEnum>
  }


  /**
   * skillSummary findMany
   */
  export type skillSummaryFindManyArgs = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
    /**
     * Filter, which skillSummaries to fetch.
     */
    where?: skillSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skillSummaries to fetch.
     */
    orderBy?: Enumerable<skillSummaryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skillSummaries.
     */
    cursor?: skillSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skillSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skillSummaries.
     */
    skip?: number
    distinct?: Enumerable<SkillSummaryScalarFieldEnum>
  }


  /**
   * skillSummary create
   */
  export type skillSummaryCreateArgs = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
    /**
     * The data needed to create a skillSummary.
     */
    data: XOR<skillSummaryCreateInput, skillSummaryUncheckedCreateInput>
  }


  /**
   * skillSummary createMany
   */
  export type skillSummaryCreateManyArgs = {
    /**
     * The data used to create many skillSummaries.
     */
    data: Enumerable<skillSummaryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * skillSummary update
   */
  export type skillSummaryUpdateArgs = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
    /**
     * The data needed to update a skillSummary.
     */
    data: XOR<skillSummaryUpdateInput, skillSummaryUncheckedUpdateInput>
    /**
     * Choose, which skillSummary to update.
     */
    where: skillSummaryWhereUniqueInput
  }


  /**
   * skillSummary updateMany
   */
  export type skillSummaryUpdateManyArgs = {
    /**
     * The data used to update skillSummaries.
     */
    data: XOR<skillSummaryUpdateManyMutationInput, skillSummaryUncheckedUpdateManyInput>
    /**
     * Filter which skillSummaries to update
     */
    where?: skillSummaryWhereInput
  }


  /**
   * skillSummary upsert
   */
  export type skillSummaryUpsertArgs = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
    /**
     * The filter to search for the skillSummary to update in case it exists.
     */
    where: skillSummaryWhereUniqueInput
    /**
     * In case the skillSummary found by the `where` argument doesn't exist, create a new skillSummary with this data.
     */
    create: XOR<skillSummaryCreateInput, skillSummaryUncheckedCreateInput>
    /**
     * In case the skillSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skillSummaryUpdateInput, skillSummaryUncheckedUpdateInput>
  }


  /**
   * skillSummary delete
   */
  export type skillSummaryDeleteArgs = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
    /**
     * Filter which skillSummary to delete.
     */
    where: skillSummaryWhereUniqueInput
  }


  /**
   * skillSummary deleteMany
   */
  export type skillSummaryDeleteManyArgs = {
    /**
     * Filter which skillSummaries to delete
     */
    where?: skillSummaryWhereInput
  }


  /**
   * skillSummary without action
   */
  export type skillSummaryArgs = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
  }



  /**
   * Model sellingPoint
   */


  export type AggregateSellingPoint = {
    _count: SellingPointCountAggregateOutputType | null
    _avg: SellingPointAvgAggregateOutputType | null
    _sum: SellingPointSumAggregateOutputType | null
    _min: SellingPointMinAggregateOutputType | null
    _max: SellingPointMaxAggregateOutputType | null
  }

  export type SellingPointAvgAggregateOutputType = {
    sellingPointId: number | null
    specId: number | null
  }

  export type SellingPointSumAggregateOutputType = {
    sellingPointId: number | null
    specId: number | null
  }

  export type SellingPointMinAggregateOutputType = {
    sellingPointId: number | null
    specId: number | null
    title: string | null
    content: string | null
  }

  export type SellingPointMaxAggregateOutputType = {
    sellingPointId: number | null
    specId: number | null
    title: string | null
    content: string | null
  }

  export type SellingPointCountAggregateOutputType = {
    sellingPointId: number
    specId: number
    title: number
    content: number
    _all: number
  }


  export type SellingPointAvgAggregateInputType = {
    sellingPointId?: true
    specId?: true
  }

  export type SellingPointSumAggregateInputType = {
    sellingPointId?: true
    specId?: true
  }

  export type SellingPointMinAggregateInputType = {
    sellingPointId?: true
    specId?: true
    title?: true
    content?: true
  }

  export type SellingPointMaxAggregateInputType = {
    sellingPointId?: true
    specId?: true
    title?: true
    content?: true
  }

  export type SellingPointCountAggregateInputType = {
    sellingPointId?: true
    specId?: true
    title?: true
    content?: true
    _all?: true
  }

  export type SellingPointAggregateArgs = {
    /**
     * Filter which sellingPoint to aggregate.
     */
    where?: sellingPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sellingPoints to fetch.
     */
    orderBy?: Enumerable<sellingPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sellingPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sellingPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sellingPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sellingPoints
    **/
    _count?: true | SellingPointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellingPointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellingPointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellingPointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellingPointMaxAggregateInputType
  }

  export type GetSellingPointAggregateType<T extends SellingPointAggregateArgs> = {
        [P in keyof T & keyof AggregateSellingPoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellingPoint[P]>
      : GetScalarType<T[P], AggregateSellingPoint[P]>
  }




  export type SellingPointGroupByArgs = {
    where?: sellingPointWhereInput
    orderBy?: Enumerable<sellingPointOrderByWithAggregationInput>
    by: SellingPointScalarFieldEnum[]
    having?: sellingPointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellingPointCountAggregateInputType | true
    _avg?: SellingPointAvgAggregateInputType
    _sum?: SellingPointSumAggregateInputType
    _min?: SellingPointMinAggregateInputType
    _max?: SellingPointMaxAggregateInputType
  }


  export type SellingPointGroupByOutputType = {
    sellingPointId: number
    specId: number
    title: string
    content: string
    _count: SellingPointCountAggregateOutputType | null
    _avg: SellingPointAvgAggregateOutputType | null
    _sum: SellingPointSumAggregateOutputType | null
    _min: SellingPointMinAggregateOutputType | null
    _max: SellingPointMaxAggregateOutputType | null
  }

  type GetSellingPointGroupByPayload<T extends SellingPointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SellingPointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellingPointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellingPointGroupByOutputType[P]>
            : GetScalarType<T[P], SellingPointGroupByOutputType[P]>
        }
      >
    >


  export type sellingPointSelect = {
    sellingPointId?: boolean
    specId?: boolean
    title?: boolean
    content?: boolean
    spec?: boolean | specArgs
  }


  export type sellingPointInclude = {
    spec?: boolean | specArgs
  }

  export type sellingPointGetPayload<S extends boolean | null | undefined | sellingPointArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? sellingPoint :
    S extends undefined ? never :
    S extends { include: any } & (sellingPointArgs | sellingPointFindManyArgs)
    ? sellingPoint  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'spec' ? specGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (sellingPointArgs | sellingPointFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'spec' ? specGetPayload<S['select'][P]> :  P extends keyof sellingPoint ? sellingPoint[P] : never
  } 
      : sellingPoint


  type sellingPointCountArgs = 
    Omit<sellingPointFindManyArgs, 'select' | 'include'> & {
      select?: SellingPointCountAggregateInputType | true
    }

  export interface sellingPointDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SellingPoint that matches the filter.
     * @param {sellingPointFindUniqueArgs} args - Arguments to find a SellingPoint
     * @example
     * // Get one SellingPoint
     * const sellingPoint = await prisma.sellingPoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sellingPointFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sellingPointFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sellingPoint'> extends True ? Prisma__sellingPointClient<sellingPointGetPayload<T>> : Prisma__sellingPointClient<sellingPointGetPayload<T> | null, null>

    /**
     * Find one SellingPoint that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sellingPointFindUniqueOrThrowArgs} args - Arguments to find a SellingPoint
     * @example
     * // Get one SellingPoint
     * const sellingPoint = await prisma.sellingPoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sellingPointFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, sellingPointFindUniqueOrThrowArgs>
    ): Prisma__sellingPointClient<sellingPointGetPayload<T>>

    /**
     * Find the first SellingPoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sellingPointFindFirstArgs} args - Arguments to find a SellingPoint
     * @example
     * // Get one SellingPoint
     * const sellingPoint = await prisma.sellingPoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sellingPointFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sellingPointFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sellingPoint'> extends True ? Prisma__sellingPointClient<sellingPointGetPayload<T>> : Prisma__sellingPointClient<sellingPointGetPayload<T> | null, null>

    /**
     * Find the first SellingPoint that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sellingPointFindFirstOrThrowArgs} args - Arguments to find a SellingPoint
     * @example
     * // Get one SellingPoint
     * const sellingPoint = await prisma.sellingPoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sellingPointFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sellingPointFindFirstOrThrowArgs>
    ): Prisma__sellingPointClient<sellingPointGetPayload<T>>

    /**
     * Find zero or more SellingPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sellingPointFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellingPoints
     * const sellingPoints = await prisma.sellingPoint.findMany()
     * 
     * // Get first 10 SellingPoints
     * const sellingPoints = await prisma.sellingPoint.findMany({ take: 10 })
     * 
     * // Only select the `sellingPointId`
     * const sellingPointWithSellingPointIdOnly = await prisma.sellingPoint.findMany({ select: { sellingPointId: true } })
     * 
    **/
    findMany<T extends sellingPointFindManyArgs>(
      args?: SelectSubset<T, sellingPointFindManyArgs>
    ): Prisma.PrismaPromise<Array<sellingPointGetPayload<T>>>

    /**
     * Create a SellingPoint.
     * @param {sellingPointCreateArgs} args - Arguments to create a SellingPoint.
     * @example
     * // Create one SellingPoint
     * const SellingPoint = await prisma.sellingPoint.create({
     *   data: {
     *     // ... data to create a SellingPoint
     *   }
     * })
     * 
    **/
    create<T extends sellingPointCreateArgs>(
      args: SelectSubset<T, sellingPointCreateArgs>
    ): Prisma__sellingPointClient<sellingPointGetPayload<T>>

    /**
     * Create many SellingPoints.
     *     @param {sellingPointCreateManyArgs} args - Arguments to create many SellingPoints.
     *     @example
     *     // Create many SellingPoints
     *     const sellingPoint = await prisma.sellingPoint.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sellingPointCreateManyArgs>(
      args?: SelectSubset<T, sellingPointCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SellingPoint.
     * @param {sellingPointDeleteArgs} args - Arguments to delete one SellingPoint.
     * @example
     * // Delete one SellingPoint
     * const SellingPoint = await prisma.sellingPoint.delete({
     *   where: {
     *     // ... filter to delete one SellingPoint
     *   }
     * })
     * 
    **/
    delete<T extends sellingPointDeleteArgs>(
      args: SelectSubset<T, sellingPointDeleteArgs>
    ): Prisma__sellingPointClient<sellingPointGetPayload<T>>

    /**
     * Update one SellingPoint.
     * @param {sellingPointUpdateArgs} args - Arguments to update one SellingPoint.
     * @example
     * // Update one SellingPoint
     * const sellingPoint = await prisma.sellingPoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sellingPointUpdateArgs>(
      args: SelectSubset<T, sellingPointUpdateArgs>
    ): Prisma__sellingPointClient<sellingPointGetPayload<T>>

    /**
     * Delete zero or more SellingPoints.
     * @param {sellingPointDeleteManyArgs} args - Arguments to filter SellingPoints to delete.
     * @example
     * // Delete a few SellingPoints
     * const { count } = await prisma.sellingPoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sellingPointDeleteManyArgs>(
      args?: SelectSubset<T, sellingPointDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellingPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sellingPointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellingPoints
     * const sellingPoint = await prisma.sellingPoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sellingPointUpdateManyArgs>(
      args: SelectSubset<T, sellingPointUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellingPoint.
     * @param {sellingPointUpsertArgs} args - Arguments to update or create a SellingPoint.
     * @example
     * // Update or create a SellingPoint
     * const sellingPoint = await prisma.sellingPoint.upsert({
     *   create: {
     *     // ... data to create a SellingPoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellingPoint we want to update
     *   }
     * })
    **/
    upsert<T extends sellingPointUpsertArgs>(
      args: SelectSubset<T, sellingPointUpsertArgs>
    ): Prisma__sellingPointClient<sellingPointGetPayload<T>>

    /**
     * Count the number of SellingPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sellingPointCountArgs} args - Arguments to filter SellingPoints to count.
     * @example
     * // Count the number of SellingPoints
     * const count = await prisma.sellingPoint.count({
     *   where: {
     *     // ... the filter for the SellingPoints we want to count
     *   }
     * })
    **/
    count<T extends sellingPointCountArgs>(
      args?: Subset<T, sellingPointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellingPointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellingPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellingPointAggregateArgs>(args: Subset<T, SellingPointAggregateArgs>): Prisma.PrismaPromise<GetSellingPointAggregateType<T>>

    /**
     * Group by SellingPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellingPointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellingPointGroupByArgs['orderBy'] }
        : { orderBy?: SellingPointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellingPointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellingPointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sellingPoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sellingPointClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    spec<T extends specArgs= {}>(args?: Subset<T, specArgs>): Prisma__specClient<specGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sellingPoint base type for findUnique actions
   */
  export type sellingPointFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the sellingPoint
     */
    select?: sellingPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sellingPointInclude | null
    /**
     * Filter, which sellingPoint to fetch.
     */
    where: sellingPointWhereUniqueInput
  }

  /**
   * sellingPoint findUnique
   */
  export interface sellingPointFindUniqueArgs extends sellingPointFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sellingPoint findUniqueOrThrow
   */
  export type sellingPointFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sellingPoint
     */
    select?: sellingPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sellingPointInclude | null
    /**
     * Filter, which sellingPoint to fetch.
     */
    where: sellingPointWhereUniqueInput
  }


  /**
   * sellingPoint base type for findFirst actions
   */
  export type sellingPointFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the sellingPoint
     */
    select?: sellingPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sellingPointInclude | null
    /**
     * Filter, which sellingPoint to fetch.
     */
    where?: sellingPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sellingPoints to fetch.
     */
    orderBy?: Enumerable<sellingPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sellingPoints.
     */
    cursor?: sellingPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sellingPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sellingPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sellingPoints.
     */
    distinct?: Enumerable<SellingPointScalarFieldEnum>
  }

  /**
   * sellingPoint findFirst
   */
  export interface sellingPointFindFirstArgs extends sellingPointFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sellingPoint findFirstOrThrow
   */
  export type sellingPointFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sellingPoint
     */
    select?: sellingPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sellingPointInclude | null
    /**
     * Filter, which sellingPoint to fetch.
     */
    where?: sellingPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sellingPoints to fetch.
     */
    orderBy?: Enumerable<sellingPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sellingPoints.
     */
    cursor?: sellingPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sellingPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sellingPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sellingPoints.
     */
    distinct?: Enumerable<SellingPointScalarFieldEnum>
  }


  /**
   * sellingPoint findMany
   */
  export type sellingPointFindManyArgs = {
    /**
     * Select specific fields to fetch from the sellingPoint
     */
    select?: sellingPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sellingPointInclude | null
    /**
     * Filter, which sellingPoints to fetch.
     */
    where?: sellingPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sellingPoints to fetch.
     */
    orderBy?: Enumerable<sellingPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sellingPoints.
     */
    cursor?: sellingPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sellingPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sellingPoints.
     */
    skip?: number
    distinct?: Enumerable<SellingPointScalarFieldEnum>
  }


  /**
   * sellingPoint create
   */
  export type sellingPointCreateArgs = {
    /**
     * Select specific fields to fetch from the sellingPoint
     */
    select?: sellingPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sellingPointInclude | null
    /**
     * The data needed to create a sellingPoint.
     */
    data: XOR<sellingPointCreateInput, sellingPointUncheckedCreateInput>
  }


  /**
   * sellingPoint createMany
   */
  export type sellingPointCreateManyArgs = {
    /**
     * The data used to create many sellingPoints.
     */
    data: Enumerable<sellingPointCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sellingPoint update
   */
  export type sellingPointUpdateArgs = {
    /**
     * Select specific fields to fetch from the sellingPoint
     */
    select?: sellingPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sellingPointInclude | null
    /**
     * The data needed to update a sellingPoint.
     */
    data: XOR<sellingPointUpdateInput, sellingPointUncheckedUpdateInput>
    /**
     * Choose, which sellingPoint to update.
     */
    where: sellingPointWhereUniqueInput
  }


  /**
   * sellingPoint updateMany
   */
  export type sellingPointUpdateManyArgs = {
    /**
     * The data used to update sellingPoints.
     */
    data: XOR<sellingPointUpdateManyMutationInput, sellingPointUncheckedUpdateManyInput>
    /**
     * Filter which sellingPoints to update
     */
    where?: sellingPointWhereInput
  }


  /**
   * sellingPoint upsert
   */
  export type sellingPointUpsertArgs = {
    /**
     * Select specific fields to fetch from the sellingPoint
     */
    select?: sellingPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sellingPointInclude | null
    /**
     * The filter to search for the sellingPoint to update in case it exists.
     */
    where: sellingPointWhereUniqueInput
    /**
     * In case the sellingPoint found by the `where` argument doesn't exist, create a new sellingPoint with this data.
     */
    create: XOR<sellingPointCreateInput, sellingPointUncheckedCreateInput>
    /**
     * In case the sellingPoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sellingPointUpdateInput, sellingPointUncheckedUpdateInput>
  }


  /**
   * sellingPoint delete
   */
  export type sellingPointDeleteArgs = {
    /**
     * Select specific fields to fetch from the sellingPoint
     */
    select?: sellingPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sellingPointInclude | null
    /**
     * Filter which sellingPoint to delete.
     */
    where: sellingPointWhereUniqueInput
  }


  /**
   * sellingPoint deleteMany
   */
  export type sellingPointDeleteManyArgs = {
    /**
     * Filter which sellingPoints to delete
     */
    where?: sellingPointWhereInput
  }


  /**
   * sellingPoint without action
   */
  export type sellingPointArgs = {
    /**
     * Select specific fields to fetch from the sellingPoint
     */
    select?: sellingPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sellingPointInclude | null
  }



  /**
   * Model qualification
   */


  export type AggregateQualification = {
    _count: QualificationCountAggregateOutputType | null
    _avg: QualificationAvgAggregateOutputType | null
    _sum: QualificationSumAggregateOutputType | null
    _min: QualificationMinAggregateOutputType | null
    _max: QualificationMaxAggregateOutputType | null
  }

  export type QualificationAvgAggregateOutputType = {
    qualificationId: number | null
    specId: number | null
  }

  export type QualificationSumAggregateOutputType = {
    qualificationId: number | null
    specId: number | null
  }

  export type QualificationMinAggregateOutputType = {
    qualificationId: number | null
    specId: number | null
    credential: string | null
    acquisitionDate: string | null
  }

  export type QualificationMaxAggregateOutputType = {
    qualificationId: number | null
    specId: number | null
    credential: string | null
    acquisitionDate: string | null
  }

  export type QualificationCountAggregateOutputType = {
    qualificationId: number
    specId: number
    credential: number
    acquisitionDate: number
    _all: number
  }


  export type QualificationAvgAggregateInputType = {
    qualificationId?: true
    specId?: true
  }

  export type QualificationSumAggregateInputType = {
    qualificationId?: true
    specId?: true
  }

  export type QualificationMinAggregateInputType = {
    qualificationId?: true
    specId?: true
    credential?: true
    acquisitionDate?: true
  }

  export type QualificationMaxAggregateInputType = {
    qualificationId?: true
    specId?: true
    credential?: true
    acquisitionDate?: true
  }

  export type QualificationCountAggregateInputType = {
    qualificationId?: true
    specId?: true
    credential?: true
    acquisitionDate?: true
    _all?: true
  }

  export type QualificationAggregateArgs = {
    /**
     * Filter which qualification to aggregate.
     */
    where?: qualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualifications to fetch.
     */
    orderBy?: Enumerable<qualificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qualifications
    **/
    _count?: true | QualificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QualificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QualificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QualificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QualificationMaxAggregateInputType
  }

  export type GetQualificationAggregateType<T extends QualificationAggregateArgs> = {
        [P in keyof T & keyof AggregateQualification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualification[P]>
      : GetScalarType<T[P], AggregateQualification[P]>
  }




  export type QualificationGroupByArgs = {
    where?: qualificationWhereInput
    orderBy?: Enumerable<qualificationOrderByWithAggregationInput>
    by: QualificationScalarFieldEnum[]
    having?: qualificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QualificationCountAggregateInputType | true
    _avg?: QualificationAvgAggregateInputType
    _sum?: QualificationSumAggregateInputType
    _min?: QualificationMinAggregateInputType
    _max?: QualificationMaxAggregateInputType
  }


  export type QualificationGroupByOutputType = {
    qualificationId: number
    specId: number
    credential: string
    acquisitionDate: string
    _count: QualificationCountAggregateOutputType | null
    _avg: QualificationAvgAggregateOutputType | null
    _sum: QualificationSumAggregateOutputType | null
    _min: QualificationMinAggregateOutputType | null
    _max: QualificationMaxAggregateOutputType | null
  }

  type GetQualificationGroupByPayload<T extends QualificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QualificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QualificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QualificationGroupByOutputType[P]>
            : GetScalarType<T[P], QualificationGroupByOutputType[P]>
        }
      >
    >


  export type qualificationSelect = {
    qualificationId?: boolean
    specId?: boolean
    credential?: boolean
    acquisitionDate?: boolean
    spec?: boolean | specArgs
  }


  export type qualificationInclude = {
    spec?: boolean | specArgs
  }

  export type qualificationGetPayload<S extends boolean | null | undefined | qualificationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? qualification :
    S extends undefined ? never :
    S extends { include: any } & (qualificationArgs | qualificationFindManyArgs)
    ? qualification  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'spec' ? specGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (qualificationArgs | qualificationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'spec' ? specGetPayload<S['select'][P]> :  P extends keyof qualification ? qualification[P] : never
  } 
      : qualification


  type qualificationCountArgs = 
    Omit<qualificationFindManyArgs, 'select' | 'include'> & {
      select?: QualificationCountAggregateInputType | true
    }

  export interface qualificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Qualification that matches the filter.
     * @param {qualificationFindUniqueArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends qualificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, qualificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'qualification'> extends True ? Prisma__qualificationClient<qualificationGetPayload<T>> : Prisma__qualificationClient<qualificationGetPayload<T> | null, null>

    /**
     * Find one Qualification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {qualificationFindUniqueOrThrowArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends qualificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, qualificationFindUniqueOrThrowArgs>
    ): Prisma__qualificationClient<qualificationGetPayload<T>>

    /**
     * Find the first Qualification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationFindFirstArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends qualificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, qualificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'qualification'> extends True ? Prisma__qualificationClient<qualificationGetPayload<T>> : Prisma__qualificationClient<qualificationGetPayload<T> | null, null>

    /**
     * Find the first Qualification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationFindFirstOrThrowArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends qualificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, qualificationFindFirstOrThrowArgs>
    ): Prisma__qualificationClient<qualificationGetPayload<T>>

    /**
     * Find zero or more Qualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qualifications
     * const qualifications = await prisma.qualification.findMany()
     * 
     * // Get first 10 Qualifications
     * const qualifications = await prisma.qualification.findMany({ take: 10 })
     * 
     * // Only select the `qualificationId`
     * const qualificationWithQualificationIdOnly = await prisma.qualification.findMany({ select: { qualificationId: true } })
     * 
    **/
    findMany<T extends qualificationFindManyArgs>(
      args?: SelectSubset<T, qualificationFindManyArgs>
    ): Prisma.PrismaPromise<Array<qualificationGetPayload<T>>>

    /**
     * Create a Qualification.
     * @param {qualificationCreateArgs} args - Arguments to create a Qualification.
     * @example
     * // Create one Qualification
     * const Qualification = await prisma.qualification.create({
     *   data: {
     *     // ... data to create a Qualification
     *   }
     * })
     * 
    **/
    create<T extends qualificationCreateArgs>(
      args: SelectSubset<T, qualificationCreateArgs>
    ): Prisma__qualificationClient<qualificationGetPayload<T>>

    /**
     * Create many Qualifications.
     *     @param {qualificationCreateManyArgs} args - Arguments to create many Qualifications.
     *     @example
     *     // Create many Qualifications
     *     const qualification = await prisma.qualification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends qualificationCreateManyArgs>(
      args?: SelectSubset<T, qualificationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qualification.
     * @param {qualificationDeleteArgs} args - Arguments to delete one Qualification.
     * @example
     * // Delete one Qualification
     * const Qualification = await prisma.qualification.delete({
     *   where: {
     *     // ... filter to delete one Qualification
     *   }
     * })
     * 
    **/
    delete<T extends qualificationDeleteArgs>(
      args: SelectSubset<T, qualificationDeleteArgs>
    ): Prisma__qualificationClient<qualificationGetPayload<T>>

    /**
     * Update one Qualification.
     * @param {qualificationUpdateArgs} args - Arguments to update one Qualification.
     * @example
     * // Update one Qualification
     * const qualification = await prisma.qualification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends qualificationUpdateArgs>(
      args: SelectSubset<T, qualificationUpdateArgs>
    ): Prisma__qualificationClient<qualificationGetPayload<T>>

    /**
     * Delete zero or more Qualifications.
     * @param {qualificationDeleteManyArgs} args - Arguments to filter Qualifications to delete.
     * @example
     * // Delete a few Qualifications
     * const { count } = await prisma.qualification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends qualificationDeleteManyArgs>(
      args?: SelectSubset<T, qualificationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qualifications
     * const qualification = await prisma.qualification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends qualificationUpdateManyArgs>(
      args: SelectSubset<T, qualificationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qualification.
     * @param {qualificationUpsertArgs} args - Arguments to update or create a Qualification.
     * @example
     * // Update or create a Qualification
     * const qualification = await prisma.qualification.upsert({
     *   create: {
     *     // ... data to create a Qualification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qualification we want to update
     *   }
     * })
    **/
    upsert<T extends qualificationUpsertArgs>(
      args: SelectSubset<T, qualificationUpsertArgs>
    ): Prisma__qualificationClient<qualificationGetPayload<T>>

    /**
     * Count the number of Qualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualificationCountArgs} args - Arguments to filter Qualifications to count.
     * @example
     * // Count the number of Qualifications
     * const count = await prisma.qualification.count({
     *   where: {
     *     // ... the filter for the Qualifications we want to count
     *   }
     * })
    **/
    count<T extends qualificationCountArgs>(
      args?: Subset<T, qualificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QualificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QualificationAggregateArgs>(args: Subset<T, QualificationAggregateArgs>): Prisma.PrismaPromise<GetQualificationAggregateType<T>>

    /**
     * Group by Qualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QualificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QualificationGroupByArgs['orderBy'] }
        : { orderBy?: QualificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QualificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for qualification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__qualificationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    spec<T extends specArgs= {}>(args?: Subset<T, specArgs>): Prisma__specClient<specGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * qualification base type for findUnique actions
   */
  export type qualificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qualificationInclude | null
    /**
     * Filter, which qualification to fetch.
     */
    where: qualificationWhereUniqueInput
  }

  /**
   * qualification findUnique
   */
  export interface qualificationFindUniqueArgs extends qualificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * qualification findUniqueOrThrow
   */
  export type qualificationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qualificationInclude | null
    /**
     * Filter, which qualification to fetch.
     */
    where: qualificationWhereUniqueInput
  }


  /**
   * qualification base type for findFirst actions
   */
  export type qualificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qualificationInclude | null
    /**
     * Filter, which qualification to fetch.
     */
    where?: qualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualifications to fetch.
     */
    orderBy?: Enumerable<qualificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qualifications.
     */
    cursor?: qualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qualifications.
     */
    distinct?: Enumerable<QualificationScalarFieldEnum>
  }

  /**
   * qualification findFirst
   */
  export interface qualificationFindFirstArgs extends qualificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * qualification findFirstOrThrow
   */
  export type qualificationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qualificationInclude | null
    /**
     * Filter, which qualification to fetch.
     */
    where?: qualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualifications to fetch.
     */
    orderBy?: Enumerable<qualificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qualifications.
     */
    cursor?: qualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qualifications.
     */
    distinct?: Enumerable<QualificationScalarFieldEnum>
  }


  /**
   * qualification findMany
   */
  export type qualificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qualificationInclude | null
    /**
     * Filter, which qualifications to fetch.
     */
    where?: qualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualifications to fetch.
     */
    orderBy?: Enumerable<qualificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qualifications.
     */
    cursor?: qualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualifications.
     */
    skip?: number
    distinct?: Enumerable<QualificationScalarFieldEnum>
  }


  /**
   * qualification create
   */
  export type qualificationCreateArgs = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qualificationInclude | null
    /**
     * The data needed to create a qualification.
     */
    data: XOR<qualificationCreateInput, qualificationUncheckedCreateInput>
  }


  /**
   * qualification createMany
   */
  export type qualificationCreateManyArgs = {
    /**
     * The data used to create many qualifications.
     */
    data: Enumerable<qualificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * qualification update
   */
  export type qualificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qualificationInclude | null
    /**
     * The data needed to update a qualification.
     */
    data: XOR<qualificationUpdateInput, qualificationUncheckedUpdateInput>
    /**
     * Choose, which qualification to update.
     */
    where: qualificationWhereUniqueInput
  }


  /**
   * qualification updateMany
   */
  export type qualificationUpdateManyArgs = {
    /**
     * The data used to update qualifications.
     */
    data: XOR<qualificationUpdateManyMutationInput, qualificationUncheckedUpdateManyInput>
    /**
     * Filter which qualifications to update
     */
    where?: qualificationWhereInput
  }


  /**
   * qualification upsert
   */
  export type qualificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qualificationInclude | null
    /**
     * The filter to search for the qualification to update in case it exists.
     */
    where: qualificationWhereUniqueInput
    /**
     * In case the qualification found by the `where` argument doesn't exist, create a new qualification with this data.
     */
    create: XOR<qualificationCreateInput, qualificationUncheckedCreateInput>
    /**
     * In case the qualification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qualificationUpdateInput, qualificationUncheckedUpdateInput>
  }


  /**
   * qualification delete
   */
  export type qualificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qualificationInclude | null
    /**
     * Filter which qualification to delete.
     */
    where: qualificationWhereUniqueInput
  }


  /**
   * qualification deleteMany
   */
  export type qualificationDeleteManyArgs = {
    /**
     * Filter which qualifications to delete
     */
    where?: qualificationWhereInput
  }


  /**
   * qualification without action
   */
  export type qualificationArgs = {
    /**
     * Select specific fields to fetch from the qualification
     */
    select?: qualificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qualificationInclude | null
  }



  /**
   * Model previousWork
   */


  export type AggregatePreviousWork = {
    _count: PreviousWorkCountAggregateOutputType | null
    _avg: PreviousWorkAvgAggregateOutputType | null
    _sum: PreviousWorkSumAggregateOutputType | null
    _min: PreviousWorkMinAggregateOutputType | null
    _max: PreviousWorkMaxAggregateOutputType | null
  }

  export type PreviousWorkAvgAggregateOutputType = {
    previousWorkId: number | null
    specId: number | null
  }

  export type PreviousWorkSumAggregateOutputType = {
    previousWorkId: number | null
    specId: number | null
  }

  export type PreviousWorkMinAggregateOutputType = {
    previousWorkId: number | null
    specId: number | null
    industry: string | null
    occupation: string | null
    JobDuties: string | null
  }

  export type PreviousWorkMaxAggregateOutputType = {
    previousWorkId: number | null
    specId: number | null
    industry: string | null
    occupation: string | null
    JobDuties: string | null
  }

  export type PreviousWorkCountAggregateOutputType = {
    previousWorkId: number
    specId: number
    industry: number
    occupation: number
    JobDuties: number
    _all: number
  }


  export type PreviousWorkAvgAggregateInputType = {
    previousWorkId?: true
    specId?: true
  }

  export type PreviousWorkSumAggregateInputType = {
    previousWorkId?: true
    specId?: true
  }

  export type PreviousWorkMinAggregateInputType = {
    previousWorkId?: true
    specId?: true
    industry?: true
    occupation?: true
    JobDuties?: true
  }

  export type PreviousWorkMaxAggregateInputType = {
    previousWorkId?: true
    specId?: true
    industry?: true
    occupation?: true
    JobDuties?: true
  }

  export type PreviousWorkCountAggregateInputType = {
    previousWorkId?: true
    specId?: true
    industry?: true
    occupation?: true
    JobDuties?: true
    _all?: true
  }

  export type PreviousWorkAggregateArgs = {
    /**
     * Filter which previousWork to aggregate.
     */
    where?: previousWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of previousWorks to fetch.
     */
    orderBy?: Enumerable<previousWorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: previousWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` previousWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` previousWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned previousWorks
    **/
    _count?: true | PreviousWorkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreviousWorkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreviousWorkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreviousWorkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreviousWorkMaxAggregateInputType
  }

  export type GetPreviousWorkAggregateType<T extends PreviousWorkAggregateArgs> = {
        [P in keyof T & keyof AggregatePreviousWork]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreviousWork[P]>
      : GetScalarType<T[P], AggregatePreviousWork[P]>
  }




  export type PreviousWorkGroupByArgs = {
    where?: previousWorkWhereInput
    orderBy?: Enumerable<previousWorkOrderByWithAggregationInput>
    by: PreviousWorkScalarFieldEnum[]
    having?: previousWorkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreviousWorkCountAggregateInputType | true
    _avg?: PreviousWorkAvgAggregateInputType
    _sum?: PreviousWorkSumAggregateInputType
    _min?: PreviousWorkMinAggregateInputType
    _max?: PreviousWorkMaxAggregateInputType
  }


  export type PreviousWorkGroupByOutputType = {
    previousWorkId: number
    specId: number
    industry: string
    occupation: string
    JobDuties: string
    _count: PreviousWorkCountAggregateOutputType | null
    _avg: PreviousWorkAvgAggregateOutputType | null
    _sum: PreviousWorkSumAggregateOutputType | null
    _min: PreviousWorkMinAggregateOutputType | null
    _max: PreviousWorkMaxAggregateOutputType | null
  }

  type GetPreviousWorkGroupByPayload<T extends PreviousWorkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PreviousWorkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreviousWorkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreviousWorkGroupByOutputType[P]>
            : GetScalarType<T[P], PreviousWorkGroupByOutputType[P]>
        }
      >
    >


  export type previousWorkSelect = {
    previousWorkId?: boolean
    specId?: boolean
    industry?: boolean
    occupation?: boolean
    JobDuties?: boolean
    spec?: boolean | specArgs
  }


  export type previousWorkInclude = {
    spec?: boolean | specArgs
  }

  export type previousWorkGetPayload<S extends boolean | null | undefined | previousWorkArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? previousWork :
    S extends undefined ? never :
    S extends { include: any } & (previousWorkArgs | previousWorkFindManyArgs)
    ? previousWork  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'spec' ? specGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (previousWorkArgs | previousWorkFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'spec' ? specGetPayload<S['select'][P]> :  P extends keyof previousWork ? previousWork[P] : never
  } 
      : previousWork


  type previousWorkCountArgs = 
    Omit<previousWorkFindManyArgs, 'select' | 'include'> & {
      select?: PreviousWorkCountAggregateInputType | true
    }

  export interface previousWorkDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PreviousWork that matches the filter.
     * @param {previousWorkFindUniqueArgs} args - Arguments to find a PreviousWork
     * @example
     * // Get one PreviousWork
     * const previousWork = await prisma.previousWork.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends previousWorkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, previousWorkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'previousWork'> extends True ? Prisma__previousWorkClient<previousWorkGetPayload<T>> : Prisma__previousWorkClient<previousWorkGetPayload<T> | null, null>

    /**
     * Find one PreviousWork that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {previousWorkFindUniqueOrThrowArgs} args - Arguments to find a PreviousWork
     * @example
     * // Get one PreviousWork
     * const previousWork = await prisma.previousWork.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends previousWorkFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, previousWorkFindUniqueOrThrowArgs>
    ): Prisma__previousWorkClient<previousWorkGetPayload<T>>

    /**
     * Find the first PreviousWork that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {previousWorkFindFirstArgs} args - Arguments to find a PreviousWork
     * @example
     * // Get one PreviousWork
     * const previousWork = await prisma.previousWork.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends previousWorkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, previousWorkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'previousWork'> extends True ? Prisma__previousWorkClient<previousWorkGetPayload<T>> : Prisma__previousWorkClient<previousWorkGetPayload<T> | null, null>

    /**
     * Find the first PreviousWork that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {previousWorkFindFirstOrThrowArgs} args - Arguments to find a PreviousWork
     * @example
     * // Get one PreviousWork
     * const previousWork = await prisma.previousWork.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends previousWorkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, previousWorkFindFirstOrThrowArgs>
    ): Prisma__previousWorkClient<previousWorkGetPayload<T>>

    /**
     * Find zero or more PreviousWorks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {previousWorkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreviousWorks
     * const previousWorks = await prisma.previousWork.findMany()
     * 
     * // Get first 10 PreviousWorks
     * const previousWorks = await prisma.previousWork.findMany({ take: 10 })
     * 
     * // Only select the `previousWorkId`
     * const previousWorkWithPreviousWorkIdOnly = await prisma.previousWork.findMany({ select: { previousWorkId: true } })
     * 
    **/
    findMany<T extends previousWorkFindManyArgs>(
      args?: SelectSubset<T, previousWorkFindManyArgs>
    ): Prisma.PrismaPromise<Array<previousWorkGetPayload<T>>>

    /**
     * Create a PreviousWork.
     * @param {previousWorkCreateArgs} args - Arguments to create a PreviousWork.
     * @example
     * // Create one PreviousWork
     * const PreviousWork = await prisma.previousWork.create({
     *   data: {
     *     // ... data to create a PreviousWork
     *   }
     * })
     * 
    **/
    create<T extends previousWorkCreateArgs>(
      args: SelectSubset<T, previousWorkCreateArgs>
    ): Prisma__previousWorkClient<previousWorkGetPayload<T>>

    /**
     * Create many PreviousWorks.
     *     @param {previousWorkCreateManyArgs} args - Arguments to create many PreviousWorks.
     *     @example
     *     // Create many PreviousWorks
     *     const previousWork = await prisma.previousWork.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends previousWorkCreateManyArgs>(
      args?: SelectSubset<T, previousWorkCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PreviousWork.
     * @param {previousWorkDeleteArgs} args - Arguments to delete one PreviousWork.
     * @example
     * // Delete one PreviousWork
     * const PreviousWork = await prisma.previousWork.delete({
     *   where: {
     *     // ... filter to delete one PreviousWork
     *   }
     * })
     * 
    **/
    delete<T extends previousWorkDeleteArgs>(
      args: SelectSubset<T, previousWorkDeleteArgs>
    ): Prisma__previousWorkClient<previousWorkGetPayload<T>>

    /**
     * Update one PreviousWork.
     * @param {previousWorkUpdateArgs} args - Arguments to update one PreviousWork.
     * @example
     * // Update one PreviousWork
     * const previousWork = await prisma.previousWork.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends previousWorkUpdateArgs>(
      args: SelectSubset<T, previousWorkUpdateArgs>
    ): Prisma__previousWorkClient<previousWorkGetPayload<T>>

    /**
     * Delete zero or more PreviousWorks.
     * @param {previousWorkDeleteManyArgs} args - Arguments to filter PreviousWorks to delete.
     * @example
     * // Delete a few PreviousWorks
     * const { count } = await prisma.previousWork.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends previousWorkDeleteManyArgs>(
      args?: SelectSubset<T, previousWorkDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreviousWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {previousWorkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreviousWorks
     * const previousWork = await prisma.previousWork.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends previousWorkUpdateManyArgs>(
      args: SelectSubset<T, previousWorkUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PreviousWork.
     * @param {previousWorkUpsertArgs} args - Arguments to update or create a PreviousWork.
     * @example
     * // Update or create a PreviousWork
     * const previousWork = await prisma.previousWork.upsert({
     *   create: {
     *     // ... data to create a PreviousWork
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreviousWork we want to update
     *   }
     * })
    **/
    upsert<T extends previousWorkUpsertArgs>(
      args: SelectSubset<T, previousWorkUpsertArgs>
    ): Prisma__previousWorkClient<previousWorkGetPayload<T>>

    /**
     * Count the number of PreviousWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {previousWorkCountArgs} args - Arguments to filter PreviousWorks to count.
     * @example
     * // Count the number of PreviousWorks
     * const count = await prisma.previousWork.count({
     *   where: {
     *     // ... the filter for the PreviousWorks we want to count
     *   }
     * })
    **/
    count<T extends previousWorkCountArgs>(
      args?: Subset<T, previousWorkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreviousWorkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreviousWork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousWorkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreviousWorkAggregateArgs>(args: Subset<T, PreviousWorkAggregateArgs>): Prisma.PrismaPromise<GetPreviousWorkAggregateType<T>>

    /**
     * Group by PreviousWork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreviousWorkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreviousWorkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreviousWorkGroupByArgs['orderBy'] }
        : { orderBy?: PreviousWorkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreviousWorkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreviousWorkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for previousWork.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__previousWorkClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    spec<T extends specArgs= {}>(args?: Subset<T, specArgs>): Prisma__specClient<specGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * previousWork base type for findUnique actions
   */
  export type previousWorkFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the previousWork
     */
    select?: previousWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: previousWorkInclude | null
    /**
     * Filter, which previousWork to fetch.
     */
    where: previousWorkWhereUniqueInput
  }

  /**
   * previousWork findUnique
   */
  export interface previousWorkFindUniqueArgs extends previousWorkFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * previousWork findUniqueOrThrow
   */
  export type previousWorkFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the previousWork
     */
    select?: previousWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: previousWorkInclude | null
    /**
     * Filter, which previousWork to fetch.
     */
    where: previousWorkWhereUniqueInput
  }


  /**
   * previousWork base type for findFirst actions
   */
  export type previousWorkFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the previousWork
     */
    select?: previousWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: previousWorkInclude | null
    /**
     * Filter, which previousWork to fetch.
     */
    where?: previousWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of previousWorks to fetch.
     */
    orderBy?: Enumerable<previousWorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for previousWorks.
     */
    cursor?: previousWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` previousWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` previousWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of previousWorks.
     */
    distinct?: Enumerable<PreviousWorkScalarFieldEnum>
  }

  /**
   * previousWork findFirst
   */
  export interface previousWorkFindFirstArgs extends previousWorkFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * previousWork findFirstOrThrow
   */
  export type previousWorkFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the previousWork
     */
    select?: previousWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: previousWorkInclude | null
    /**
     * Filter, which previousWork to fetch.
     */
    where?: previousWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of previousWorks to fetch.
     */
    orderBy?: Enumerable<previousWorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for previousWorks.
     */
    cursor?: previousWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` previousWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` previousWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of previousWorks.
     */
    distinct?: Enumerable<PreviousWorkScalarFieldEnum>
  }


  /**
   * previousWork findMany
   */
  export type previousWorkFindManyArgs = {
    /**
     * Select specific fields to fetch from the previousWork
     */
    select?: previousWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: previousWorkInclude | null
    /**
     * Filter, which previousWorks to fetch.
     */
    where?: previousWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of previousWorks to fetch.
     */
    orderBy?: Enumerable<previousWorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing previousWorks.
     */
    cursor?: previousWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` previousWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` previousWorks.
     */
    skip?: number
    distinct?: Enumerable<PreviousWorkScalarFieldEnum>
  }


  /**
   * previousWork create
   */
  export type previousWorkCreateArgs = {
    /**
     * Select specific fields to fetch from the previousWork
     */
    select?: previousWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: previousWorkInclude | null
    /**
     * The data needed to create a previousWork.
     */
    data: XOR<previousWorkCreateInput, previousWorkUncheckedCreateInput>
  }


  /**
   * previousWork createMany
   */
  export type previousWorkCreateManyArgs = {
    /**
     * The data used to create many previousWorks.
     */
    data: Enumerable<previousWorkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * previousWork update
   */
  export type previousWorkUpdateArgs = {
    /**
     * Select specific fields to fetch from the previousWork
     */
    select?: previousWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: previousWorkInclude | null
    /**
     * The data needed to update a previousWork.
     */
    data: XOR<previousWorkUpdateInput, previousWorkUncheckedUpdateInput>
    /**
     * Choose, which previousWork to update.
     */
    where: previousWorkWhereUniqueInput
  }


  /**
   * previousWork updateMany
   */
  export type previousWorkUpdateManyArgs = {
    /**
     * The data used to update previousWorks.
     */
    data: XOR<previousWorkUpdateManyMutationInput, previousWorkUncheckedUpdateManyInput>
    /**
     * Filter which previousWorks to update
     */
    where?: previousWorkWhereInput
  }


  /**
   * previousWork upsert
   */
  export type previousWorkUpsertArgs = {
    /**
     * Select specific fields to fetch from the previousWork
     */
    select?: previousWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: previousWorkInclude | null
    /**
     * The filter to search for the previousWork to update in case it exists.
     */
    where: previousWorkWhereUniqueInput
    /**
     * In case the previousWork found by the `where` argument doesn't exist, create a new previousWork with this data.
     */
    create: XOR<previousWorkCreateInput, previousWorkUncheckedCreateInput>
    /**
     * In case the previousWork was found with the provided `where` argument, update it with this data.
     */
    update: XOR<previousWorkUpdateInput, previousWorkUncheckedUpdateInput>
  }


  /**
   * previousWork delete
   */
  export type previousWorkDeleteArgs = {
    /**
     * Select specific fields to fetch from the previousWork
     */
    select?: previousWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: previousWorkInclude | null
    /**
     * Filter which previousWork to delete.
     */
    where: previousWorkWhereUniqueInput
  }


  /**
   * previousWork deleteMany
   */
  export type previousWorkDeleteManyArgs = {
    /**
     * Filter which previousWorks to delete
     */
    where?: previousWorkWhereInput
  }


  /**
   * previousWork without action
   */
  export type previousWorkArgs = {
    /**
     * Select specific fields to fetch from the previousWork
     */
    select?: previousWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: previousWorkInclude | null
  }



  /**
   * Model developmentExperience
   */


  export type AggregateDevelopmentExperience = {
    _count: DevelopmentExperienceCountAggregateOutputType | null
    _avg: DevelopmentExperienceAvgAggregateOutputType | null
    _sum: DevelopmentExperienceSumAggregateOutputType | null
    _min: DevelopmentExperienceMinAggregateOutputType | null
    _max: DevelopmentExperienceMaxAggregateOutputType | null
  }

  export type DevelopmentExperienceAvgAggregateOutputType = {
    developmentExperienceId: number | null
    specId: number | null
    autoCalibrationId: number | null
  }

  export type DevelopmentExperienceSumAggregateOutputType = {
    developmentExperienceId: number | null
    specId: number | null
    autoCalibrationId: number | null
  }

  export type DevelopmentExperienceMinAggregateOutputType = {
    developmentExperienceId: number | null
    specId: number | null
    startDate: string | null
    duration: string | null
    assignedTask: string | null
    teamSize: string | null
    totalProjectHeadcount: string | null
    projectName: string | null
    jobDuties: string | null
    img: string | null
    autoCalibrationId: number | null
  }

  export type DevelopmentExperienceMaxAggregateOutputType = {
    developmentExperienceId: number | null
    specId: number | null
    startDate: string | null
    duration: string | null
    assignedTask: string | null
    teamSize: string | null
    totalProjectHeadcount: string | null
    projectName: string | null
    jobDuties: string | null
    img: string | null
    autoCalibrationId: number | null
  }

  export type DevelopmentExperienceCountAggregateOutputType = {
    developmentExperienceId: number
    specId: number
    startDate: number
    duration: number
    assignedTask: number
    teamSize: number
    totalProjectHeadcount: number
    projectName: number
    jobDuties: number
    img: number
    autoCalibrationId: number
    _all: number
  }


  export type DevelopmentExperienceAvgAggregateInputType = {
    developmentExperienceId?: true
    specId?: true
    autoCalibrationId?: true
  }

  export type DevelopmentExperienceSumAggregateInputType = {
    developmentExperienceId?: true
    specId?: true
    autoCalibrationId?: true
  }

  export type DevelopmentExperienceMinAggregateInputType = {
    developmentExperienceId?: true
    specId?: true
    startDate?: true
    duration?: true
    assignedTask?: true
    teamSize?: true
    totalProjectHeadcount?: true
    projectName?: true
    jobDuties?: true
    img?: true
    autoCalibrationId?: true
  }

  export type DevelopmentExperienceMaxAggregateInputType = {
    developmentExperienceId?: true
    specId?: true
    startDate?: true
    duration?: true
    assignedTask?: true
    teamSize?: true
    totalProjectHeadcount?: true
    projectName?: true
    jobDuties?: true
    img?: true
    autoCalibrationId?: true
  }

  export type DevelopmentExperienceCountAggregateInputType = {
    developmentExperienceId?: true
    specId?: true
    startDate?: true
    duration?: true
    assignedTask?: true
    teamSize?: true
    totalProjectHeadcount?: true
    projectName?: true
    jobDuties?: true
    img?: true
    autoCalibrationId?: true
    _all?: true
  }

  export type DevelopmentExperienceAggregateArgs = {
    /**
     * Filter which developmentExperience to aggregate.
     */
    where?: developmentExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of developmentExperiences to fetch.
     */
    orderBy?: Enumerable<developmentExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: developmentExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` developmentExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` developmentExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned developmentExperiences
    **/
    _count?: true | DevelopmentExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DevelopmentExperienceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DevelopmentExperienceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DevelopmentExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DevelopmentExperienceMaxAggregateInputType
  }

  export type GetDevelopmentExperienceAggregateType<T extends DevelopmentExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevelopmentExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevelopmentExperience[P]>
      : GetScalarType<T[P], AggregateDevelopmentExperience[P]>
  }




  export type DevelopmentExperienceGroupByArgs = {
    where?: developmentExperienceWhereInput
    orderBy?: Enumerable<developmentExperienceOrderByWithAggregationInput>
    by: DevelopmentExperienceScalarFieldEnum[]
    having?: developmentExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DevelopmentExperienceCountAggregateInputType | true
    _avg?: DevelopmentExperienceAvgAggregateInputType
    _sum?: DevelopmentExperienceSumAggregateInputType
    _min?: DevelopmentExperienceMinAggregateInputType
    _max?: DevelopmentExperienceMaxAggregateInputType
  }


  export type DevelopmentExperienceGroupByOutputType = {
    developmentExperienceId: number
    specId: number
    startDate: string
    duration: string
    assignedTask: string
    teamSize: string
    totalProjectHeadcount: string
    projectName: string
    jobDuties: string
    img: string
    autoCalibrationId: number
    _count: DevelopmentExperienceCountAggregateOutputType | null
    _avg: DevelopmentExperienceAvgAggregateOutputType | null
    _sum: DevelopmentExperienceSumAggregateOutputType | null
    _min: DevelopmentExperienceMinAggregateOutputType | null
    _max: DevelopmentExperienceMaxAggregateOutputType | null
  }

  type GetDevelopmentExperienceGroupByPayload<T extends DevelopmentExperienceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DevelopmentExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DevelopmentExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DevelopmentExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], DevelopmentExperienceGroupByOutputType[P]>
        }
      >
    >


  export type developmentExperienceSelect = {
    developmentExperienceId?: boolean
    specId?: boolean
    startDate?: boolean
    duration?: boolean
    assignedTask?: boolean
    teamSize?: boolean
    totalProjectHeadcount?: boolean
    projectName?: boolean
    jobDuties?: boolean
    img?: boolean
    autoCalibrationId?: boolean
    spec?: boolean | specArgs
    autoCalibration?: boolean | autoCalibrationArgs
  }


  export type developmentExperienceInclude = {
    spec?: boolean | specArgs
    autoCalibration?: boolean | autoCalibrationArgs
  }

  export type developmentExperienceGetPayload<S extends boolean | null | undefined | developmentExperienceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? developmentExperience :
    S extends undefined ? never :
    S extends { include: any } & (developmentExperienceArgs | developmentExperienceFindManyArgs)
    ? developmentExperience  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'spec' ? specGetPayload<S['include'][P]> :
        P extends 'autoCalibration' ? autoCalibrationGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (developmentExperienceArgs | developmentExperienceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'spec' ? specGetPayload<S['select'][P]> :
        P extends 'autoCalibration' ? autoCalibrationGetPayload<S['select'][P]> :  P extends keyof developmentExperience ? developmentExperience[P] : never
  } 
      : developmentExperience


  type developmentExperienceCountArgs = 
    Omit<developmentExperienceFindManyArgs, 'select' | 'include'> & {
      select?: DevelopmentExperienceCountAggregateInputType | true
    }

  export interface developmentExperienceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DevelopmentExperience that matches the filter.
     * @param {developmentExperienceFindUniqueArgs} args - Arguments to find a DevelopmentExperience
     * @example
     * // Get one DevelopmentExperience
     * const developmentExperience = await prisma.developmentExperience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends developmentExperienceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, developmentExperienceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'developmentExperience'> extends True ? Prisma__developmentExperienceClient<developmentExperienceGetPayload<T>> : Prisma__developmentExperienceClient<developmentExperienceGetPayload<T> | null, null>

    /**
     * Find one DevelopmentExperience that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {developmentExperienceFindUniqueOrThrowArgs} args - Arguments to find a DevelopmentExperience
     * @example
     * // Get one DevelopmentExperience
     * const developmentExperience = await prisma.developmentExperience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends developmentExperienceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, developmentExperienceFindUniqueOrThrowArgs>
    ): Prisma__developmentExperienceClient<developmentExperienceGetPayload<T>>

    /**
     * Find the first DevelopmentExperience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {developmentExperienceFindFirstArgs} args - Arguments to find a DevelopmentExperience
     * @example
     * // Get one DevelopmentExperience
     * const developmentExperience = await prisma.developmentExperience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends developmentExperienceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, developmentExperienceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'developmentExperience'> extends True ? Prisma__developmentExperienceClient<developmentExperienceGetPayload<T>> : Prisma__developmentExperienceClient<developmentExperienceGetPayload<T> | null, null>

    /**
     * Find the first DevelopmentExperience that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {developmentExperienceFindFirstOrThrowArgs} args - Arguments to find a DevelopmentExperience
     * @example
     * // Get one DevelopmentExperience
     * const developmentExperience = await prisma.developmentExperience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends developmentExperienceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, developmentExperienceFindFirstOrThrowArgs>
    ): Prisma__developmentExperienceClient<developmentExperienceGetPayload<T>>

    /**
     * Find zero or more DevelopmentExperiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {developmentExperienceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DevelopmentExperiences
     * const developmentExperiences = await prisma.developmentExperience.findMany()
     * 
     * // Get first 10 DevelopmentExperiences
     * const developmentExperiences = await prisma.developmentExperience.findMany({ take: 10 })
     * 
     * // Only select the `developmentExperienceId`
     * const developmentExperienceWithDevelopmentExperienceIdOnly = await prisma.developmentExperience.findMany({ select: { developmentExperienceId: true } })
     * 
    **/
    findMany<T extends developmentExperienceFindManyArgs>(
      args?: SelectSubset<T, developmentExperienceFindManyArgs>
    ): Prisma.PrismaPromise<Array<developmentExperienceGetPayload<T>>>

    /**
     * Create a DevelopmentExperience.
     * @param {developmentExperienceCreateArgs} args - Arguments to create a DevelopmentExperience.
     * @example
     * // Create one DevelopmentExperience
     * const DevelopmentExperience = await prisma.developmentExperience.create({
     *   data: {
     *     // ... data to create a DevelopmentExperience
     *   }
     * })
     * 
    **/
    create<T extends developmentExperienceCreateArgs>(
      args: SelectSubset<T, developmentExperienceCreateArgs>
    ): Prisma__developmentExperienceClient<developmentExperienceGetPayload<T>>

    /**
     * Create many DevelopmentExperiences.
     *     @param {developmentExperienceCreateManyArgs} args - Arguments to create many DevelopmentExperiences.
     *     @example
     *     // Create many DevelopmentExperiences
     *     const developmentExperience = await prisma.developmentExperience.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends developmentExperienceCreateManyArgs>(
      args?: SelectSubset<T, developmentExperienceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DevelopmentExperience.
     * @param {developmentExperienceDeleteArgs} args - Arguments to delete one DevelopmentExperience.
     * @example
     * // Delete one DevelopmentExperience
     * const DevelopmentExperience = await prisma.developmentExperience.delete({
     *   where: {
     *     // ... filter to delete one DevelopmentExperience
     *   }
     * })
     * 
    **/
    delete<T extends developmentExperienceDeleteArgs>(
      args: SelectSubset<T, developmentExperienceDeleteArgs>
    ): Prisma__developmentExperienceClient<developmentExperienceGetPayload<T>>

    /**
     * Update one DevelopmentExperience.
     * @param {developmentExperienceUpdateArgs} args - Arguments to update one DevelopmentExperience.
     * @example
     * // Update one DevelopmentExperience
     * const developmentExperience = await prisma.developmentExperience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends developmentExperienceUpdateArgs>(
      args: SelectSubset<T, developmentExperienceUpdateArgs>
    ): Prisma__developmentExperienceClient<developmentExperienceGetPayload<T>>

    /**
     * Delete zero or more DevelopmentExperiences.
     * @param {developmentExperienceDeleteManyArgs} args - Arguments to filter DevelopmentExperiences to delete.
     * @example
     * // Delete a few DevelopmentExperiences
     * const { count } = await prisma.developmentExperience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends developmentExperienceDeleteManyArgs>(
      args?: SelectSubset<T, developmentExperienceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DevelopmentExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {developmentExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DevelopmentExperiences
     * const developmentExperience = await prisma.developmentExperience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends developmentExperienceUpdateManyArgs>(
      args: SelectSubset<T, developmentExperienceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DevelopmentExperience.
     * @param {developmentExperienceUpsertArgs} args - Arguments to update or create a DevelopmentExperience.
     * @example
     * // Update or create a DevelopmentExperience
     * const developmentExperience = await prisma.developmentExperience.upsert({
     *   create: {
     *     // ... data to create a DevelopmentExperience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DevelopmentExperience we want to update
     *   }
     * })
    **/
    upsert<T extends developmentExperienceUpsertArgs>(
      args: SelectSubset<T, developmentExperienceUpsertArgs>
    ): Prisma__developmentExperienceClient<developmentExperienceGetPayload<T>>

    /**
     * Count the number of DevelopmentExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {developmentExperienceCountArgs} args - Arguments to filter DevelopmentExperiences to count.
     * @example
     * // Count the number of DevelopmentExperiences
     * const count = await prisma.developmentExperience.count({
     *   where: {
     *     // ... the filter for the DevelopmentExperiences we want to count
     *   }
     * })
    **/
    count<T extends developmentExperienceCountArgs>(
      args?: Subset<T, developmentExperienceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DevelopmentExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DevelopmentExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DevelopmentExperienceAggregateArgs>(args: Subset<T, DevelopmentExperienceAggregateArgs>): Prisma.PrismaPromise<GetDevelopmentExperienceAggregateType<T>>

    /**
     * Group by DevelopmentExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DevelopmentExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DevelopmentExperienceGroupByArgs['orderBy'] }
        : { orderBy?: DevelopmentExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DevelopmentExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDevelopmentExperienceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for developmentExperience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__developmentExperienceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    spec<T extends specArgs= {}>(args?: Subset<T, specArgs>): Prisma__specClient<specGetPayload<T> | Null>;

    autoCalibration<T extends autoCalibrationArgs= {}>(args?: Subset<T, autoCalibrationArgs>): Prisma__autoCalibrationClient<autoCalibrationGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * developmentExperience base type for findUnique actions
   */
  export type developmentExperienceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
    /**
     * Filter, which developmentExperience to fetch.
     */
    where: developmentExperienceWhereUniqueInput
  }

  /**
   * developmentExperience findUnique
   */
  export interface developmentExperienceFindUniqueArgs extends developmentExperienceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * developmentExperience findUniqueOrThrow
   */
  export type developmentExperienceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
    /**
     * Filter, which developmentExperience to fetch.
     */
    where: developmentExperienceWhereUniqueInput
  }


  /**
   * developmentExperience base type for findFirst actions
   */
  export type developmentExperienceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
    /**
     * Filter, which developmentExperience to fetch.
     */
    where?: developmentExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of developmentExperiences to fetch.
     */
    orderBy?: Enumerable<developmentExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for developmentExperiences.
     */
    cursor?: developmentExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` developmentExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` developmentExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of developmentExperiences.
     */
    distinct?: Enumerable<DevelopmentExperienceScalarFieldEnum>
  }

  /**
   * developmentExperience findFirst
   */
  export interface developmentExperienceFindFirstArgs extends developmentExperienceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * developmentExperience findFirstOrThrow
   */
  export type developmentExperienceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
    /**
     * Filter, which developmentExperience to fetch.
     */
    where?: developmentExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of developmentExperiences to fetch.
     */
    orderBy?: Enumerable<developmentExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for developmentExperiences.
     */
    cursor?: developmentExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` developmentExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` developmentExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of developmentExperiences.
     */
    distinct?: Enumerable<DevelopmentExperienceScalarFieldEnum>
  }


  /**
   * developmentExperience findMany
   */
  export type developmentExperienceFindManyArgs = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
    /**
     * Filter, which developmentExperiences to fetch.
     */
    where?: developmentExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of developmentExperiences to fetch.
     */
    orderBy?: Enumerable<developmentExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing developmentExperiences.
     */
    cursor?: developmentExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` developmentExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` developmentExperiences.
     */
    skip?: number
    distinct?: Enumerable<DevelopmentExperienceScalarFieldEnum>
  }


  /**
   * developmentExperience create
   */
  export type developmentExperienceCreateArgs = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
    /**
     * The data needed to create a developmentExperience.
     */
    data: XOR<developmentExperienceCreateInput, developmentExperienceUncheckedCreateInput>
  }


  /**
   * developmentExperience createMany
   */
  export type developmentExperienceCreateManyArgs = {
    /**
     * The data used to create many developmentExperiences.
     */
    data: Enumerable<developmentExperienceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * developmentExperience update
   */
  export type developmentExperienceUpdateArgs = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
    /**
     * The data needed to update a developmentExperience.
     */
    data: XOR<developmentExperienceUpdateInput, developmentExperienceUncheckedUpdateInput>
    /**
     * Choose, which developmentExperience to update.
     */
    where: developmentExperienceWhereUniqueInput
  }


  /**
   * developmentExperience updateMany
   */
  export type developmentExperienceUpdateManyArgs = {
    /**
     * The data used to update developmentExperiences.
     */
    data: XOR<developmentExperienceUpdateManyMutationInput, developmentExperienceUncheckedUpdateManyInput>
    /**
     * Filter which developmentExperiences to update
     */
    where?: developmentExperienceWhereInput
  }


  /**
   * developmentExperience upsert
   */
  export type developmentExperienceUpsertArgs = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
    /**
     * The filter to search for the developmentExperience to update in case it exists.
     */
    where: developmentExperienceWhereUniqueInput
    /**
     * In case the developmentExperience found by the `where` argument doesn't exist, create a new developmentExperience with this data.
     */
    create: XOR<developmentExperienceCreateInput, developmentExperienceUncheckedCreateInput>
    /**
     * In case the developmentExperience was found with the provided `where` argument, update it with this data.
     */
    update: XOR<developmentExperienceUpdateInput, developmentExperienceUncheckedUpdateInput>
  }


  /**
   * developmentExperience delete
   */
  export type developmentExperienceDeleteArgs = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
    /**
     * Filter which developmentExperience to delete.
     */
    where: developmentExperienceWhereUniqueInput
  }


  /**
   * developmentExperience deleteMany
   */
  export type developmentExperienceDeleteManyArgs = {
    /**
     * Filter which developmentExperiences to delete
     */
    where?: developmentExperienceWhereInput
  }


  /**
   * developmentExperience without action
   */
  export type developmentExperienceArgs = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
  }



  /**
   * Model autoCalibration
   */


  export type AggregateAutoCalibration = {
    _count: AutoCalibrationCountAggregateOutputType | null
    _avg: AutoCalibrationAvgAggregateOutputType | null
    _sum: AutoCalibrationSumAggregateOutputType | null
    _min: AutoCalibrationMinAggregateOutputType | null
    _max: AutoCalibrationMaxAggregateOutputType | null
  }

  export type AutoCalibrationAvgAggregateOutputType = {
    autoCalibrationId: number | null
    membership: number | null
    category: number | null
    FR: number | null
    CL: number | null
    ML: number | null
    QA: number | null
    JAVA: number | null
    PHP: number | null
  }

  export type AutoCalibrationSumAggregateOutputType = {
    autoCalibrationId: number | null
    membership: number | null
    category: number | null
    FR: number | null
    CL: number | null
    ML: number | null
    QA: number | null
    JAVA: number | null
    PHP: number | null
  }

  export type AutoCalibrationMinAggregateOutputType = {
    autoCalibrationId: number | null
    skill: string | null
    membership: number | null
    category: number | null
    FR: number | null
    CL: number | null
    ML: number | null
    QA: number | null
    JAVA: number | null
    PHP: number | null
  }

  export type AutoCalibrationMaxAggregateOutputType = {
    autoCalibrationId: number | null
    skill: string | null
    membership: number | null
    category: number | null
    FR: number | null
    CL: number | null
    ML: number | null
    QA: number | null
    JAVA: number | null
    PHP: number | null
  }

  export type AutoCalibrationCountAggregateOutputType = {
    autoCalibrationId: number
    skill: number
    membership: number
    category: number
    FR: number
    CL: number
    ML: number
    QA: number
    JAVA: number
    PHP: number
    _all: number
  }


  export type AutoCalibrationAvgAggregateInputType = {
    autoCalibrationId?: true
    membership?: true
    category?: true
    FR?: true
    CL?: true
    ML?: true
    QA?: true
    JAVA?: true
    PHP?: true
  }

  export type AutoCalibrationSumAggregateInputType = {
    autoCalibrationId?: true
    membership?: true
    category?: true
    FR?: true
    CL?: true
    ML?: true
    QA?: true
    JAVA?: true
    PHP?: true
  }

  export type AutoCalibrationMinAggregateInputType = {
    autoCalibrationId?: true
    skill?: true
    membership?: true
    category?: true
    FR?: true
    CL?: true
    ML?: true
    QA?: true
    JAVA?: true
    PHP?: true
  }

  export type AutoCalibrationMaxAggregateInputType = {
    autoCalibrationId?: true
    skill?: true
    membership?: true
    category?: true
    FR?: true
    CL?: true
    ML?: true
    QA?: true
    JAVA?: true
    PHP?: true
  }

  export type AutoCalibrationCountAggregateInputType = {
    autoCalibrationId?: true
    skill?: true
    membership?: true
    category?: true
    FR?: true
    CL?: true
    ML?: true
    QA?: true
    JAVA?: true
    PHP?: true
    _all?: true
  }

  export type AutoCalibrationAggregateArgs = {
    /**
     * Filter which autoCalibration to aggregate.
     */
    where?: autoCalibrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autoCalibrations to fetch.
     */
    orderBy?: Enumerable<autoCalibrationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autoCalibrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autoCalibrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autoCalibrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autoCalibrations
    **/
    _count?: true | AutoCalibrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoCalibrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoCalibrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoCalibrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoCalibrationMaxAggregateInputType
  }

  export type GetAutoCalibrationAggregateType<T extends AutoCalibrationAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoCalibration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoCalibration[P]>
      : GetScalarType<T[P], AggregateAutoCalibration[P]>
  }




  export type AutoCalibrationGroupByArgs = {
    where?: autoCalibrationWhereInput
    orderBy?: Enumerable<autoCalibrationOrderByWithAggregationInput>
    by: AutoCalibrationScalarFieldEnum[]
    having?: autoCalibrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoCalibrationCountAggregateInputType | true
    _avg?: AutoCalibrationAvgAggregateInputType
    _sum?: AutoCalibrationSumAggregateInputType
    _min?: AutoCalibrationMinAggregateInputType
    _max?: AutoCalibrationMaxAggregateInputType
  }


  export type AutoCalibrationGroupByOutputType = {
    autoCalibrationId: number
    skill: string
    membership: number
    category: number
    FR: number
    CL: number
    ML: number
    QA: number
    JAVA: number
    PHP: number
    _count: AutoCalibrationCountAggregateOutputType | null
    _avg: AutoCalibrationAvgAggregateOutputType | null
    _sum: AutoCalibrationSumAggregateOutputType | null
    _min: AutoCalibrationMinAggregateOutputType | null
    _max: AutoCalibrationMaxAggregateOutputType | null
  }

  type GetAutoCalibrationGroupByPayload<T extends AutoCalibrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AutoCalibrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoCalibrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoCalibrationGroupByOutputType[P]>
            : GetScalarType<T[P], AutoCalibrationGroupByOutputType[P]>
        }
      >
    >


  export type autoCalibrationSelect = {
    autoCalibrationId?: boolean
    skill?: boolean
    membership?: boolean
    category?: boolean
    FR?: boolean
    CL?: boolean
    ML?: boolean
    QA?: boolean
    JAVA?: boolean
    PHP?: boolean
    skillSummaries?: boolean | autoCalibration$skillSummariesArgs
    developmentExperiences?: boolean | autoCalibration$developmentExperiencesArgs
    _count?: boolean | AutoCalibrationCountOutputTypeArgs
  }


  export type autoCalibrationInclude = {
    skillSummaries?: boolean | autoCalibration$skillSummariesArgs
    developmentExperiences?: boolean | autoCalibration$developmentExperiencesArgs
    _count?: boolean | AutoCalibrationCountOutputTypeArgs
  }

  export type autoCalibrationGetPayload<S extends boolean | null | undefined | autoCalibrationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? autoCalibration :
    S extends undefined ? never :
    S extends { include: any } & (autoCalibrationArgs | autoCalibrationFindManyArgs)
    ? autoCalibration  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'skillSummaries' ? Array < skillSummaryGetPayload<S['include'][P]>>  :
        P extends 'developmentExperiences' ? Array < developmentExperienceGetPayload<S['include'][P]>>  :
        P extends '_count' ? AutoCalibrationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (autoCalibrationArgs | autoCalibrationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'skillSummaries' ? Array < skillSummaryGetPayload<S['select'][P]>>  :
        P extends 'developmentExperiences' ? Array < developmentExperienceGetPayload<S['select'][P]>>  :
        P extends '_count' ? AutoCalibrationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof autoCalibration ? autoCalibration[P] : never
  } 
      : autoCalibration


  type autoCalibrationCountArgs = 
    Omit<autoCalibrationFindManyArgs, 'select' | 'include'> & {
      select?: AutoCalibrationCountAggregateInputType | true
    }

  export interface autoCalibrationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AutoCalibration that matches the filter.
     * @param {autoCalibrationFindUniqueArgs} args - Arguments to find a AutoCalibration
     * @example
     * // Get one AutoCalibration
     * const autoCalibration = await prisma.autoCalibration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autoCalibrationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autoCalibrationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autoCalibration'> extends True ? Prisma__autoCalibrationClient<autoCalibrationGetPayload<T>> : Prisma__autoCalibrationClient<autoCalibrationGetPayload<T> | null, null>

    /**
     * Find one AutoCalibration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autoCalibrationFindUniqueOrThrowArgs} args - Arguments to find a AutoCalibration
     * @example
     * // Get one AutoCalibration
     * const autoCalibration = await prisma.autoCalibration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autoCalibrationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, autoCalibrationFindUniqueOrThrowArgs>
    ): Prisma__autoCalibrationClient<autoCalibrationGetPayload<T>>

    /**
     * Find the first AutoCalibration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autoCalibrationFindFirstArgs} args - Arguments to find a AutoCalibration
     * @example
     * // Get one AutoCalibration
     * const autoCalibration = await prisma.autoCalibration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autoCalibrationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autoCalibrationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autoCalibration'> extends True ? Prisma__autoCalibrationClient<autoCalibrationGetPayload<T>> : Prisma__autoCalibrationClient<autoCalibrationGetPayload<T> | null, null>

    /**
     * Find the first AutoCalibration that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autoCalibrationFindFirstOrThrowArgs} args - Arguments to find a AutoCalibration
     * @example
     * // Get one AutoCalibration
     * const autoCalibration = await prisma.autoCalibration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autoCalibrationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, autoCalibrationFindFirstOrThrowArgs>
    ): Prisma__autoCalibrationClient<autoCalibrationGetPayload<T>>

    /**
     * Find zero or more AutoCalibrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autoCalibrationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoCalibrations
     * const autoCalibrations = await prisma.autoCalibration.findMany()
     * 
     * // Get first 10 AutoCalibrations
     * const autoCalibrations = await prisma.autoCalibration.findMany({ take: 10 })
     * 
     * // Only select the `autoCalibrationId`
     * const autoCalibrationWithAutoCalibrationIdOnly = await prisma.autoCalibration.findMany({ select: { autoCalibrationId: true } })
     * 
    **/
    findMany<T extends autoCalibrationFindManyArgs>(
      args?: SelectSubset<T, autoCalibrationFindManyArgs>
    ): Prisma.PrismaPromise<Array<autoCalibrationGetPayload<T>>>

    /**
     * Create a AutoCalibration.
     * @param {autoCalibrationCreateArgs} args - Arguments to create a AutoCalibration.
     * @example
     * // Create one AutoCalibration
     * const AutoCalibration = await prisma.autoCalibration.create({
     *   data: {
     *     // ... data to create a AutoCalibration
     *   }
     * })
     * 
    **/
    create<T extends autoCalibrationCreateArgs>(
      args: SelectSubset<T, autoCalibrationCreateArgs>
    ): Prisma__autoCalibrationClient<autoCalibrationGetPayload<T>>

    /**
     * Create many AutoCalibrations.
     *     @param {autoCalibrationCreateManyArgs} args - Arguments to create many AutoCalibrations.
     *     @example
     *     // Create many AutoCalibrations
     *     const autoCalibration = await prisma.autoCalibration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autoCalibrationCreateManyArgs>(
      args?: SelectSubset<T, autoCalibrationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutoCalibration.
     * @param {autoCalibrationDeleteArgs} args - Arguments to delete one AutoCalibration.
     * @example
     * // Delete one AutoCalibration
     * const AutoCalibration = await prisma.autoCalibration.delete({
     *   where: {
     *     // ... filter to delete one AutoCalibration
     *   }
     * })
     * 
    **/
    delete<T extends autoCalibrationDeleteArgs>(
      args: SelectSubset<T, autoCalibrationDeleteArgs>
    ): Prisma__autoCalibrationClient<autoCalibrationGetPayload<T>>

    /**
     * Update one AutoCalibration.
     * @param {autoCalibrationUpdateArgs} args - Arguments to update one AutoCalibration.
     * @example
     * // Update one AutoCalibration
     * const autoCalibration = await prisma.autoCalibration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autoCalibrationUpdateArgs>(
      args: SelectSubset<T, autoCalibrationUpdateArgs>
    ): Prisma__autoCalibrationClient<autoCalibrationGetPayload<T>>

    /**
     * Delete zero or more AutoCalibrations.
     * @param {autoCalibrationDeleteManyArgs} args - Arguments to filter AutoCalibrations to delete.
     * @example
     * // Delete a few AutoCalibrations
     * const { count } = await prisma.autoCalibration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autoCalibrationDeleteManyArgs>(
      args?: SelectSubset<T, autoCalibrationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoCalibrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autoCalibrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoCalibrations
     * const autoCalibration = await prisma.autoCalibration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autoCalibrationUpdateManyArgs>(
      args: SelectSubset<T, autoCalibrationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoCalibration.
     * @param {autoCalibrationUpsertArgs} args - Arguments to update or create a AutoCalibration.
     * @example
     * // Update or create a AutoCalibration
     * const autoCalibration = await prisma.autoCalibration.upsert({
     *   create: {
     *     // ... data to create a AutoCalibration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoCalibration we want to update
     *   }
     * })
    **/
    upsert<T extends autoCalibrationUpsertArgs>(
      args: SelectSubset<T, autoCalibrationUpsertArgs>
    ): Prisma__autoCalibrationClient<autoCalibrationGetPayload<T>>

    /**
     * Count the number of AutoCalibrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autoCalibrationCountArgs} args - Arguments to filter AutoCalibrations to count.
     * @example
     * // Count the number of AutoCalibrations
     * const count = await prisma.autoCalibration.count({
     *   where: {
     *     // ... the filter for the AutoCalibrations we want to count
     *   }
     * })
    **/
    count<T extends autoCalibrationCountArgs>(
      args?: Subset<T, autoCalibrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoCalibrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoCalibration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoCalibrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoCalibrationAggregateArgs>(args: Subset<T, AutoCalibrationAggregateArgs>): Prisma.PrismaPromise<GetAutoCalibrationAggregateType<T>>

    /**
     * Group by AutoCalibration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoCalibrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoCalibrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoCalibrationGroupByArgs['orderBy'] }
        : { orderBy?: AutoCalibrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoCalibrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoCalibrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autoCalibration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autoCalibrationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    skillSummaries<T extends autoCalibration$skillSummariesArgs= {}>(args?: Subset<T, autoCalibration$skillSummariesArgs>): Prisma.PrismaPromise<Array<skillSummaryGetPayload<T>>| Null>;

    developmentExperiences<T extends autoCalibration$developmentExperiencesArgs= {}>(args?: Subset<T, autoCalibration$developmentExperiencesArgs>): Prisma.PrismaPromise<Array<developmentExperienceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autoCalibration base type for findUnique actions
   */
  export type autoCalibrationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the autoCalibration
     */
    select?: autoCalibrationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autoCalibrationInclude | null
    /**
     * Filter, which autoCalibration to fetch.
     */
    where: autoCalibrationWhereUniqueInput
  }

  /**
   * autoCalibration findUnique
   */
  export interface autoCalibrationFindUniqueArgs extends autoCalibrationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autoCalibration findUniqueOrThrow
   */
  export type autoCalibrationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the autoCalibration
     */
    select?: autoCalibrationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autoCalibrationInclude | null
    /**
     * Filter, which autoCalibration to fetch.
     */
    where: autoCalibrationWhereUniqueInput
  }


  /**
   * autoCalibration base type for findFirst actions
   */
  export type autoCalibrationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the autoCalibration
     */
    select?: autoCalibrationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autoCalibrationInclude | null
    /**
     * Filter, which autoCalibration to fetch.
     */
    where?: autoCalibrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autoCalibrations to fetch.
     */
    orderBy?: Enumerable<autoCalibrationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autoCalibrations.
     */
    cursor?: autoCalibrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autoCalibrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autoCalibrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autoCalibrations.
     */
    distinct?: Enumerable<AutoCalibrationScalarFieldEnum>
  }

  /**
   * autoCalibration findFirst
   */
  export interface autoCalibrationFindFirstArgs extends autoCalibrationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autoCalibration findFirstOrThrow
   */
  export type autoCalibrationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the autoCalibration
     */
    select?: autoCalibrationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autoCalibrationInclude | null
    /**
     * Filter, which autoCalibration to fetch.
     */
    where?: autoCalibrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autoCalibrations to fetch.
     */
    orderBy?: Enumerable<autoCalibrationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autoCalibrations.
     */
    cursor?: autoCalibrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autoCalibrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autoCalibrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autoCalibrations.
     */
    distinct?: Enumerable<AutoCalibrationScalarFieldEnum>
  }


  /**
   * autoCalibration findMany
   */
  export type autoCalibrationFindManyArgs = {
    /**
     * Select specific fields to fetch from the autoCalibration
     */
    select?: autoCalibrationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autoCalibrationInclude | null
    /**
     * Filter, which autoCalibrations to fetch.
     */
    where?: autoCalibrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autoCalibrations to fetch.
     */
    orderBy?: Enumerable<autoCalibrationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autoCalibrations.
     */
    cursor?: autoCalibrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autoCalibrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autoCalibrations.
     */
    skip?: number
    distinct?: Enumerable<AutoCalibrationScalarFieldEnum>
  }


  /**
   * autoCalibration create
   */
  export type autoCalibrationCreateArgs = {
    /**
     * Select specific fields to fetch from the autoCalibration
     */
    select?: autoCalibrationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autoCalibrationInclude | null
    /**
     * The data needed to create a autoCalibration.
     */
    data: XOR<autoCalibrationCreateInput, autoCalibrationUncheckedCreateInput>
  }


  /**
   * autoCalibration createMany
   */
  export type autoCalibrationCreateManyArgs = {
    /**
     * The data used to create many autoCalibrations.
     */
    data: Enumerable<autoCalibrationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * autoCalibration update
   */
  export type autoCalibrationUpdateArgs = {
    /**
     * Select specific fields to fetch from the autoCalibration
     */
    select?: autoCalibrationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autoCalibrationInclude | null
    /**
     * The data needed to update a autoCalibration.
     */
    data: XOR<autoCalibrationUpdateInput, autoCalibrationUncheckedUpdateInput>
    /**
     * Choose, which autoCalibration to update.
     */
    where: autoCalibrationWhereUniqueInput
  }


  /**
   * autoCalibration updateMany
   */
  export type autoCalibrationUpdateManyArgs = {
    /**
     * The data used to update autoCalibrations.
     */
    data: XOR<autoCalibrationUpdateManyMutationInput, autoCalibrationUncheckedUpdateManyInput>
    /**
     * Filter which autoCalibrations to update
     */
    where?: autoCalibrationWhereInput
  }


  /**
   * autoCalibration upsert
   */
  export type autoCalibrationUpsertArgs = {
    /**
     * Select specific fields to fetch from the autoCalibration
     */
    select?: autoCalibrationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autoCalibrationInclude | null
    /**
     * The filter to search for the autoCalibration to update in case it exists.
     */
    where: autoCalibrationWhereUniqueInput
    /**
     * In case the autoCalibration found by the `where` argument doesn't exist, create a new autoCalibration with this data.
     */
    create: XOR<autoCalibrationCreateInput, autoCalibrationUncheckedCreateInput>
    /**
     * In case the autoCalibration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autoCalibrationUpdateInput, autoCalibrationUncheckedUpdateInput>
  }


  /**
   * autoCalibration delete
   */
  export type autoCalibrationDeleteArgs = {
    /**
     * Select specific fields to fetch from the autoCalibration
     */
    select?: autoCalibrationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autoCalibrationInclude | null
    /**
     * Filter which autoCalibration to delete.
     */
    where: autoCalibrationWhereUniqueInput
  }


  /**
   * autoCalibration deleteMany
   */
  export type autoCalibrationDeleteManyArgs = {
    /**
     * Filter which autoCalibrations to delete
     */
    where?: autoCalibrationWhereInput
  }


  /**
   * autoCalibration.skillSummaries
   */
  export type autoCalibration$skillSummariesArgs = {
    /**
     * Select specific fields to fetch from the skillSummary
     */
    select?: skillSummarySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: skillSummaryInclude | null
    where?: skillSummaryWhereInput
    orderBy?: Enumerable<skillSummaryOrderByWithRelationInput>
    cursor?: skillSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SkillSummaryScalarFieldEnum>
  }


  /**
   * autoCalibration.developmentExperiences
   */
  export type autoCalibration$developmentExperiencesArgs = {
    /**
     * Select specific fields to fetch from the developmentExperience
     */
    select?: developmentExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: developmentExperienceInclude | null
    where?: developmentExperienceWhereInput
    orderBy?: Enumerable<developmentExperienceOrderByWithRelationInput>
    cursor?: developmentExperienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DevelopmentExperienceScalarFieldEnum>
  }


  /**
   * autoCalibration without action
   */
  export type autoCalibrationArgs = {
    /**
     * Select specific fields to fetch from the autoCalibration
     */
    select?: autoCalibrationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: autoCalibrationInclude | null
  }



  /**
   * Model request
   */


  export type AggregateRequest = {
    _count: RequestCountAggregateOutputType | null
    _avg: RequestAvgAggregateOutputType | null
    _sum: RequestSumAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  export type RequestAvgAggregateOutputType = {
    applicationId: number | null
    userId: number | null
    status: number | null
    adminId: number | null
  }

  export type RequestSumAggregateOutputType = {
    applicationId: number | null
    userId: number | null
    status: number | null
    adminId: number | null
  }

  export type RequestMinAggregateOutputType = {
    applicationId: number | null
    userId: number | null
    status: number | null
    adminComment: string | null
    engineerComment: string | null
    adminId: number | null
    createdAt: Date | null
    resultedAt: Date | null
  }

  export type RequestMaxAggregateOutputType = {
    applicationId: number | null
    userId: number | null
    status: number | null
    adminComment: string | null
    engineerComment: string | null
    adminId: number | null
    createdAt: Date | null
    resultedAt: Date | null
  }

  export type RequestCountAggregateOutputType = {
    applicationId: number
    userId: number
    status: number
    adminComment: number
    engineerComment: number
    adminId: number
    createdAt: number
    resultedAt: number
    _all: number
  }


  export type RequestAvgAggregateInputType = {
    applicationId?: true
    userId?: true
    status?: true
    adminId?: true
  }

  export type RequestSumAggregateInputType = {
    applicationId?: true
    userId?: true
    status?: true
    adminId?: true
  }

  export type RequestMinAggregateInputType = {
    applicationId?: true
    userId?: true
    status?: true
    adminComment?: true
    engineerComment?: true
    adminId?: true
    createdAt?: true
    resultedAt?: true
  }

  export type RequestMaxAggregateInputType = {
    applicationId?: true
    userId?: true
    status?: true
    adminComment?: true
    engineerComment?: true
    adminId?: true
    createdAt?: true
    resultedAt?: true
  }

  export type RequestCountAggregateInputType = {
    applicationId?: true
    userId?: true
    status?: true
    adminComment?: true
    engineerComment?: true
    adminId?: true
    createdAt?: true
    resultedAt?: true
    _all?: true
  }

  export type RequestAggregateArgs = {
    /**
     * Filter which request to aggregate.
     */
    where?: requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: Enumerable<requestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requests
    **/
    _count?: true | RequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestMaxAggregateInputType
  }

  export type GetRequestAggregateType<T extends RequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequest[P]>
      : GetScalarType<T[P], AggregateRequest[P]>
  }




  export type RequestGroupByArgs = {
    where?: requestWhereInput
    orderBy?: Enumerable<requestOrderByWithAggregationInput>
    by: RequestScalarFieldEnum[]
    having?: requestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestCountAggregateInputType | true
    _avg?: RequestAvgAggregateInputType
    _sum?: RequestSumAggregateInputType
    _min?: RequestMinAggregateInputType
    _max?: RequestMaxAggregateInputType
  }


  export type RequestGroupByOutputType = {
    applicationId: number
    userId: number
    status: number
    adminComment: string
    engineerComment: string
    adminId: number
    createdAt: Date
    resultedAt: Date
    _count: RequestCountAggregateOutputType | null
    _avg: RequestAvgAggregateOutputType | null
    _sum: RequestSumAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  type GetRequestGroupByPayload<T extends RequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestGroupByOutputType[P]>
            : GetScalarType<T[P], RequestGroupByOutputType[P]>
        }
      >
    >


  export type requestSelect = {
    applicationId?: boolean
    userId?: boolean
    status?: boolean
    adminComment?: boolean
    engineerComment?: boolean
    adminId?: boolean
    createdAt?: boolean
    resultedAt?: boolean
    user?: boolean | userArgs
    admin?: boolean | adminArgs
  }


  export type requestInclude = {
    user?: boolean | userArgs
    admin?: boolean | adminArgs
  }

  export type requestGetPayload<S extends boolean | null | undefined | requestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? request :
    S extends undefined ? never :
    S extends { include: any } & (requestArgs | requestFindManyArgs)
    ? request  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends 'admin' ? adminGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (requestArgs | requestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends 'admin' ? adminGetPayload<S['select'][P]> :  P extends keyof request ? request[P] : never
  } 
      : request


  type requestCountArgs = 
    Omit<requestFindManyArgs, 'select' | 'include'> & {
      select?: RequestCountAggregateInputType | true
    }

  export interface requestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Request that matches the filter.
     * @param {requestFindUniqueArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends requestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, requestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'request'> extends True ? Prisma__requestClient<requestGetPayload<T>> : Prisma__requestClient<requestGetPayload<T> | null, null>

    /**
     * Find one Request that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {requestFindUniqueOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends requestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, requestFindUniqueOrThrowArgs>
    ): Prisma__requestClient<requestGetPayload<T>>

    /**
     * Find the first Request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestFindFirstArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends requestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, requestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'request'> extends True ? Prisma__requestClient<requestGetPayload<T>> : Prisma__requestClient<requestGetPayload<T> | null, null>

    /**
     * Find the first Request that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestFindFirstOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends requestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, requestFindFirstOrThrowArgs>
    ): Prisma__requestClient<requestGetPayload<T>>

    /**
     * Find zero or more Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requests
     * const requests = await prisma.request.findMany()
     * 
     * // Get first 10 Requests
     * const requests = await prisma.request.findMany({ take: 10 })
     * 
     * // Only select the `applicationId`
     * const requestWithApplicationIdOnly = await prisma.request.findMany({ select: { applicationId: true } })
     * 
    **/
    findMany<T extends requestFindManyArgs>(
      args?: SelectSubset<T, requestFindManyArgs>
    ): Prisma.PrismaPromise<Array<requestGetPayload<T>>>

    /**
     * Create a Request.
     * @param {requestCreateArgs} args - Arguments to create a Request.
     * @example
     * // Create one Request
     * const Request = await prisma.request.create({
     *   data: {
     *     // ... data to create a Request
     *   }
     * })
     * 
    **/
    create<T extends requestCreateArgs>(
      args: SelectSubset<T, requestCreateArgs>
    ): Prisma__requestClient<requestGetPayload<T>>

    /**
     * Create many Requests.
     *     @param {requestCreateManyArgs} args - Arguments to create many Requests.
     *     @example
     *     // Create many Requests
     *     const request = await prisma.request.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends requestCreateManyArgs>(
      args?: SelectSubset<T, requestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Request.
     * @param {requestDeleteArgs} args - Arguments to delete one Request.
     * @example
     * // Delete one Request
     * const Request = await prisma.request.delete({
     *   where: {
     *     // ... filter to delete one Request
     *   }
     * })
     * 
    **/
    delete<T extends requestDeleteArgs>(
      args: SelectSubset<T, requestDeleteArgs>
    ): Prisma__requestClient<requestGetPayload<T>>

    /**
     * Update one Request.
     * @param {requestUpdateArgs} args - Arguments to update one Request.
     * @example
     * // Update one Request
     * const request = await prisma.request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends requestUpdateArgs>(
      args: SelectSubset<T, requestUpdateArgs>
    ): Prisma__requestClient<requestGetPayload<T>>

    /**
     * Delete zero or more Requests.
     * @param {requestDeleteManyArgs} args - Arguments to filter Requests to delete.
     * @example
     * // Delete a few Requests
     * const { count } = await prisma.request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends requestDeleteManyArgs>(
      args?: SelectSubset<T, requestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requests
     * const request = await prisma.request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends requestUpdateManyArgs>(
      args: SelectSubset<T, requestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Request.
     * @param {requestUpsertArgs} args - Arguments to update or create a Request.
     * @example
     * // Update or create a Request
     * const request = await prisma.request.upsert({
     *   create: {
     *     // ... data to create a Request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Request we want to update
     *   }
     * })
    **/
    upsert<T extends requestUpsertArgs>(
      args: SelectSubset<T, requestUpsertArgs>
    ): Prisma__requestClient<requestGetPayload<T>>

    /**
     * Count the number of Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestCountArgs} args - Arguments to filter Requests to count.
     * @example
     * // Count the number of Requests
     * const count = await prisma.request.count({
     *   where: {
     *     // ... the filter for the Requests we want to count
     *   }
     * })
    **/
    count<T extends requestCountArgs>(
      args?: Subset<T, requestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestAggregateArgs>(args: Subset<T, RequestAggregateArgs>): Prisma.PrismaPromise<GetRequestAggregateType<T>>

    /**
     * Group by Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestGroupByArgs['orderBy'] }
        : { orderBy?: RequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__requestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    admin<T extends adminArgs= {}>(args?: Subset<T, adminArgs>): Prisma__adminClient<adminGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * request base type for findUnique actions
   */
  export type requestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
    /**
     * Filter, which request to fetch.
     */
    where: requestWhereUniqueInput
  }

  /**
   * request findUnique
   */
  export interface requestFindUniqueArgs extends requestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * request findUniqueOrThrow
   */
  export type requestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
    /**
     * Filter, which request to fetch.
     */
    where: requestWhereUniqueInput
  }


  /**
   * request base type for findFirst actions
   */
  export type requestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
    /**
     * Filter, which request to fetch.
     */
    where?: requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: Enumerable<requestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requests.
     */
    cursor?: requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requests.
     */
    distinct?: Enumerable<RequestScalarFieldEnum>
  }

  /**
   * request findFirst
   */
  export interface requestFindFirstArgs extends requestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * request findFirstOrThrow
   */
  export type requestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
    /**
     * Filter, which request to fetch.
     */
    where?: requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: Enumerable<requestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requests.
     */
    cursor?: requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requests.
     */
    distinct?: Enumerable<RequestScalarFieldEnum>
  }


  /**
   * request findMany
   */
  export type requestFindManyArgs = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
    /**
     * Filter, which requests to fetch.
     */
    where?: requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requests to fetch.
     */
    orderBy?: Enumerable<requestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requests.
     */
    cursor?: requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requests.
     */
    skip?: number
    distinct?: Enumerable<RequestScalarFieldEnum>
  }


  /**
   * request create
   */
  export type requestCreateArgs = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
    /**
     * The data needed to create a request.
     */
    data: XOR<requestCreateInput, requestUncheckedCreateInput>
  }


  /**
   * request createMany
   */
  export type requestCreateManyArgs = {
    /**
     * The data used to create many requests.
     */
    data: Enumerable<requestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * request update
   */
  export type requestUpdateArgs = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
    /**
     * The data needed to update a request.
     */
    data: XOR<requestUpdateInput, requestUncheckedUpdateInput>
    /**
     * Choose, which request to update.
     */
    where: requestWhereUniqueInput
  }


  /**
   * request updateMany
   */
  export type requestUpdateManyArgs = {
    /**
     * The data used to update requests.
     */
    data: XOR<requestUpdateManyMutationInput, requestUncheckedUpdateManyInput>
    /**
     * Filter which requests to update
     */
    where?: requestWhereInput
  }


  /**
   * request upsert
   */
  export type requestUpsertArgs = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
    /**
     * The filter to search for the request to update in case it exists.
     */
    where: requestWhereUniqueInput
    /**
     * In case the request found by the `where` argument doesn't exist, create a new request with this data.
     */
    create: XOR<requestCreateInput, requestUncheckedCreateInput>
    /**
     * In case the request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<requestUpdateInput, requestUncheckedUpdateInput>
  }


  /**
   * request delete
   */
  export type requestDeleteArgs = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
    /**
     * Filter which request to delete.
     */
    where: requestWhereUniqueInput
  }


  /**
   * request deleteMany
   */
  export type requestDeleteManyArgs = {
    /**
     * Filter which requests to delete
     */
    where?: requestWhereInput
  }


  /**
   * request without action
   */
  export type requestArgs = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
  }



  /**
   * Model admin
   */


  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    adminId: number | null
  }

  export type AdminSumAggregateOutputType = {
    adminId: number | null
  }

  export type AdminMinAggregateOutputType = {
    adminId: number | null
    email: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    adminId: number | null
    email: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    adminId: number
    email: number
    password: number
    name: number
    createdAt: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    adminId?: true
  }

  export type AdminSumAggregateInputType = {
    adminId?: true
  }

  export type AdminMinAggregateInputType = {
    adminId?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
  }

  export type AdminMaxAggregateInputType = {
    adminId?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
  }

  export type AdminCountAggregateInputType = {
    adminId?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAggregateArgs = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: Enumerable<adminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs = {
    where?: adminWhereInput
    orderBy?: Enumerable<adminOrderByWithAggregationInput>
    by: AdminScalarFieldEnum[]
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }


  export type AdminGroupByOutputType = {
    adminId: number
    email: string
    password: string
    name: string
    createdAt: Date
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect = {
    adminId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    requests?: boolean | admin$requestsArgs
    _count?: boolean | AdminCountOutputTypeArgs
  }


  export type adminInclude = {
    requests?: boolean | admin$requestsArgs
    _count?: boolean | AdminCountOutputTypeArgs
  }

  export type adminGetPayload<S extends boolean | null | undefined | adminArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? admin :
    S extends undefined ? never :
    S extends { include: any } & (adminArgs | adminFindManyArgs)
    ? admin  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'requests' ? Array < requestGetPayload<S['include'][P]>>  :
        P extends '_count' ? AdminCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (adminArgs | adminFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'requests' ? Array < requestGetPayload<S['select'][P]>>  :
        P extends '_count' ? AdminCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof admin ? admin[P] : never
  } 
      : admin


  type adminCountArgs = 
    Omit<adminFindManyArgs, 'select' | 'include'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends adminFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, adminFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'admin'> extends True ? Prisma__adminClient<adminGetPayload<T>> : Prisma__adminClient<adminGetPayload<T> | null, null>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, adminFindUniqueOrThrowArgs>
    ): Prisma__adminClient<adminGetPayload<T>>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends adminFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, adminFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'admin'> extends True ? Prisma__adminClient<adminGetPayload<T>> : Prisma__adminClient<adminGetPayload<T> | null, null>

    /**
     * Find the first Admin that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(
      args?: SelectSubset<T, adminFindFirstOrThrowArgs>
    ): Prisma__adminClient<adminGetPayload<T>>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `adminId`
     * const adminWithAdminIdOnly = await prisma.admin.findMany({ select: { adminId: true } })
     * 
    **/
    findMany<T extends adminFindManyArgs>(
      args?: SelectSubset<T, adminFindManyArgs>
    ): Prisma.PrismaPromise<Array<adminGetPayload<T>>>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends adminCreateArgs>(
      args: SelectSubset<T, adminCreateArgs>
    ): Prisma__adminClient<adminGetPayload<T>>

    /**
     * Create many Admins.
     *     @param {adminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends adminCreateManyArgs>(
      args?: SelectSubset<T, adminCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends adminDeleteArgs>(
      args: SelectSubset<T, adminDeleteArgs>
    ): Prisma__adminClient<adminGetPayload<T>>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends adminUpdateArgs>(
      args: SelectSubset<T, adminUpdateArgs>
    ): Prisma__adminClient<adminGetPayload<T>>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends adminDeleteManyArgs>(
      args?: SelectSubset<T, adminDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends adminUpdateManyArgs>(
      args: SelectSubset<T, adminUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends adminUpsertArgs>(
      args: SelectSubset<T, adminUpsertArgs>
    ): Prisma__adminClient<adminGetPayload<T>>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__adminClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    requests<T extends admin$requestsArgs= {}>(args?: Subset<T, admin$requestsArgs>): Prisma.PrismaPromise<Array<requestGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * admin base type for findUnique actions
   */
  export type adminFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUnique
   */
  export interface adminFindUniqueArgs extends adminFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }


  /**
   * admin base type for findFirst actions
   */
  export type adminFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: Enumerable<adminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: Enumerable<AdminScalarFieldEnum>
  }

  /**
   * admin findFirst
   */
  export interface adminFindFirstArgs extends adminFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: Enumerable<adminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * admin findMany
   */
  export type adminFindManyArgs = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: Enumerable<adminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * admin create
   */
  export type adminCreateArgs = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude | null
    /**
     * The data needed to create a admin.
     */
    data: XOR<adminCreateInput, adminUncheckedCreateInput>
  }


  /**
   * admin createMany
   */
  export type adminCreateManyArgs = {
    /**
     * The data used to create many admins.
     */
    data: Enumerable<adminCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * admin update
   */
  export type adminUpdateArgs = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }


  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
  }


  /**
   * admin upsert
   */
  export type adminUpsertArgs = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }


  /**
   * admin delete
   */
  export type adminDeleteArgs = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }


  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
  }


  /**
   * admin.requests
   */
  export type admin$requestsArgs = {
    /**
     * Select specific fields to fetch from the request
     */
    select?: requestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: requestInclude | null
    where?: requestWhereInput
    orderBy?: Enumerable<requestOrderByWithRelationInput>
    cursor?: requestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RequestScalarFieldEnum>
  }


  /**
   * admin without action
   */
  export type adminArgs = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: adminInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AdminScalarFieldEnum: {
    adminId: 'adminId',
    email: 'email',
    password: 'password',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AutoCalibrationScalarFieldEnum: {
    autoCalibrationId: 'autoCalibrationId',
    skill: 'skill',
    membership: 'membership',
    category: 'category',
    FR: 'FR',
    CL: 'CL',
    ML: 'ML',
    QA: 'QA',
    JAVA: 'JAVA',
    PHP: 'PHP'
  };

  export type AutoCalibrationScalarFieldEnum = (typeof AutoCalibrationScalarFieldEnum)[keyof typeof AutoCalibrationScalarFieldEnum]


  export const DevelopmentExperienceScalarFieldEnum: {
    developmentExperienceId: 'developmentExperienceId',
    specId: 'specId',
    startDate: 'startDate',
    duration: 'duration',
    assignedTask: 'assignedTask',
    teamSize: 'teamSize',
    totalProjectHeadcount: 'totalProjectHeadcount',
    projectName: 'projectName',
    jobDuties: 'jobDuties',
    img: 'img',
    autoCalibrationId: 'autoCalibrationId'
  };

  export type DevelopmentExperienceScalarFieldEnum = (typeof DevelopmentExperienceScalarFieldEnum)[keyof typeof DevelopmentExperienceScalarFieldEnum]


  export const PortfolioScalarFieldEnum: {
    portfolioId: 'portfolioId',
    specId: 'specId',
    heading: 'heading',
    url: 'url'
  };

  export type PortfolioScalarFieldEnum = (typeof PortfolioScalarFieldEnum)[keyof typeof PortfolioScalarFieldEnum]


  export const PreviousWorkScalarFieldEnum: {
    previousWorkId: 'previousWorkId',
    specId: 'specId',
    industry: 'industry',
    occupation: 'occupation',
    JobDuties: 'JobDuties'
  };

  export type PreviousWorkScalarFieldEnum = (typeof PreviousWorkScalarFieldEnum)[keyof typeof PreviousWorkScalarFieldEnum]


  export const QualificationScalarFieldEnum: {
    qualificationId: 'qualificationId',
    specId: 'specId',
    credential: 'credential',
    acquisitionDate: 'acquisitionDate'
  };

  export type QualificationScalarFieldEnum = (typeof QualificationScalarFieldEnum)[keyof typeof QualificationScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RequestScalarFieldEnum: {
    applicationId: 'applicationId',
    userId: 'userId',
    status: 'status',
    adminComment: 'adminComment',
    engineerComment: 'engineerComment',
    adminId: 'adminId',
    createdAt: 'createdAt',
    resultedAt: 'resultedAt'
  };

  export type RequestScalarFieldEnum = (typeof RequestScalarFieldEnum)[keyof typeof RequestScalarFieldEnum]


  export const SellingPointScalarFieldEnum: {
    sellingPointId: 'sellingPointId',
    specId: 'specId',
    title: 'title',
    content: 'content'
  };

  export type SellingPointScalarFieldEnum = (typeof SellingPointScalarFieldEnum)[keyof typeof SellingPointScalarFieldEnum]


  export const SkillPointScalarFieldEnum: {
    skillPointId: 'skillPointId',
    userId: 'userId',
    FR: 'FR',
    BK: 'BK',
    DB: 'DB',
    SBR: 'SBR',
    AR: 'AR',
    TS: 'TS',
    COM: 'COM'
  };

  export type SkillPointScalarFieldEnum = (typeof SkillPointScalarFieldEnum)[keyof typeof SkillPointScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    skillId: 'skillId',
    userId: 'userId',
    InherentName: 'InherentName',
    InherentDescription: 'InherentDescription',
    numericalNumber: 'numericalNumber',
    numericalExplain: 'numericalExplain',
    updatedAt: 'updatedAt'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const SkillSummaryScalarFieldEnum: {
    skillSummaryId: 'skillSummaryId',
    specId: 'specId',
    autoCalibrationId: 'autoCalibrationId'
  };

  export type SkillSummaryScalarFieldEnum = (typeof SkillSummaryScalarFieldEnum)[keyof typeof SkillSummaryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SpaecialAbilityScalarFieldEnum: {
    spaecialAbilityId: 'spaecialAbilityId',
    userId: 'userId',
    skillList: 'skillList',
    skillSelection: 'skillSelection'
  };

  export type SpaecialAbilityScalarFieldEnum = (typeof SpaecialAbilityScalarFieldEnum)[keyof typeof SpaecialAbilityScalarFieldEnum]


  export const SpecScalarFieldEnum: {
    specId: 'specId',
    userId: 'userId',
    github: 'github',
    offHours: 'offHours',
    createdAt: 'createdAt'
  };

  export type SpecScalarFieldEnum = (typeof SpecScalarFieldEnum)[keyof typeof SpecScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    userId: 'userId',
    email: 'email',
    employeeNumber: 'employeeNumber',
    joinDate: 'joinDate',
    userName: 'userName',
    affiliation: 'affiliation',
    businessSituation: 'businessSituation',
    password: 'password',
    confirmPassword: 'confirmPassword',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: Enumerable<userWhereInput>
    OR?: Enumerable<userWhereInput>
    NOT?: Enumerable<userWhereInput>
    userId?: IntFilter | number
    email?: StringFilter | string
    employeeNumber?: IntFilter | number
    joinDate?: StringFilter | string
    userName?: StringFilter | string
    affiliation?: StringFilter | string
    businessSituation?: StringFilter | string
    password?: StringFilter | string
    confirmPassword?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    skills?: SkillListRelationFilter
    skillPoints?: SkillPointListRelationFilter
    specialAbilities?: SpaecialAbilityListRelationFilter
    specs?: SpecListRelationFilter
    requests?: RequestListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    userId?: SortOrder
    email?: SortOrder
    employeeNumber?: SortOrder
    joinDate?: SortOrder
    userName?: SortOrder
    affiliation?: SortOrder
    businessSituation?: SortOrder
    password?: SortOrder
    confirmPassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    skills?: skillOrderByRelationAggregateInput
    skillPoints?: skillPointOrderByRelationAggregateInput
    specialAbilities?: spaecialAbilityOrderByRelationAggregateInput
    specs?: specOrderByRelationAggregateInput
    requests?: requestOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = {
    userId?: number
    email?: string
  }

  export type userOrderByWithAggregationInput = {
    userId?: SortOrder
    email?: SortOrder
    employeeNumber?: SortOrder
    joinDate?: SortOrder
    userName?: SortOrder
    affiliation?: SortOrder
    businessSituation?: SortOrder
    password?: SortOrder
    confirmPassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userScalarWhereWithAggregatesInput>
    OR?: Enumerable<userScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    employeeNumber?: IntWithAggregatesFilter | number
    joinDate?: StringWithAggregatesFilter | string
    userName?: StringWithAggregatesFilter | string
    affiliation?: StringWithAggregatesFilter | string
    businessSituation?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    confirmPassword?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type skillWhereInput = {
    AND?: Enumerable<skillWhereInput>
    OR?: Enumerable<skillWhereInput>
    NOT?: Enumerable<skillWhereInput>
    skillId?: IntFilter | number
    userId?: IntFilter | number
    InherentName?: StringFilter | string
    InherentDescription?: StringFilter | string
    numericalNumber?: IntFilter | number
    numericalExplain?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type skillOrderByWithRelationInput = {
    skillId?: SortOrder
    userId?: SortOrder
    InherentName?: SortOrder
    InherentDescription?: SortOrder
    numericalNumber?: SortOrder
    numericalExplain?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type skillWhereUniqueInput = {
    skillId?: number
  }

  export type skillOrderByWithAggregationInput = {
    skillId?: SortOrder
    userId?: SortOrder
    InherentName?: SortOrder
    InherentDescription?: SortOrder
    numericalNumber?: SortOrder
    numericalExplain?: SortOrder
    updatedAt?: SortOrder
    _count?: skillCountOrderByAggregateInput
    _avg?: skillAvgOrderByAggregateInput
    _max?: skillMaxOrderByAggregateInput
    _min?: skillMinOrderByAggregateInput
    _sum?: skillSumOrderByAggregateInput
  }

  export type skillScalarWhereWithAggregatesInput = {
    AND?: Enumerable<skillScalarWhereWithAggregatesInput>
    OR?: Enumerable<skillScalarWhereWithAggregatesInput>
    NOT?: Enumerable<skillScalarWhereWithAggregatesInput>
    skillId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    InherentName?: StringWithAggregatesFilter | string
    InherentDescription?: StringWithAggregatesFilter | string
    numericalNumber?: IntWithAggregatesFilter | number
    numericalExplain?: StringWithAggregatesFilter | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type skillPointWhereInput = {
    AND?: Enumerable<skillPointWhereInput>
    OR?: Enumerable<skillPointWhereInput>
    NOT?: Enumerable<skillPointWhereInput>
    skillPointId?: IntFilter | number
    userId?: IntFilter | number
    FR?: IntFilter | number
    BK?: IntFilter | number
    DB?: IntFilter | number
    SBR?: IntFilter | number
    AR?: IntFilter | number
    TS?: IntFilter | number
    COM?: IntFilter | number
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type skillPointOrderByWithRelationInput = {
    skillPointId?: SortOrder
    userId?: SortOrder
    FR?: SortOrder
    BK?: SortOrder
    DB?: SortOrder
    SBR?: SortOrder
    AR?: SortOrder
    TS?: SortOrder
    COM?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type skillPointWhereUniqueInput = {
    skillPointId?: number
  }

  export type skillPointOrderByWithAggregationInput = {
    skillPointId?: SortOrder
    userId?: SortOrder
    FR?: SortOrder
    BK?: SortOrder
    DB?: SortOrder
    SBR?: SortOrder
    AR?: SortOrder
    TS?: SortOrder
    COM?: SortOrder
    _count?: skillPointCountOrderByAggregateInput
    _avg?: skillPointAvgOrderByAggregateInput
    _max?: skillPointMaxOrderByAggregateInput
    _min?: skillPointMinOrderByAggregateInput
    _sum?: skillPointSumOrderByAggregateInput
  }

  export type skillPointScalarWhereWithAggregatesInput = {
    AND?: Enumerable<skillPointScalarWhereWithAggregatesInput>
    OR?: Enumerable<skillPointScalarWhereWithAggregatesInput>
    NOT?: Enumerable<skillPointScalarWhereWithAggregatesInput>
    skillPointId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    FR?: IntWithAggregatesFilter | number
    BK?: IntWithAggregatesFilter | number
    DB?: IntWithAggregatesFilter | number
    SBR?: IntWithAggregatesFilter | number
    AR?: IntWithAggregatesFilter | number
    TS?: IntWithAggregatesFilter | number
    COM?: IntWithAggregatesFilter | number
  }

  export type spaecialAbilityWhereInput = {
    AND?: Enumerable<spaecialAbilityWhereInput>
    OR?: Enumerable<spaecialAbilityWhereInput>
    NOT?: Enumerable<spaecialAbilityWhereInput>
    spaecialAbilityId?: IntFilter | number
    userId?: IntFilter | number
    skillList?: StringFilter | string
    skillSelection?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type spaecialAbilityOrderByWithRelationInput = {
    spaecialAbilityId?: SortOrder
    userId?: SortOrder
    skillList?: SortOrder
    skillSelection?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type spaecialAbilityWhereUniqueInput = {
    spaecialAbilityId?: number
  }

  export type spaecialAbilityOrderByWithAggregationInput = {
    spaecialAbilityId?: SortOrder
    userId?: SortOrder
    skillList?: SortOrder
    skillSelection?: SortOrder
    _count?: spaecialAbilityCountOrderByAggregateInput
    _avg?: spaecialAbilityAvgOrderByAggregateInput
    _max?: spaecialAbilityMaxOrderByAggregateInput
    _min?: spaecialAbilityMinOrderByAggregateInput
    _sum?: spaecialAbilitySumOrderByAggregateInput
  }

  export type spaecialAbilityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<spaecialAbilityScalarWhereWithAggregatesInput>
    OR?: Enumerable<spaecialAbilityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<spaecialAbilityScalarWhereWithAggregatesInput>
    spaecialAbilityId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    skillList?: StringWithAggregatesFilter | string
    skillSelection?: BoolWithAggregatesFilter | boolean
  }

  export type specWhereInput = {
    AND?: Enumerable<specWhereInput>
    OR?: Enumerable<specWhereInput>
    NOT?: Enumerable<specWhereInput>
    specId?: IntFilter | number
    userId?: IntFilter | number
    github?: StringFilter | string
    offHours?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    portfolios?: PortfolioListRelationFilter
    skillSummaries?: SkillSummaryListRelationFilter
    sellingPoints?: SellingPointListRelationFilter
    qualifications?: QualificationListRelationFilter
    previousWorks?: PreviousWorkListRelationFilter
    developmentExperiences?: DevelopmentExperienceListRelationFilter
  }

  export type specOrderByWithRelationInput = {
    specId?: SortOrder
    userId?: SortOrder
    github?: SortOrder
    offHours?: SortOrder
    createdAt?: SortOrder
    user?: userOrderByWithRelationInput
    portfolios?: portfolioOrderByRelationAggregateInput
    skillSummaries?: skillSummaryOrderByRelationAggregateInput
    sellingPoints?: sellingPointOrderByRelationAggregateInput
    qualifications?: qualificationOrderByRelationAggregateInput
    previousWorks?: previousWorkOrderByRelationAggregateInput
    developmentExperiences?: developmentExperienceOrderByRelationAggregateInput
  }

  export type specWhereUniqueInput = {
    specId?: number
  }

  export type specOrderByWithAggregationInput = {
    specId?: SortOrder
    userId?: SortOrder
    github?: SortOrder
    offHours?: SortOrder
    createdAt?: SortOrder
    _count?: specCountOrderByAggregateInput
    _avg?: specAvgOrderByAggregateInput
    _max?: specMaxOrderByAggregateInput
    _min?: specMinOrderByAggregateInput
    _sum?: specSumOrderByAggregateInput
  }

  export type specScalarWhereWithAggregatesInput = {
    AND?: Enumerable<specScalarWhereWithAggregatesInput>
    OR?: Enumerable<specScalarWhereWithAggregatesInput>
    NOT?: Enumerable<specScalarWhereWithAggregatesInput>
    specId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    github?: StringWithAggregatesFilter | string
    offHours?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type portfolioWhereInput = {
    AND?: Enumerable<portfolioWhereInput>
    OR?: Enumerable<portfolioWhereInput>
    NOT?: Enumerable<portfolioWhereInput>
    portfolioId?: IntFilter | number
    specId?: IntFilter | number
    heading?: StringFilter | string
    url?: StringFilter | string
    spec?: XOR<SpecRelationFilter, specWhereInput>
  }

  export type portfolioOrderByWithRelationInput = {
    portfolioId?: SortOrder
    specId?: SortOrder
    heading?: SortOrder
    url?: SortOrder
    spec?: specOrderByWithRelationInput
  }

  export type portfolioWhereUniqueInput = {
    portfolioId?: number
  }

  export type portfolioOrderByWithAggregationInput = {
    portfolioId?: SortOrder
    specId?: SortOrder
    heading?: SortOrder
    url?: SortOrder
    _count?: portfolioCountOrderByAggregateInput
    _avg?: portfolioAvgOrderByAggregateInput
    _max?: portfolioMaxOrderByAggregateInput
    _min?: portfolioMinOrderByAggregateInput
    _sum?: portfolioSumOrderByAggregateInput
  }

  export type portfolioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<portfolioScalarWhereWithAggregatesInput>
    OR?: Enumerable<portfolioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<portfolioScalarWhereWithAggregatesInput>
    portfolioId?: IntWithAggregatesFilter | number
    specId?: IntWithAggregatesFilter | number
    heading?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
  }

  export type skillSummaryWhereInput = {
    AND?: Enumerable<skillSummaryWhereInput>
    OR?: Enumerable<skillSummaryWhereInput>
    NOT?: Enumerable<skillSummaryWhereInput>
    skillSummaryId?: IntFilter | number
    specId?: IntFilter | number
    autoCalibrationId?: IntFilter | number
    spec?: XOR<SpecRelationFilter, specWhereInput>
    autoCalibration?: XOR<AutoCalibrationRelationFilter, autoCalibrationWhereInput>
  }

  export type skillSummaryOrderByWithRelationInput = {
    skillSummaryId?: SortOrder
    specId?: SortOrder
    autoCalibrationId?: SortOrder
    spec?: specOrderByWithRelationInput
    autoCalibration?: autoCalibrationOrderByWithRelationInput
  }

  export type skillSummaryWhereUniqueInput = {
    skillSummaryId?: number
  }

  export type skillSummaryOrderByWithAggregationInput = {
    skillSummaryId?: SortOrder
    specId?: SortOrder
    autoCalibrationId?: SortOrder
    _count?: skillSummaryCountOrderByAggregateInput
    _avg?: skillSummaryAvgOrderByAggregateInput
    _max?: skillSummaryMaxOrderByAggregateInput
    _min?: skillSummaryMinOrderByAggregateInput
    _sum?: skillSummarySumOrderByAggregateInput
  }

  export type skillSummaryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<skillSummaryScalarWhereWithAggregatesInput>
    OR?: Enumerable<skillSummaryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<skillSummaryScalarWhereWithAggregatesInput>
    skillSummaryId?: IntWithAggregatesFilter | number
    specId?: IntWithAggregatesFilter | number
    autoCalibrationId?: IntWithAggregatesFilter | number
  }

  export type sellingPointWhereInput = {
    AND?: Enumerable<sellingPointWhereInput>
    OR?: Enumerable<sellingPointWhereInput>
    NOT?: Enumerable<sellingPointWhereInput>
    sellingPointId?: IntFilter | number
    specId?: IntFilter | number
    title?: StringFilter | string
    content?: StringFilter | string
    spec?: XOR<SpecRelationFilter, specWhereInput>
  }

  export type sellingPointOrderByWithRelationInput = {
    sellingPointId?: SortOrder
    specId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    spec?: specOrderByWithRelationInput
  }

  export type sellingPointWhereUniqueInput = {
    sellingPointId?: number
  }

  export type sellingPointOrderByWithAggregationInput = {
    sellingPointId?: SortOrder
    specId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    _count?: sellingPointCountOrderByAggregateInput
    _avg?: sellingPointAvgOrderByAggregateInput
    _max?: sellingPointMaxOrderByAggregateInput
    _min?: sellingPointMinOrderByAggregateInput
    _sum?: sellingPointSumOrderByAggregateInput
  }

  export type sellingPointScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sellingPointScalarWhereWithAggregatesInput>
    OR?: Enumerable<sellingPointScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sellingPointScalarWhereWithAggregatesInput>
    sellingPointId?: IntWithAggregatesFilter | number
    specId?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
  }

  export type qualificationWhereInput = {
    AND?: Enumerable<qualificationWhereInput>
    OR?: Enumerable<qualificationWhereInput>
    NOT?: Enumerable<qualificationWhereInput>
    qualificationId?: IntFilter | number
    specId?: IntFilter | number
    credential?: StringFilter | string
    acquisitionDate?: StringFilter | string
    spec?: XOR<SpecRelationFilter, specWhereInput>
  }

  export type qualificationOrderByWithRelationInput = {
    qualificationId?: SortOrder
    specId?: SortOrder
    credential?: SortOrder
    acquisitionDate?: SortOrder
    spec?: specOrderByWithRelationInput
  }

  export type qualificationWhereUniqueInput = {
    qualificationId?: number
  }

  export type qualificationOrderByWithAggregationInput = {
    qualificationId?: SortOrder
    specId?: SortOrder
    credential?: SortOrder
    acquisitionDate?: SortOrder
    _count?: qualificationCountOrderByAggregateInput
    _avg?: qualificationAvgOrderByAggregateInput
    _max?: qualificationMaxOrderByAggregateInput
    _min?: qualificationMinOrderByAggregateInput
    _sum?: qualificationSumOrderByAggregateInput
  }

  export type qualificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<qualificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<qualificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<qualificationScalarWhereWithAggregatesInput>
    qualificationId?: IntWithAggregatesFilter | number
    specId?: IntWithAggregatesFilter | number
    credential?: StringWithAggregatesFilter | string
    acquisitionDate?: StringWithAggregatesFilter | string
  }

  export type previousWorkWhereInput = {
    AND?: Enumerable<previousWorkWhereInput>
    OR?: Enumerable<previousWorkWhereInput>
    NOT?: Enumerable<previousWorkWhereInput>
    previousWorkId?: IntFilter | number
    specId?: IntFilter | number
    industry?: StringFilter | string
    occupation?: StringFilter | string
    JobDuties?: StringFilter | string
    spec?: XOR<SpecRelationFilter, specWhereInput>
  }

  export type previousWorkOrderByWithRelationInput = {
    previousWorkId?: SortOrder
    specId?: SortOrder
    industry?: SortOrder
    occupation?: SortOrder
    JobDuties?: SortOrder
    spec?: specOrderByWithRelationInput
  }

  export type previousWorkWhereUniqueInput = {
    previousWorkId?: number
  }

  export type previousWorkOrderByWithAggregationInput = {
    previousWorkId?: SortOrder
    specId?: SortOrder
    industry?: SortOrder
    occupation?: SortOrder
    JobDuties?: SortOrder
    _count?: previousWorkCountOrderByAggregateInput
    _avg?: previousWorkAvgOrderByAggregateInput
    _max?: previousWorkMaxOrderByAggregateInput
    _min?: previousWorkMinOrderByAggregateInput
    _sum?: previousWorkSumOrderByAggregateInput
  }

  export type previousWorkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<previousWorkScalarWhereWithAggregatesInput>
    OR?: Enumerable<previousWorkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<previousWorkScalarWhereWithAggregatesInput>
    previousWorkId?: IntWithAggregatesFilter | number
    specId?: IntWithAggregatesFilter | number
    industry?: StringWithAggregatesFilter | string
    occupation?: StringWithAggregatesFilter | string
    JobDuties?: StringWithAggregatesFilter | string
  }

  export type developmentExperienceWhereInput = {
    AND?: Enumerable<developmentExperienceWhereInput>
    OR?: Enumerable<developmentExperienceWhereInput>
    NOT?: Enumerable<developmentExperienceWhereInput>
    developmentExperienceId?: IntFilter | number
    specId?: IntFilter | number
    startDate?: StringFilter | string
    duration?: StringFilter | string
    assignedTask?: StringFilter | string
    teamSize?: StringFilter | string
    totalProjectHeadcount?: StringFilter | string
    projectName?: StringFilter | string
    jobDuties?: StringFilter | string
    img?: StringFilter | string
    autoCalibrationId?: IntFilter | number
    spec?: XOR<SpecRelationFilter, specWhereInput>
    autoCalibration?: XOR<AutoCalibrationRelationFilter, autoCalibrationWhereInput>
  }

  export type developmentExperienceOrderByWithRelationInput = {
    developmentExperienceId?: SortOrder
    specId?: SortOrder
    startDate?: SortOrder
    duration?: SortOrder
    assignedTask?: SortOrder
    teamSize?: SortOrder
    totalProjectHeadcount?: SortOrder
    projectName?: SortOrder
    jobDuties?: SortOrder
    img?: SortOrder
    autoCalibrationId?: SortOrder
    spec?: specOrderByWithRelationInput
    autoCalibration?: autoCalibrationOrderByWithRelationInput
  }

  export type developmentExperienceWhereUniqueInput = {
    developmentExperienceId?: number
  }

  export type developmentExperienceOrderByWithAggregationInput = {
    developmentExperienceId?: SortOrder
    specId?: SortOrder
    startDate?: SortOrder
    duration?: SortOrder
    assignedTask?: SortOrder
    teamSize?: SortOrder
    totalProjectHeadcount?: SortOrder
    projectName?: SortOrder
    jobDuties?: SortOrder
    img?: SortOrder
    autoCalibrationId?: SortOrder
    _count?: developmentExperienceCountOrderByAggregateInput
    _avg?: developmentExperienceAvgOrderByAggregateInput
    _max?: developmentExperienceMaxOrderByAggregateInput
    _min?: developmentExperienceMinOrderByAggregateInput
    _sum?: developmentExperienceSumOrderByAggregateInput
  }

  export type developmentExperienceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<developmentExperienceScalarWhereWithAggregatesInput>
    OR?: Enumerable<developmentExperienceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<developmentExperienceScalarWhereWithAggregatesInput>
    developmentExperienceId?: IntWithAggregatesFilter | number
    specId?: IntWithAggregatesFilter | number
    startDate?: StringWithAggregatesFilter | string
    duration?: StringWithAggregatesFilter | string
    assignedTask?: StringWithAggregatesFilter | string
    teamSize?: StringWithAggregatesFilter | string
    totalProjectHeadcount?: StringWithAggregatesFilter | string
    projectName?: StringWithAggregatesFilter | string
    jobDuties?: StringWithAggregatesFilter | string
    img?: StringWithAggregatesFilter | string
    autoCalibrationId?: IntWithAggregatesFilter | number
  }

  export type autoCalibrationWhereInput = {
    AND?: Enumerable<autoCalibrationWhereInput>
    OR?: Enumerable<autoCalibrationWhereInput>
    NOT?: Enumerable<autoCalibrationWhereInput>
    autoCalibrationId?: IntFilter | number
    skill?: StringFilter | string
    membership?: IntFilter | number
    category?: IntFilter | number
    FR?: IntFilter | number
    CL?: IntFilter | number
    ML?: IntFilter | number
    QA?: IntFilter | number
    JAVA?: IntFilter | number
    PHP?: IntFilter | number
    skillSummaries?: SkillSummaryListRelationFilter
    developmentExperiences?: DevelopmentExperienceListRelationFilter
  }

  export type autoCalibrationOrderByWithRelationInput = {
    autoCalibrationId?: SortOrder
    skill?: SortOrder
    membership?: SortOrder
    category?: SortOrder
    FR?: SortOrder
    CL?: SortOrder
    ML?: SortOrder
    QA?: SortOrder
    JAVA?: SortOrder
    PHP?: SortOrder
    skillSummaries?: skillSummaryOrderByRelationAggregateInput
    developmentExperiences?: developmentExperienceOrderByRelationAggregateInput
  }

  export type autoCalibrationWhereUniqueInput = {
    autoCalibrationId?: number
  }

  export type autoCalibrationOrderByWithAggregationInput = {
    autoCalibrationId?: SortOrder
    skill?: SortOrder
    membership?: SortOrder
    category?: SortOrder
    FR?: SortOrder
    CL?: SortOrder
    ML?: SortOrder
    QA?: SortOrder
    JAVA?: SortOrder
    PHP?: SortOrder
    _count?: autoCalibrationCountOrderByAggregateInput
    _avg?: autoCalibrationAvgOrderByAggregateInput
    _max?: autoCalibrationMaxOrderByAggregateInput
    _min?: autoCalibrationMinOrderByAggregateInput
    _sum?: autoCalibrationSumOrderByAggregateInput
  }

  export type autoCalibrationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<autoCalibrationScalarWhereWithAggregatesInput>
    OR?: Enumerable<autoCalibrationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<autoCalibrationScalarWhereWithAggregatesInput>
    autoCalibrationId?: IntWithAggregatesFilter | number
    skill?: StringWithAggregatesFilter | string
    membership?: IntWithAggregatesFilter | number
    category?: IntWithAggregatesFilter | number
    FR?: IntWithAggregatesFilter | number
    CL?: IntWithAggregatesFilter | number
    ML?: IntWithAggregatesFilter | number
    QA?: IntWithAggregatesFilter | number
    JAVA?: IntWithAggregatesFilter | number
    PHP?: IntWithAggregatesFilter | number
  }

  export type requestWhereInput = {
    AND?: Enumerable<requestWhereInput>
    OR?: Enumerable<requestWhereInput>
    NOT?: Enumerable<requestWhereInput>
    applicationId?: IntFilter | number
    userId?: IntFilter | number
    status?: IntFilter | number
    adminComment?: StringFilter | string
    engineerComment?: StringFilter | string
    adminId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    resultedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
    admin?: XOR<AdminRelationFilter, adminWhereInput>
  }

  export type requestOrderByWithRelationInput = {
    applicationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    adminComment?: SortOrder
    engineerComment?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    resultedAt?: SortOrder
    user?: userOrderByWithRelationInput
    admin?: adminOrderByWithRelationInput
  }

  export type requestWhereUniqueInput = {
    applicationId?: number
  }

  export type requestOrderByWithAggregationInput = {
    applicationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    adminComment?: SortOrder
    engineerComment?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    resultedAt?: SortOrder
    _count?: requestCountOrderByAggregateInput
    _avg?: requestAvgOrderByAggregateInput
    _max?: requestMaxOrderByAggregateInput
    _min?: requestMinOrderByAggregateInput
    _sum?: requestSumOrderByAggregateInput
  }

  export type requestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<requestScalarWhereWithAggregatesInput>
    OR?: Enumerable<requestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<requestScalarWhereWithAggregatesInput>
    applicationId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    status?: IntWithAggregatesFilter | number
    adminComment?: StringWithAggregatesFilter | string
    engineerComment?: StringWithAggregatesFilter | string
    adminId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    resultedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type adminWhereInput = {
    AND?: Enumerable<adminWhereInput>
    OR?: Enumerable<adminWhereInput>
    NOT?: Enumerable<adminWhereInput>
    adminId?: IntFilter | number
    email?: StringFilter | string
    password?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    requests?: RequestListRelationFilter
  }

  export type adminOrderByWithRelationInput = {
    adminId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    requests?: requestOrderByRelationAggregateInput
  }

  export type adminWhereUniqueInput = {
    adminId?: number
    email?: string
  }

  export type adminOrderByWithAggregationInput = {
    adminId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: Enumerable<adminScalarWhereWithAggregatesInput>
    OR?: Enumerable<adminScalarWhereWithAggregatesInput>
    NOT?: Enumerable<adminScalarWhereWithAggregatesInput>
    adminId?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type userCreateInput = {
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skills?: skillCreateNestedManyWithoutUserInput
    skillPoints?: skillPointCreateNestedManyWithoutUserInput
    specialAbilities?: spaecialAbilityCreateNestedManyWithoutUserInput
    specs?: specCreateNestedManyWithoutUserInput
    requests?: requestCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    userId?: number
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skills?: skillUncheckedCreateNestedManyWithoutUserInput
    skillPoints?: skillPointUncheckedCreateNestedManyWithoutUserInput
    specialAbilities?: spaecialAbilityUncheckedCreateNestedManyWithoutUserInput
    specs?: specUncheckedCreateNestedManyWithoutUserInput
    requests?: requestUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: skillUpdateManyWithoutUserNestedInput
    skillPoints?: skillPointUpdateManyWithoutUserNestedInput
    specialAbilities?: spaecialAbilityUpdateManyWithoutUserNestedInput
    specs?: specUpdateManyWithoutUserNestedInput
    requests?: requestUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: skillUncheckedUpdateManyWithoutUserNestedInput
    skillPoints?: skillPointUncheckedUpdateManyWithoutUserNestedInput
    specialAbilities?: spaecialAbilityUncheckedUpdateManyWithoutUserNestedInput
    specs?: specUncheckedUpdateManyWithoutUserNestedInput
    requests?: requestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    userId?: number
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type skillCreateInput = {
    InherentName: string
    InherentDescription: string
    numericalNumber: number
    numericalExplain: string
    updatedAt: Date | string
    user: userCreateNestedOneWithoutSkillsInput
  }

  export type skillUncheckedCreateInput = {
    skillId?: number
    userId: number
    InherentName: string
    InherentDescription: string
    numericalNumber: number
    numericalExplain: string
    updatedAt: Date | string
  }

  export type skillUpdateInput = {
    InherentName?: StringFieldUpdateOperationsInput | string
    InherentDescription?: StringFieldUpdateOperationsInput | string
    numericalNumber?: IntFieldUpdateOperationsInput | number
    numericalExplain?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type skillUncheckedUpdateInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    InherentName?: StringFieldUpdateOperationsInput | string
    InherentDescription?: StringFieldUpdateOperationsInput | string
    numericalNumber?: IntFieldUpdateOperationsInput | number
    numericalExplain?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type skillCreateManyInput = {
    skillId?: number
    userId: number
    InherentName: string
    InherentDescription: string
    numericalNumber: number
    numericalExplain: string
    updatedAt: Date | string
  }

  export type skillUpdateManyMutationInput = {
    InherentName?: StringFieldUpdateOperationsInput | string
    InherentDescription?: StringFieldUpdateOperationsInput | string
    numericalNumber?: IntFieldUpdateOperationsInput | number
    numericalExplain?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type skillUncheckedUpdateManyInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    InherentName?: StringFieldUpdateOperationsInput | string
    InherentDescription?: StringFieldUpdateOperationsInput | string
    numericalNumber?: IntFieldUpdateOperationsInput | number
    numericalExplain?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type skillPointCreateInput = {
    FR: number
    BK: number
    DB: number
    SBR: number
    AR: number
    TS: number
    COM: number
    user: userCreateNestedOneWithoutSkillPointsInput
  }

  export type skillPointUncheckedCreateInput = {
    skillPointId?: number
    userId: number
    FR: number
    BK: number
    DB: number
    SBR: number
    AR: number
    TS: number
    COM: number
  }

  export type skillPointUpdateInput = {
    FR?: IntFieldUpdateOperationsInput | number
    BK?: IntFieldUpdateOperationsInput | number
    DB?: IntFieldUpdateOperationsInput | number
    SBR?: IntFieldUpdateOperationsInput | number
    AR?: IntFieldUpdateOperationsInput | number
    TS?: IntFieldUpdateOperationsInput | number
    COM?: IntFieldUpdateOperationsInput | number
    user?: userUpdateOneRequiredWithoutSkillPointsNestedInput
  }

  export type skillPointUncheckedUpdateInput = {
    skillPointId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    BK?: IntFieldUpdateOperationsInput | number
    DB?: IntFieldUpdateOperationsInput | number
    SBR?: IntFieldUpdateOperationsInput | number
    AR?: IntFieldUpdateOperationsInput | number
    TS?: IntFieldUpdateOperationsInput | number
    COM?: IntFieldUpdateOperationsInput | number
  }

  export type skillPointCreateManyInput = {
    skillPointId?: number
    userId: number
    FR: number
    BK: number
    DB: number
    SBR: number
    AR: number
    TS: number
    COM: number
  }

  export type skillPointUpdateManyMutationInput = {
    FR?: IntFieldUpdateOperationsInput | number
    BK?: IntFieldUpdateOperationsInput | number
    DB?: IntFieldUpdateOperationsInput | number
    SBR?: IntFieldUpdateOperationsInput | number
    AR?: IntFieldUpdateOperationsInput | number
    TS?: IntFieldUpdateOperationsInput | number
    COM?: IntFieldUpdateOperationsInput | number
  }

  export type skillPointUncheckedUpdateManyInput = {
    skillPointId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    BK?: IntFieldUpdateOperationsInput | number
    DB?: IntFieldUpdateOperationsInput | number
    SBR?: IntFieldUpdateOperationsInput | number
    AR?: IntFieldUpdateOperationsInput | number
    TS?: IntFieldUpdateOperationsInput | number
    COM?: IntFieldUpdateOperationsInput | number
  }

  export type spaecialAbilityCreateInput = {
    skillList: string
    skillSelection: boolean
    user: userCreateNestedOneWithoutSpecialAbilitiesInput
  }

  export type spaecialAbilityUncheckedCreateInput = {
    spaecialAbilityId?: number
    userId: number
    skillList: string
    skillSelection: boolean
  }

  export type spaecialAbilityUpdateInput = {
    skillList?: StringFieldUpdateOperationsInput | string
    skillSelection?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateOneRequiredWithoutSpecialAbilitiesNestedInput
  }

  export type spaecialAbilityUncheckedUpdateInput = {
    spaecialAbilityId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    skillList?: StringFieldUpdateOperationsInput | string
    skillSelection?: BoolFieldUpdateOperationsInput | boolean
  }

  export type spaecialAbilityCreateManyInput = {
    spaecialAbilityId?: number
    userId: number
    skillList: string
    skillSelection: boolean
  }

  export type spaecialAbilityUpdateManyMutationInput = {
    skillList?: StringFieldUpdateOperationsInput | string
    skillSelection?: BoolFieldUpdateOperationsInput | boolean
  }

  export type spaecialAbilityUncheckedUpdateManyInput = {
    spaecialAbilityId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    skillList?: StringFieldUpdateOperationsInput | string
    skillSelection?: BoolFieldUpdateOperationsInput | boolean
  }

  export type specCreateInput = {
    github: string
    offHours: string
    createdAt: Date | string
    user: userCreateNestedOneWithoutSpecsInput
    portfolios?: portfolioCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointCreateNestedManyWithoutSpecInput
    qualifications?: qualificationCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceCreateNestedManyWithoutSpecInput
  }

  export type specUncheckedCreateInput = {
    specId?: number
    userId: number
    github: string
    offHours: string
    createdAt: Date | string
    portfolios?: portfolioUncheckedCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryUncheckedCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointUncheckedCreateNestedManyWithoutSpecInput
    qualifications?: qualificationUncheckedCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkUncheckedCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceUncheckedCreateNestedManyWithoutSpecInput
  }

  export type specUpdateInput = {
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutSpecsNestedInput
    portfolios?: portfolioUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUpdateManyWithoutSpecNestedInput
  }

  export type specUncheckedUpdateInput = {
    specId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolios?: portfolioUncheckedUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUncheckedUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUncheckedUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUncheckedUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUncheckedUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type specCreateManyInput = {
    specId?: number
    userId: number
    github: string
    offHours: string
    createdAt: Date | string
  }

  export type specUpdateManyMutationInput = {
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type specUncheckedUpdateManyInput = {
    specId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type portfolioCreateInput = {
    heading: string
    url: string
    spec: specCreateNestedOneWithoutPortfoliosInput
  }

  export type portfolioUncheckedCreateInput = {
    portfolioId?: number
    specId: number
    heading: string
    url: string
  }

  export type portfolioUpdateInput = {
    heading?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    spec?: specUpdateOneRequiredWithoutPortfoliosNestedInput
  }

  export type portfolioUncheckedUpdateInput = {
    portfolioId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    heading?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type portfolioCreateManyInput = {
    portfolioId?: number
    specId: number
    heading: string
    url: string
  }

  export type portfolioUpdateManyMutationInput = {
    heading?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type portfolioUncheckedUpdateManyInput = {
    portfolioId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    heading?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type skillSummaryCreateInput = {
    spec: specCreateNestedOneWithoutSkillSummariesInput
    autoCalibration: autoCalibrationCreateNestedOneWithoutSkillSummariesInput
  }

  export type skillSummaryUncheckedCreateInput = {
    skillSummaryId?: number
    specId: number
    autoCalibrationId: number
  }

  export type skillSummaryUpdateInput = {
    spec?: specUpdateOneRequiredWithoutSkillSummariesNestedInput
    autoCalibration?: autoCalibrationUpdateOneRequiredWithoutSkillSummariesNestedInput
  }

  export type skillSummaryUncheckedUpdateInput = {
    skillSummaryId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
  }

  export type skillSummaryCreateManyInput = {
    skillSummaryId?: number
    specId: number
    autoCalibrationId: number
  }

  export type skillSummaryUpdateManyMutationInput = {

  }

  export type skillSummaryUncheckedUpdateManyInput = {
    skillSummaryId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
  }

  export type sellingPointCreateInput = {
    title: string
    content: string
    spec: specCreateNestedOneWithoutSellingPointsInput
  }

  export type sellingPointUncheckedCreateInput = {
    sellingPointId?: number
    specId: number
    title: string
    content: string
  }

  export type sellingPointUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    spec?: specUpdateOneRequiredWithoutSellingPointsNestedInput
  }

  export type sellingPointUncheckedUpdateInput = {
    sellingPointId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type sellingPointCreateManyInput = {
    sellingPointId?: number
    specId: number
    title: string
    content: string
  }

  export type sellingPointUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type sellingPointUncheckedUpdateManyInput = {
    sellingPointId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type qualificationCreateInput = {
    credential: string
    acquisitionDate: string
    spec: specCreateNestedOneWithoutQualificationsInput
  }

  export type qualificationUncheckedCreateInput = {
    qualificationId?: number
    specId: number
    credential: string
    acquisitionDate: string
  }

  export type qualificationUpdateInput = {
    credential?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: StringFieldUpdateOperationsInput | string
    spec?: specUpdateOneRequiredWithoutQualificationsNestedInput
  }

  export type qualificationUncheckedUpdateInput = {
    qualificationId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    credential?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: StringFieldUpdateOperationsInput | string
  }

  export type qualificationCreateManyInput = {
    qualificationId?: number
    specId: number
    credential: string
    acquisitionDate: string
  }

  export type qualificationUpdateManyMutationInput = {
    credential?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: StringFieldUpdateOperationsInput | string
  }

  export type qualificationUncheckedUpdateManyInput = {
    qualificationId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    credential?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: StringFieldUpdateOperationsInput | string
  }

  export type previousWorkCreateInput = {
    industry: string
    occupation: string
    JobDuties: string
    spec: specCreateNestedOneWithoutPreviousWorksInput
  }

  export type previousWorkUncheckedCreateInput = {
    previousWorkId?: number
    specId: number
    industry: string
    occupation: string
    JobDuties: string
  }

  export type previousWorkUpdateInput = {
    industry?: StringFieldUpdateOperationsInput | string
    occupation?: StringFieldUpdateOperationsInput | string
    JobDuties?: StringFieldUpdateOperationsInput | string
    spec?: specUpdateOneRequiredWithoutPreviousWorksNestedInput
  }

  export type previousWorkUncheckedUpdateInput = {
    previousWorkId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    industry?: StringFieldUpdateOperationsInput | string
    occupation?: StringFieldUpdateOperationsInput | string
    JobDuties?: StringFieldUpdateOperationsInput | string
  }

  export type previousWorkCreateManyInput = {
    previousWorkId?: number
    specId: number
    industry: string
    occupation: string
    JobDuties: string
  }

  export type previousWorkUpdateManyMutationInput = {
    industry?: StringFieldUpdateOperationsInput | string
    occupation?: StringFieldUpdateOperationsInput | string
    JobDuties?: StringFieldUpdateOperationsInput | string
  }

  export type previousWorkUncheckedUpdateManyInput = {
    previousWorkId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    industry?: StringFieldUpdateOperationsInput | string
    occupation?: StringFieldUpdateOperationsInput | string
    JobDuties?: StringFieldUpdateOperationsInput | string
  }

  export type developmentExperienceCreateInput = {
    startDate: string
    duration: string
    assignedTask: string
    teamSize: string
    totalProjectHeadcount: string
    projectName: string
    jobDuties: string
    img: string
    spec: specCreateNestedOneWithoutDevelopmentExperiencesInput
    autoCalibration: autoCalibrationCreateNestedOneWithoutDevelopmentExperiencesInput
  }

  export type developmentExperienceUncheckedCreateInput = {
    developmentExperienceId?: number
    specId: number
    startDate: string
    duration: string
    assignedTask: string
    teamSize: string
    totalProjectHeadcount: string
    projectName: string
    jobDuties: string
    img: string
    autoCalibrationId: number
  }

  export type developmentExperienceUpdateInput = {
    startDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    assignedTask?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    totalProjectHeadcount?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jobDuties?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    spec?: specUpdateOneRequiredWithoutDevelopmentExperiencesNestedInput
    autoCalibration?: autoCalibrationUpdateOneRequiredWithoutDevelopmentExperiencesNestedInput
  }

  export type developmentExperienceUncheckedUpdateInput = {
    developmentExperienceId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    assignedTask?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    totalProjectHeadcount?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jobDuties?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
  }

  export type developmentExperienceCreateManyInput = {
    developmentExperienceId?: number
    specId: number
    startDate: string
    duration: string
    assignedTask: string
    teamSize: string
    totalProjectHeadcount: string
    projectName: string
    jobDuties: string
    img: string
    autoCalibrationId: number
  }

  export type developmentExperienceUpdateManyMutationInput = {
    startDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    assignedTask?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    totalProjectHeadcount?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jobDuties?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
  }

  export type developmentExperienceUncheckedUpdateManyInput = {
    developmentExperienceId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    assignedTask?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    totalProjectHeadcount?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jobDuties?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
  }

  export type autoCalibrationCreateInput = {
    skill: string
    membership: number
    category: number
    FR: number
    CL: number
    ML: number
    QA: number
    JAVA: number
    PHP: number
    skillSummaries?: skillSummaryCreateNestedManyWithoutAutoCalibrationInput
    developmentExperiences?: developmentExperienceCreateNestedManyWithoutAutoCalibrationInput
  }

  export type autoCalibrationUncheckedCreateInput = {
    autoCalibrationId?: number
    skill: string
    membership: number
    category: number
    FR: number
    CL: number
    ML: number
    QA: number
    JAVA: number
    PHP: number
    skillSummaries?: skillSummaryUncheckedCreateNestedManyWithoutAutoCalibrationInput
    developmentExperiences?: developmentExperienceUncheckedCreateNestedManyWithoutAutoCalibrationInput
  }

  export type autoCalibrationUpdateInput = {
    skill?: StringFieldUpdateOperationsInput | string
    membership?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    CL?: IntFieldUpdateOperationsInput | number
    ML?: IntFieldUpdateOperationsInput | number
    QA?: IntFieldUpdateOperationsInput | number
    JAVA?: IntFieldUpdateOperationsInput | number
    PHP?: IntFieldUpdateOperationsInput | number
    skillSummaries?: skillSummaryUpdateManyWithoutAutoCalibrationNestedInput
    developmentExperiences?: developmentExperienceUpdateManyWithoutAutoCalibrationNestedInput
  }

  export type autoCalibrationUncheckedUpdateInput = {
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
    skill?: StringFieldUpdateOperationsInput | string
    membership?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    CL?: IntFieldUpdateOperationsInput | number
    ML?: IntFieldUpdateOperationsInput | number
    QA?: IntFieldUpdateOperationsInput | number
    JAVA?: IntFieldUpdateOperationsInput | number
    PHP?: IntFieldUpdateOperationsInput | number
    skillSummaries?: skillSummaryUncheckedUpdateManyWithoutAutoCalibrationNestedInput
    developmentExperiences?: developmentExperienceUncheckedUpdateManyWithoutAutoCalibrationNestedInput
  }

  export type autoCalibrationCreateManyInput = {
    autoCalibrationId?: number
    skill: string
    membership: number
    category: number
    FR: number
    CL: number
    ML: number
    QA: number
    JAVA: number
    PHP: number
  }

  export type autoCalibrationUpdateManyMutationInput = {
    skill?: StringFieldUpdateOperationsInput | string
    membership?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    CL?: IntFieldUpdateOperationsInput | number
    ML?: IntFieldUpdateOperationsInput | number
    QA?: IntFieldUpdateOperationsInput | number
    JAVA?: IntFieldUpdateOperationsInput | number
    PHP?: IntFieldUpdateOperationsInput | number
  }

  export type autoCalibrationUncheckedUpdateManyInput = {
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
    skill?: StringFieldUpdateOperationsInput | string
    membership?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    CL?: IntFieldUpdateOperationsInput | number
    ML?: IntFieldUpdateOperationsInput | number
    QA?: IntFieldUpdateOperationsInput | number
    JAVA?: IntFieldUpdateOperationsInput | number
    PHP?: IntFieldUpdateOperationsInput | number
  }

  export type requestCreateInput = {
    status: number
    adminComment: string
    engineerComment: string
    createdAt: Date | string
    resultedAt: Date | string
    user: userCreateNestedOneWithoutRequestsInput
    admin: adminCreateNestedOneWithoutRequestsInput
  }

  export type requestUncheckedCreateInput = {
    applicationId?: number
    userId: number
    status: number
    adminComment: string
    engineerComment: string
    adminId: number
    createdAt: Date | string
    resultedAt: Date | string
  }

  export type requestUpdateInput = {
    status?: IntFieldUpdateOperationsInput | number
    adminComment?: StringFieldUpdateOperationsInput | string
    engineerComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutRequestsNestedInput
    admin?: adminUpdateOneRequiredWithoutRequestsNestedInput
  }

  export type requestUncheckedUpdateInput = {
    applicationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    adminComment?: StringFieldUpdateOperationsInput | string
    engineerComment?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requestCreateManyInput = {
    applicationId?: number
    userId: number
    status: number
    adminComment: string
    engineerComment: string
    adminId: number
    createdAt: Date | string
    resultedAt: Date | string
  }

  export type requestUpdateManyMutationInput = {
    status?: IntFieldUpdateOperationsInput | number
    adminComment?: StringFieldUpdateOperationsInput | string
    engineerComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requestUncheckedUpdateManyInput = {
    applicationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    adminComment?: StringFieldUpdateOperationsInput | string
    engineerComment?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminCreateInput = {
    email: string
    password: string
    name: string
    createdAt: Date | string
    requests?: requestCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateInput = {
    adminId?: number
    email: string
    password: string
    name: string
    createdAt: Date | string
    requests?: requestUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: requestUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateInput = {
    adminId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: requestUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type adminCreateManyInput = {
    adminId?: number
    email: string
    password: string
    name: string
    createdAt: Date | string
  }

  export type adminUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminUncheckedUpdateManyInput = {
    adminId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type SkillListRelationFilter = {
    every?: skillWhereInput
    some?: skillWhereInput
    none?: skillWhereInput
  }

  export type SkillPointListRelationFilter = {
    every?: skillPointWhereInput
    some?: skillPointWhereInput
    none?: skillPointWhereInput
  }

  export type SpaecialAbilityListRelationFilter = {
    every?: spaecialAbilityWhereInput
    some?: spaecialAbilityWhereInput
    none?: spaecialAbilityWhereInput
  }

  export type SpecListRelationFilter = {
    every?: specWhereInput
    some?: specWhereInput
    none?: specWhereInput
  }

  export type RequestListRelationFilter = {
    every?: requestWhereInput
    some?: requestWhereInput
    none?: requestWhereInput
  }

  export type skillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type skillPointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type spaecialAbilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type specOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type requestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    userId?: SortOrder
    email?: SortOrder
    employeeNumber?: SortOrder
    joinDate?: SortOrder
    userName?: SortOrder
    affiliation?: SortOrder
    businessSituation?: SortOrder
    password?: SortOrder
    confirmPassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    userId?: SortOrder
    employeeNumber?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    userId?: SortOrder
    email?: SortOrder
    employeeNumber?: SortOrder
    joinDate?: SortOrder
    userName?: SortOrder
    affiliation?: SortOrder
    businessSituation?: SortOrder
    password?: SortOrder
    confirmPassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    userId?: SortOrder
    email?: SortOrder
    employeeNumber?: SortOrder
    joinDate?: SortOrder
    userName?: SortOrder
    affiliation?: SortOrder
    businessSituation?: SortOrder
    password?: SortOrder
    confirmPassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    userId?: SortOrder
    employeeNumber?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type skillCountOrderByAggregateInput = {
    skillId?: SortOrder
    userId?: SortOrder
    InherentName?: SortOrder
    InherentDescription?: SortOrder
    numericalNumber?: SortOrder
    numericalExplain?: SortOrder
    updatedAt?: SortOrder
  }

  export type skillAvgOrderByAggregateInput = {
    skillId?: SortOrder
    userId?: SortOrder
    numericalNumber?: SortOrder
  }

  export type skillMaxOrderByAggregateInput = {
    skillId?: SortOrder
    userId?: SortOrder
    InherentName?: SortOrder
    InherentDescription?: SortOrder
    numericalNumber?: SortOrder
    numericalExplain?: SortOrder
    updatedAt?: SortOrder
  }

  export type skillMinOrderByAggregateInput = {
    skillId?: SortOrder
    userId?: SortOrder
    InherentName?: SortOrder
    InherentDescription?: SortOrder
    numericalNumber?: SortOrder
    numericalExplain?: SortOrder
    updatedAt?: SortOrder
  }

  export type skillSumOrderByAggregateInput = {
    skillId?: SortOrder
    userId?: SortOrder
    numericalNumber?: SortOrder
  }

  export type skillPointCountOrderByAggregateInput = {
    skillPointId?: SortOrder
    userId?: SortOrder
    FR?: SortOrder
    BK?: SortOrder
    DB?: SortOrder
    SBR?: SortOrder
    AR?: SortOrder
    TS?: SortOrder
    COM?: SortOrder
  }

  export type skillPointAvgOrderByAggregateInput = {
    skillPointId?: SortOrder
    userId?: SortOrder
    FR?: SortOrder
    BK?: SortOrder
    DB?: SortOrder
    SBR?: SortOrder
    AR?: SortOrder
    TS?: SortOrder
    COM?: SortOrder
  }

  export type skillPointMaxOrderByAggregateInput = {
    skillPointId?: SortOrder
    userId?: SortOrder
    FR?: SortOrder
    BK?: SortOrder
    DB?: SortOrder
    SBR?: SortOrder
    AR?: SortOrder
    TS?: SortOrder
    COM?: SortOrder
  }

  export type skillPointMinOrderByAggregateInput = {
    skillPointId?: SortOrder
    userId?: SortOrder
    FR?: SortOrder
    BK?: SortOrder
    DB?: SortOrder
    SBR?: SortOrder
    AR?: SortOrder
    TS?: SortOrder
    COM?: SortOrder
  }

  export type skillPointSumOrderByAggregateInput = {
    skillPointId?: SortOrder
    userId?: SortOrder
    FR?: SortOrder
    BK?: SortOrder
    DB?: SortOrder
    SBR?: SortOrder
    AR?: SortOrder
    TS?: SortOrder
    COM?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type spaecialAbilityCountOrderByAggregateInput = {
    spaecialAbilityId?: SortOrder
    userId?: SortOrder
    skillList?: SortOrder
    skillSelection?: SortOrder
  }

  export type spaecialAbilityAvgOrderByAggregateInput = {
    spaecialAbilityId?: SortOrder
    userId?: SortOrder
  }

  export type spaecialAbilityMaxOrderByAggregateInput = {
    spaecialAbilityId?: SortOrder
    userId?: SortOrder
    skillList?: SortOrder
    skillSelection?: SortOrder
  }

  export type spaecialAbilityMinOrderByAggregateInput = {
    spaecialAbilityId?: SortOrder
    userId?: SortOrder
    skillList?: SortOrder
    skillSelection?: SortOrder
  }

  export type spaecialAbilitySumOrderByAggregateInput = {
    spaecialAbilityId?: SortOrder
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type PortfolioListRelationFilter = {
    every?: portfolioWhereInput
    some?: portfolioWhereInput
    none?: portfolioWhereInput
  }

  export type SkillSummaryListRelationFilter = {
    every?: skillSummaryWhereInput
    some?: skillSummaryWhereInput
    none?: skillSummaryWhereInput
  }

  export type SellingPointListRelationFilter = {
    every?: sellingPointWhereInput
    some?: sellingPointWhereInput
    none?: sellingPointWhereInput
  }

  export type QualificationListRelationFilter = {
    every?: qualificationWhereInput
    some?: qualificationWhereInput
    none?: qualificationWhereInput
  }

  export type PreviousWorkListRelationFilter = {
    every?: previousWorkWhereInput
    some?: previousWorkWhereInput
    none?: previousWorkWhereInput
  }

  export type DevelopmentExperienceListRelationFilter = {
    every?: developmentExperienceWhereInput
    some?: developmentExperienceWhereInput
    none?: developmentExperienceWhereInput
  }

  export type portfolioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type skillSummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sellingPointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qualificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type previousWorkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type developmentExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type specCountOrderByAggregateInput = {
    specId?: SortOrder
    userId?: SortOrder
    github?: SortOrder
    offHours?: SortOrder
    createdAt?: SortOrder
  }

  export type specAvgOrderByAggregateInput = {
    specId?: SortOrder
    userId?: SortOrder
  }

  export type specMaxOrderByAggregateInput = {
    specId?: SortOrder
    userId?: SortOrder
    github?: SortOrder
    offHours?: SortOrder
    createdAt?: SortOrder
  }

  export type specMinOrderByAggregateInput = {
    specId?: SortOrder
    userId?: SortOrder
    github?: SortOrder
    offHours?: SortOrder
    createdAt?: SortOrder
  }

  export type specSumOrderByAggregateInput = {
    specId?: SortOrder
    userId?: SortOrder
  }

  export type SpecRelationFilter = {
    is?: specWhereInput
    isNot?: specWhereInput
  }

  export type portfolioCountOrderByAggregateInput = {
    portfolioId?: SortOrder
    specId?: SortOrder
    heading?: SortOrder
    url?: SortOrder
  }

  export type portfolioAvgOrderByAggregateInput = {
    portfolioId?: SortOrder
    specId?: SortOrder
  }

  export type portfolioMaxOrderByAggregateInput = {
    portfolioId?: SortOrder
    specId?: SortOrder
    heading?: SortOrder
    url?: SortOrder
  }

  export type portfolioMinOrderByAggregateInput = {
    portfolioId?: SortOrder
    specId?: SortOrder
    heading?: SortOrder
    url?: SortOrder
  }

  export type portfolioSumOrderByAggregateInput = {
    portfolioId?: SortOrder
    specId?: SortOrder
  }

  export type AutoCalibrationRelationFilter = {
    is?: autoCalibrationWhereInput
    isNot?: autoCalibrationWhereInput
  }

  export type skillSummaryCountOrderByAggregateInput = {
    skillSummaryId?: SortOrder
    specId?: SortOrder
    autoCalibrationId?: SortOrder
  }

  export type skillSummaryAvgOrderByAggregateInput = {
    skillSummaryId?: SortOrder
    specId?: SortOrder
    autoCalibrationId?: SortOrder
  }

  export type skillSummaryMaxOrderByAggregateInput = {
    skillSummaryId?: SortOrder
    specId?: SortOrder
    autoCalibrationId?: SortOrder
  }

  export type skillSummaryMinOrderByAggregateInput = {
    skillSummaryId?: SortOrder
    specId?: SortOrder
    autoCalibrationId?: SortOrder
  }

  export type skillSummarySumOrderByAggregateInput = {
    skillSummaryId?: SortOrder
    specId?: SortOrder
    autoCalibrationId?: SortOrder
  }

  export type sellingPointCountOrderByAggregateInput = {
    sellingPointId?: SortOrder
    specId?: SortOrder
    title?: SortOrder
    content?: SortOrder
  }

  export type sellingPointAvgOrderByAggregateInput = {
    sellingPointId?: SortOrder
    specId?: SortOrder
  }

  export type sellingPointMaxOrderByAggregateInput = {
    sellingPointId?: SortOrder
    specId?: SortOrder
    title?: SortOrder
    content?: SortOrder
  }

  export type sellingPointMinOrderByAggregateInput = {
    sellingPointId?: SortOrder
    specId?: SortOrder
    title?: SortOrder
    content?: SortOrder
  }

  export type sellingPointSumOrderByAggregateInput = {
    sellingPointId?: SortOrder
    specId?: SortOrder
  }

  export type qualificationCountOrderByAggregateInput = {
    qualificationId?: SortOrder
    specId?: SortOrder
    credential?: SortOrder
    acquisitionDate?: SortOrder
  }

  export type qualificationAvgOrderByAggregateInput = {
    qualificationId?: SortOrder
    specId?: SortOrder
  }

  export type qualificationMaxOrderByAggregateInput = {
    qualificationId?: SortOrder
    specId?: SortOrder
    credential?: SortOrder
    acquisitionDate?: SortOrder
  }

  export type qualificationMinOrderByAggregateInput = {
    qualificationId?: SortOrder
    specId?: SortOrder
    credential?: SortOrder
    acquisitionDate?: SortOrder
  }

  export type qualificationSumOrderByAggregateInput = {
    qualificationId?: SortOrder
    specId?: SortOrder
  }

  export type previousWorkCountOrderByAggregateInput = {
    previousWorkId?: SortOrder
    specId?: SortOrder
    industry?: SortOrder
    occupation?: SortOrder
    JobDuties?: SortOrder
  }

  export type previousWorkAvgOrderByAggregateInput = {
    previousWorkId?: SortOrder
    specId?: SortOrder
  }

  export type previousWorkMaxOrderByAggregateInput = {
    previousWorkId?: SortOrder
    specId?: SortOrder
    industry?: SortOrder
    occupation?: SortOrder
    JobDuties?: SortOrder
  }

  export type previousWorkMinOrderByAggregateInput = {
    previousWorkId?: SortOrder
    specId?: SortOrder
    industry?: SortOrder
    occupation?: SortOrder
    JobDuties?: SortOrder
  }

  export type previousWorkSumOrderByAggregateInput = {
    previousWorkId?: SortOrder
    specId?: SortOrder
  }

  export type developmentExperienceCountOrderByAggregateInput = {
    developmentExperienceId?: SortOrder
    specId?: SortOrder
    startDate?: SortOrder
    duration?: SortOrder
    assignedTask?: SortOrder
    teamSize?: SortOrder
    totalProjectHeadcount?: SortOrder
    projectName?: SortOrder
    jobDuties?: SortOrder
    img?: SortOrder
    autoCalibrationId?: SortOrder
  }

  export type developmentExperienceAvgOrderByAggregateInput = {
    developmentExperienceId?: SortOrder
    specId?: SortOrder
    autoCalibrationId?: SortOrder
  }

  export type developmentExperienceMaxOrderByAggregateInput = {
    developmentExperienceId?: SortOrder
    specId?: SortOrder
    startDate?: SortOrder
    duration?: SortOrder
    assignedTask?: SortOrder
    teamSize?: SortOrder
    totalProjectHeadcount?: SortOrder
    projectName?: SortOrder
    jobDuties?: SortOrder
    img?: SortOrder
    autoCalibrationId?: SortOrder
  }

  export type developmentExperienceMinOrderByAggregateInput = {
    developmentExperienceId?: SortOrder
    specId?: SortOrder
    startDate?: SortOrder
    duration?: SortOrder
    assignedTask?: SortOrder
    teamSize?: SortOrder
    totalProjectHeadcount?: SortOrder
    projectName?: SortOrder
    jobDuties?: SortOrder
    img?: SortOrder
    autoCalibrationId?: SortOrder
  }

  export type developmentExperienceSumOrderByAggregateInput = {
    developmentExperienceId?: SortOrder
    specId?: SortOrder
    autoCalibrationId?: SortOrder
  }

  export type autoCalibrationCountOrderByAggregateInput = {
    autoCalibrationId?: SortOrder
    skill?: SortOrder
    membership?: SortOrder
    category?: SortOrder
    FR?: SortOrder
    CL?: SortOrder
    ML?: SortOrder
    QA?: SortOrder
    JAVA?: SortOrder
    PHP?: SortOrder
  }

  export type autoCalibrationAvgOrderByAggregateInput = {
    autoCalibrationId?: SortOrder
    membership?: SortOrder
    category?: SortOrder
    FR?: SortOrder
    CL?: SortOrder
    ML?: SortOrder
    QA?: SortOrder
    JAVA?: SortOrder
    PHP?: SortOrder
  }

  export type autoCalibrationMaxOrderByAggregateInput = {
    autoCalibrationId?: SortOrder
    skill?: SortOrder
    membership?: SortOrder
    category?: SortOrder
    FR?: SortOrder
    CL?: SortOrder
    ML?: SortOrder
    QA?: SortOrder
    JAVA?: SortOrder
    PHP?: SortOrder
  }

  export type autoCalibrationMinOrderByAggregateInput = {
    autoCalibrationId?: SortOrder
    skill?: SortOrder
    membership?: SortOrder
    category?: SortOrder
    FR?: SortOrder
    CL?: SortOrder
    ML?: SortOrder
    QA?: SortOrder
    JAVA?: SortOrder
    PHP?: SortOrder
  }

  export type autoCalibrationSumOrderByAggregateInput = {
    autoCalibrationId?: SortOrder
    membership?: SortOrder
    category?: SortOrder
    FR?: SortOrder
    CL?: SortOrder
    ML?: SortOrder
    QA?: SortOrder
    JAVA?: SortOrder
    PHP?: SortOrder
  }

  export type AdminRelationFilter = {
    is?: adminWhereInput
    isNot?: adminWhereInput
  }

  export type requestCountOrderByAggregateInput = {
    applicationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    adminComment?: SortOrder
    engineerComment?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    resultedAt?: SortOrder
  }

  export type requestAvgOrderByAggregateInput = {
    applicationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    adminId?: SortOrder
  }

  export type requestMaxOrderByAggregateInput = {
    applicationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    adminComment?: SortOrder
    engineerComment?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    resultedAt?: SortOrder
  }

  export type requestMinOrderByAggregateInput = {
    applicationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    adminComment?: SortOrder
    engineerComment?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    resultedAt?: SortOrder
  }

  export type requestSumOrderByAggregateInput = {
    applicationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    adminId?: SortOrder
  }

  export type adminCountOrderByAggregateInput = {
    adminId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    adminId?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    adminId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    adminId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    adminId?: SortOrder
  }

  export type skillCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<skillCreateWithoutUserInput>, Enumerable<skillUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<skillCreateOrConnectWithoutUserInput>
    createMany?: skillCreateManyUserInputEnvelope
    connect?: Enumerable<skillWhereUniqueInput>
  }

  export type skillPointCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<skillPointCreateWithoutUserInput>, Enumerable<skillPointUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<skillPointCreateOrConnectWithoutUserInput>
    createMany?: skillPointCreateManyUserInputEnvelope
    connect?: Enumerable<skillPointWhereUniqueInput>
  }

  export type spaecialAbilityCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<spaecialAbilityCreateWithoutUserInput>, Enumerable<spaecialAbilityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<spaecialAbilityCreateOrConnectWithoutUserInput>
    createMany?: spaecialAbilityCreateManyUserInputEnvelope
    connect?: Enumerable<spaecialAbilityWhereUniqueInput>
  }

  export type specCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<specCreateWithoutUserInput>, Enumerable<specUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<specCreateOrConnectWithoutUserInput>
    createMany?: specCreateManyUserInputEnvelope
    connect?: Enumerable<specWhereUniqueInput>
  }

  export type requestCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<requestCreateWithoutUserInput>, Enumerable<requestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<requestCreateOrConnectWithoutUserInput>
    createMany?: requestCreateManyUserInputEnvelope
    connect?: Enumerable<requestWhereUniqueInput>
  }

  export type skillUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<skillCreateWithoutUserInput>, Enumerable<skillUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<skillCreateOrConnectWithoutUserInput>
    createMany?: skillCreateManyUserInputEnvelope
    connect?: Enumerable<skillWhereUniqueInput>
  }

  export type skillPointUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<skillPointCreateWithoutUserInput>, Enumerable<skillPointUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<skillPointCreateOrConnectWithoutUserInput>
    createMany?: skillPointCreateManyUserInputEnvelope
    connect?: Enumerable<skillPointWhereUniqueInput>
  }

  export type spaecialAbilityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<spaecialAbilityCreateWithoutUserInput>, Enumerable<spaecialAbilityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<spaecialAbilityCreateOrConnectWithoutUserInput>
    createMany?: spaecialAbilityCreateManyUserInputEnvelope
    connect?: Enumerable<spaecialAbilityWhereUniqueInput>
  }

  export type specUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<specCreateWithoutUserInput>, Enumerable<specUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<specCreateOrConnectWithoutUserInput>
    createMany?: specCreateManyUserInputEnvelope
    connect?: Enumerable<specWhereUniqueInput>
  }

  export type requestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<requestCreateWithoutUserInput>, Enumerable<requestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<requestCreateOrConnectWithoutUserInput>
    createMany?: requestCreateManyUserInputEnvelope
    connect?: Enumerable<requestWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type skillUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<skillCreateWithoutUserInput>, Enumerable<skillUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<skillCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<skillUpsertWithWhereUniqueWithoutUserInput>
    createMany?: skillCreateManyUserInputEnvelope
    set?: Enumerable<skillWhereUniqueInput>
    disconnect?: Enumerable<skillWhereUniqueInput>
    delete?: Enumerable<skillWhereUniqueInput>
    connect?: Enumerable<skillWhereUniqueInput>
    update?: Enumerable<skillUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<skillUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<skillScalarWhereInput>
  }

  export type skillPointUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<skillPointCreateWithoutUserInput>, Enumerable<skillPointUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<skillPointCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<skillPointUpsertWithWhereUniqueWithoutUserInput>
    createMany?: skillPointCreateManyUserInputEnvelope
    set?: Enumerable<skillPointWhereUniqueInput>
    disconnect?: Enumerable<skillPointWhereUniqueInput>
    delete?: Enumerable<skillPointWhereUniqueInput>
    connect?: Enumerable<skillPointWhereUniqueInput>
    update?: Enumerable<skillPointUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<skillPointUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<skillPointScalarWhereInput>
  }

  export type spaecialAbilityUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<spaecialAbilityCreateWithoutUserInput>, Enumerable<spaecialAbilityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<spaecialAbilityCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<spaecialAbilityUpsertWithWhereUniqueWithoutUserInput>
    createMany?: spaecialAbilityCreateManyUserInputEnvelope
    set?: Enumerable<spaecialAbilityWhereUniqueInput>
    disconnect?: Enumerable<spaecialAbilityWhereUniqueInput>
    delete?: Enumerable<spaecialAbilityWhereUniqueInput>
    connect?: Enumerable<spaecialAbilityWhereUniqueInput>
    update?: Enumerable<spaecialAbilityUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<spaecialAbilityUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<spaecialAbilityScalarWhereInput>
  }

  export type specUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<specCreateWithoutUserInput>, Enumerable<specUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<specCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<specUpsertWithWhereUniqueWithoutUserInput>
    createMany?: specCreateManyUserInputEnvelope
    set?: Enumerable<specWhereUniqueInput>
    disconnect?: Enumerable<specWhereUniqueInput>
    delete?: Enumerable<specWhereUniqueInput>
    connect?: Enumerable<specWhereUniqueInput>
    update?: Enumerable<specUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<specUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<specScalarWhereInput>
  }

  export type requestUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<requestCreateWithoutUserInput>, Enumerable<requestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<requestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<requestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: requestCreateManyUserInputEnvelope
    set?: Enumerable<requestWhereUniqueInput>
    disconnect?: Enumerable<requestWhereUniqueInput>
    delete?: Enumerable<requestWhereUniqueInput>
    connect?: Enumerable<requestWhereUniqueInput>
    update?: Enumerable<requestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<requestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<requestScalarWhereInput>
  }

  export type skillUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<skillCreateWithoutUserInput>, Enumerable<skillUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<skillCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<skillUpsertWithWhereUniqueWithoutUserInput>
    createMany?: skillCreateManyUserInputEnvelope
    set?: Enumerable<skillWhereUniqueInput>
    disconnect?: Enumerable<skillWhereUniqueInput>
    delete?: Enumerable<skillWhereUniqueInput>
    connect?: Enumerable<skillWhereUniqueInput>
    update?: Enumerable<skillUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<skillUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<skillScalarWhereInput>
  }

  export type skillPointUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<skillPointCreateWithoutUserInput>, Enumerable<skillPointUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<skillPointCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<skillPointUpsertWithWhereUniqueWithoutUserInput>
    createMany?: skillPointCreateManyUserInputEnvelope
    set?: Enumerable<skillPointWhereUniqueInput>
    disconnect?: Enumerable<skillPointWhereUniqueInput>
    delete?: Enumerable<skillPointWhereUniqueInput>
    connect?: Enumerable<skillPointWhereUniqueInput>
    update?: Enumerable<skillPointUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<skillPointUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<skillPointScalarWhereInput>
  }

  export type spaecialAbilityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<spaecialAbilityCreateWithoutUserInput>, Enumerable<spaecialAbilityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<spaecialAbilityCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<spaecialAbilityUpsertWithWhereUniqueWithoutUserInput>
    createMany?: spaecialAbilityCreateManyUserInputEnvelope
    set?: Enumerable<spaecialAbilityWhereUniqueInput>
    disconnect?: Enumerable<spaecialAbilityWhereUniqueInput>
    delete?: Enumerable<spaecialAbilityWhereUniqueInput>
    connect?: Enumerable<spaecialAbilityWhereUniqueInput>
    update?: Enumerable<spaecialAbilityUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<spaecialAbilityUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<spaecialAbilityScalarWhereInput>
  }

  export type specUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<specCreateWithoutUserInput>, Enumerable<specUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<specCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<specUpsertWithWhereUniqueWithoutUserInput>
    createMany?: specCreateManyUserInputEnvelope
    set?: Enumerable<specWhereUniqueInput>
    disconnect?: Enumerable<specWhereUniqueInput>
    delete?: Enumerable<specWhereUniqueInput>
    connect?: Enumerable<specWhereUniqueInput>
    update?: Enumerable<specUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<specUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<specScalarWhereInput>
  }

  export type requestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<requestCreateWithoutUserInput>, Enumerable<requestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<requestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<requestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: requestCreateManyUserInputEnvelope
    set?: Enumerable<requestWhereUniqueInput>
    disconnect?: Enumerable<requestWhereUniqueInput>
    delete?: Enumerable<requestWhereUniqueInput>
    connect?: Enumerable<requestWhereUniqueInput>
    update?: Enumerable<requestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<requestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<requestScalarWhereInput>
  }

  export type userCreateNestedOneWithoutSkillsInput = {
    create?: XOR<userCreateWithoutSkillsInput, userUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: userCreateOrConnectWithoutSkillsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<userCreateWithoutSkillsInput, userUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: userCreateOrConnectWithoutSkillsInput
    upsert?: userUpsertWithoutSkillsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutSkillsInput, userUncheckedUpdateWithoutSkillsInput>
  }

  export type userCreateNestedOneWithoutSkillPointsInput = {
    create?: XOR<userCreateWithoutSkillPointsInput, userUncheckedCreateWithoutSkillPointsInput>
    connectOrCreate?: userCreateOrConnectWithoutSkillPointsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutSkillPointsNestedInput = {
    create?: XOR<userCreateWithoutSkillPointsInput, userUncheckedCreateWithoutSkillPointsInput>
    connectOrCreate?: userCreateOrConnectWithoutSkillPointsInput
    upsert?: userUpsertWithoutSkillPointsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutSkillPointsInput, userUncheckedUpdateWithoutSkillPointsInput>
  }

  export type userCreateNestedOneWithoutSpecialAbilitiesInput = {
    create?: XOR<userCreateWithoutSpecialAbilitiesInput, userUncheckedCreateWithoutSpecialAbilitiesInput>
    connectOrCreate?: userCreateOrConnectWithoutSpecialAbilitiesInput
    connect?: userWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type userUpdateOneRequiredWithoutSpecialAbilitiesNestedInput = {
    create?: XOR<userCreateWithoutSpecialAbilitiesInput, userUncheckedCreateWithoutSpecialAbilitiesInput>
    connectOrCreate?: userCreateOrConnectWithoutSpecialAbilitiesInput
    upsert?: userUpsertWithoutSpecialAbilitiesInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutSpecialAbilitiesInput, userUncheckedUpdateWithoutSpecialAbilitiesInput>
  }

  export type userCreateNestedOneWithoutSpecsInput = {
    create?: XOR<userCreateWithoutSpecsInput, userUncheckedCreateWithoutSpecsInput>
    connectOrCreate?: userCreateOrConnectWithoutSpecsInput
    connect?: userWhereUniqueInput
  }

  export type portfolioCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<portfolioCreateWithoutSpecInput>, Enumerable<portfolioUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<portfolioCreateOrConnectWithoutSpecInput>
    createMany?: portfolioCreateManySpecInputEnvelope
    connect?: Enumerable<portfolioWhereUniqueInput>
  }

  export type skillSummaryCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<skillSummaryCreateWithoutSpecInput>, Enumerable<skillSummaryUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<skillSummaryCreateOrConnectWithoutSpecInput>
    createMany?: skillSummaryCreateManySpecInputEnvelope
    connect?: Enumerable<skillSummaryWhereUniqueInput>
  }

  export type sellingPointCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<sellingPointCreateWithoutSpecInput>, Enumerable<sellingPointUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<sellingPointCreateOrConnectWithoutSpecInput>
    createMany?: sellingPointCreateManySpecInputEnvelope
    connect?: Enumerable<sellingPointWhereUniqueInput>
  }

  export type qualificationCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<qualificationCreateWithoutSpecInput>, Enumerable<qualificationUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<qualificationCreateOrConnectWithoutSpecInput>
    createMany?: qualificationCreateManySpecInputEnvelope
    connect?: Enumerable<qualificationWhereUniqueInput>
  }

  export type previousWorkCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<previousWorkCreateWithoutSpecInput>, Enumerable<previousWorkUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<previousWorkCreateOrConnectWithoutSpecInput>
    createMany?: previousWorkCreateManySpecInputEnvelope
    connect?: Enumerable<previousWorkWhereUniqueInput>
  }

  export type developmentExperienceCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<developmentExperienceCreateWithoutSpecInput>, Enumerable<developmentExperienceUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<developmentExperienceCreateOrConnectWithoutSpecInput>
    createMany?: developmentExperienceCreateManySpecInputEnvelope
    connect?: Enumerable<developmentExperienceWhereUniqueInput>
  }

  export type portfolioUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<portfolioCreateWithoutSpecInput>, Enumerable<portfolioUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<portfolioCreateOrConnectWithoutSpecInput>
    createMany?: portfolioCreateManySpecInputEnvelope
    connect?: Enumerable<portfolioWhereUniqueInput>
  }

  export type skillSummaryUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<skillSummaryCreateWithoutSpecInput>, Enumerable<skillSummaryUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<skillSummaryCreateOrConnectWithoutSpecInput>
    createMany?: skillSummaryCreateManySpecInputEnvelope
    connect?: Enumerable<skillSummaryWhereUniqueInput>
  }

  export type sellingPointUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<sellingPointCreateWithoutSpecInput>, Enumerable<sellingPointUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<sellingPointCreateOrConnectWithoutSpecInput>
    createMany?: sellingPointCreateManySpecInputEnvelope
    connect?: Enumerable<sellingPointWhereUniqueInput>
  }

  export type qualificationUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<qualificationCreateWithoutSpecInput>, Enumerable<qualificationUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<qualificationCreateOrConnectWithoutSpecInput>
    createMany?: qualificationCreateManySpecInputEnvelope
    connect?: Enumerable<qualificationWhereUniqueInput>
  }

  export type previousWorkUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<previousWorkCreateWithoutSpecInput>, Enumerable<previousWorkUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<previousWorkCreateOrConnectWithoutSpecInput>
    createMany?: previousWorkCreateManySpecInputEnvelope
    connect?: Enumerable<previousWorkWhereUniqueInput>
  }

  export type developmentExperienceUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<developmentExperienceCreateWithoutSpecInput>, Enumerable<developmentExperienceUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<developmentExperienceCreateOrConnectWithoutSpecInput>
    createMany?: developmentExperienceCreateManySpecInputEnvelope
    connect?: Enumerable<developmentExperienceWhereUniqueInput>
  }

  export type userUpdateOneRequiredWithoutSpecsNestedInput = {
    create?: XOR<userCreateWithoutSpecsInput, userUncheckedCreateWithoutSpecsInput>
    connectOrCreate?: userCreateOrConnectWithoutSpecsInput
    upsert?: userUpsertWithoutSpecsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutSpecsInput, userUncheckedUpdateWithoutSpecsInput>
  }

  export type portfolioUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<portfolioCreateWithoutSpecInput>, Enumerable<portfolioUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<portfolioCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<portfolioUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: portfolioCreateManySpecInputEnvelope
    set?: Enumerable<portfolioWhereUniqueInput>
    disconnect?: Enumerable<portfolioWhereUniqueInput>
    delete?: Enumerable<portfolioWhereUniqueInput>
    connect?: Enumerable<portfolioWhereUniqueInput>
    update?: Enumerable<portfolioUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<portfolioUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<portfolioScalarWhereInput>
  }

  export type skillSummaryUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<skillSummaryCreateWithoutSpecInput>, Enumerable<skillSummaryUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<skillSummaryCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<skillSummaryUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: skillSummaryCreateManySpecInputEnvelope
    set?: Enumerable<skillSummaryWhereUniqueInput>
    disconnect?: Enumerable<skillSummaryWhereUniqueInput>
    delete?: Enumerable<skillSummaryWhereUniqueInput>
    connect?: Enumerable<skillSummaryWhereUniqueInput>
    update?: Enumerable<skillSummaryUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<skillSummaryUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<skillSummaryScalarWhereInput>
  }

  export type sellingPointUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<sellingPointCreateWithoutSpecInput>, Enumerable<sellingPointUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<sellingPointCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<sellingPointUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: sellingPointCreateManySpecInputEnvelope
    set?: Enumerable<sellingPointWhereUniqueInput>
    disconnect?: Enumerable<sellingPointWhereUniqueInput>
    delete?: Enumerable<sellingPointWhereUniqueInput>
    connect?: Enumerable<sellingPointWhereUniqueInput>
    update?: Enumerable<sellingPointUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<sellingPointUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<sellingPointScalarWhereInput>
  }

  export type qualificationUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<qualificationCreateWithoutSpecInput>, Enumerable<qualificationUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<qualificationCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<qualificationUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: qualificationCreateManySpecInputEnvelope
    set?: Enumerable<qualificationWhereUniqueInput>
    disconnect?: Enumerable<qualificationWhereUniqueInput>
    delete?: Enumerable<qualificationWhereUniqueInput>
    connect?: Enumerable<qualificationWhereUniqueInput>
    update?: Enumerable<qualificationUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<qualificationUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<qualificationScalarWhereInput>
  }

  export type previousWorkUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<previousWorkCreateWithoutSpecInput>, Enumerable<previousWorkUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<previousWorkCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<previousWorkUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: previousWorkCreateManySpecInputEnvelope
    set?: Enumerable<previousWorkWhereUniqueInput>
    disconnect?: Enumerable<previousWorkWhereUniqueInput>
    delete?: Enumerable<previousWorkWhereUniqueInput>
    connect?: Enumerable<previousWorkWhereUniqueInput>
    update?: Enumerable<previousWorkUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<previousWorkUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<previousWorkScalarWhereInput>
  }

  export type developmentExperienceUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<developmentExperienceCreateWithoutSpecInput>, Enumerable<developmentExperienceUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<developmentExperienceCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<developmentExperienceUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: developmentExperienceCreateManySpecInputEnvelope
    set?: Enumerable<developmentExperienceWhereUniqueInput>
    disconnect?: Enumerable<developmentExperienceWhereUniqueInput>
    delete?: Enumerable<developmentExperienceWhereUniqueInput>
    connect?: Enumerable<developmentExperienceWhereUniqueInput>
    update?: Enumerable<developmentExperienceUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<developmentExperienceUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<developmentExperienceScalarWhereInput>
  }

  export type portfolioUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<portfolioCreateWithoutSpecInput>, Enumerable<portfolioUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<portfolioCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<portfolioUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: portfolioCreateManySpecInputEnvelope
    set?: Enumerable<portfolioWhereUniqueInput>
    disconnect?: Enumerable<portfolioWhereUniqueInput>
    delete?: Enumerable<portfolioWhereUniqueInput>
    connect?: Enumerable<portfolioWhereUniqueInput>
    update?: Enumerable<portfolioUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<portfolioUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<portfolioScalarWhereInput>
  }

  export type skillSummaryUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<skillSummaryCreateWithoutSpecInput>, Enumerable<skillSummaryUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<skillSummaryCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<skillSummaryUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: skillSummaryCreateManySpecInputEnvelope
    set?: Enumerable<skillSummaryWhereUniqueInput>
    disconnect?: Enumerable<skillSummaryWhereUniqueInput>
    delete?: Enumerable<skillSummaryWhereUniqueInput>
    connect?: Enumerable<skillSummaryWhereUniqueInput>
    update?: Enumerable<skillSummaryUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<skillSummaryUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<skillSummaryScalarWhereInput>
  }

  export type sellingPointUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<sellingPointCreateWithoutSpecInput>, Enumerable<sellingPointUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<sellingPointCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<sellingPointUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: sellingPointCreateManySpecInputEnvelope
    set?: Enumerable<sellingPointWhereUniqueInput>
    disconnect?: Enumerable<sellingPointWhereUniqueInput>
    delete?: Enumerable<sellingPointWhereUniqueInput>
    connect?: Enumerable<sellingPointWhereUniqueInput>
    update?: Enumerable<sellingPointUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<sellingPointUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<sellingPointScalarWhereInput>
  }

  export type qualificationUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<qualificationCreateWithoutSpecInput>, Enumerable<qualificationUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<qualificationCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<qualificationUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: qualificationCreateManySpecInputEnvelope
    set?: Enumerable<qualificationWhereUniqueInput>
    disconnect?: Enumerable<qualificationWhereUniqueInput>
    delete?: Enumerable<qualificationWhereUniqueInput>
    connect?: Enumerable<qualificationWhereUniqueInput>
    update?: Enumerable<qualificationUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<qualificationUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<qualificationScalarWhereInput>
  }

  export type previousWorkUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<previousWorkCreateWithoutSpecInput>, Enumerable<previousWorkUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<previousWorkCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<previousWorkUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: previousWorkCreateManySpecInputEnvelope
    set?: Enumerable<previousWorkWhereUniqueInput>
    disconnect?: Enumerable<previousWorkWhereUniqueInput>
    delete?: Enumerable<previousWorkWhereUniqueInput>
    connect?: Enumerable<previousWorkWhereUniqueInput>
    update?: Enumerable<previousWorkUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<previousWorkUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<previousWorkScalarWhereInput>
  }

  export type developmentExperienceUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<developmentExperienceCreateWithoutSpecInput>, Enumerable<developmentExperienceUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<developmentExperienceCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<developmentExperienceUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: developmentExperienceCreateManySpecInputEnvelope
    set?: Enumerable<developmentExperienceWhereUniqueInput>
    disconnect?: Enumerable<developmentExperienceWhereUniqueInput>
    delete?: Enumerable<developmentExperienceWhereUniqueInput>
    connect?: Enumerable<developmentExperienceWhereUniqueInput>
    update?: Enumerable<developmentExperienceUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<developmentExperienceUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<developmentExperienceScalarWhereInput>
  }

  export type specCreateNestedOneWithoutPortfoliosInput = {
    create?: XOR<specCreateWithoutPortfoliosInput, specUncheckedCreateWithoutPortfoliosInput>
    connectOrCreate?: specCreateOrConnectWithoutPortfoliosInput
    connect?: specWhereUniqueInput
  }

  export type specUpdateOneRequiredWithoutPortfoliosNestedInput = {
    create?: XOR<specCreateWithoutPortfoliosInput, specUncheckedCreateWithoutPortfoliosInput>
    connectOrCreate?: specCreateOrConnectWithoutPortfoliosInput
    upsert?: specUpsertWithoutPortfoliosInput
    connect?: specWhereUniqueInput
    update?: XOR<specUpdateWithoutPortfoliosInput, specUncheckedUpdateWithoutPortfoliosInput>
  }

  export type specCreateNestedOneWithoutSkillSummariesInput = {
    create?: XOR<specCreateWithoutSkillSummariesInput, specUncheckedCreateWithoutSkillSummariesInput>
    connectOrCreate?: specCreateOrConnectWithoutSkillSummariesInput
    connect?: specWhereUniqueInput
  }

  export type autoCalibrationCreateNestedOneWithoutSkillSummariesInput = {
    create?: XOR<autoCalibrationCreateWithoutSkillSummariesInput, autoCalibrationUncheckedCreateWithoutSkillSummariesInput>
    connectOrCreate?: autoCalibrationCreateOrConnectWithoutSkillSummariesInput
    connect?: autoCalibrationWhereUniqueInput
  }

  export type specUpdateOneRequiredWithoutSkillSummariesNestedInput = {
    create?: XOR<specCreateWithoutSkillSummariesInput, specUncheckedCreateWithoutSkillSummariesInput>
    connectOrCreate?: specCreateOrConnectWithoutSkillSummariesInput
    upsert?: specUpsertWithoutSkillSummariesInput
    connect?: specWhereUniqueInput
    update?: XOR<specUpdateWithoutSkillSummariesInput, specUncheckedUpdateWithoutSkillSummariesInput>
  }

  export type autoCalibrationUpdateOneRequiredWithoutSkillSummariesNestedInput = {
    create?: XOR<autoCalibrationCreateWithoutSkillSummariesInput, autoCalibrationUncheckedCreateWithoutSkillSummariesInput>
    connectOrCreate?: autoCalibrationCreateOrConnectWithoutSkillSummariesInput
    upsert?: autoCalibrationUpsertWithoutSkillSummariesInput
    connect?: autoCalibrationWhereUniqueInput
    update?: XOR<autoCalibrationUpdateWithoutSkillSummariesInput, autoCalibrationUncheckedUpdateWithoutSkillSummariesInput>
  }

  export type specCreateNestedOneWithoutSellingPointsInput = {
    create?: XOR<specCreateWithoutSellingPointsInput, specUncheckedCreateWithoutSellingPointsInput>
    connectOrCreate?: specCreateOrConnectWithoutSellingPointsInput
    connect?: specWhereUniqueInput
  }

  export type specUpdateOneRequiredWithoutSellingPointsNestedInput = {
    create?: XOR<specCreateWithoutSellingPointsInput, specUncheckedCreateWithoutSellingPointsInput>
    connectOrCreate?: specCreateOrConnectWithoutSellingPointsInput
    upsert?: specUpsertWithoutSellingPointsInput
    connect?: specWhereUniqueInput
    update?: XOR<specUpdateWithoutSellingPointsInput, specUncheckedUpdateWithoutSellingPointsInput>
  }

  export type specCreateNestedOneWithoutQualificationsInput = {
    create?: XOR<specCreateWithoutQualificationsInput, specUncheckedCreateWithoutQualificationsInput>
    connectOrCreate?: specCreateOrConnectWithoutQualificationsInput
    connect?: specWhereUniqueInput
  }

  export type specUpdateOneRequiredWithoutQualificationsNestedInput = {
    create?: XOR<specCreateWithoutQualificationsInput, specUncheckedCreateWithoutQualificationsInput>
    connectOrCreate?: specCreateOrConnectWithoutQualificationsInput
    upsert?: specUpsertWithoutQualificationsInput
    connect?: specWhereUniqueInput
    update?: XOR<specUpdateWithoutQualificationsInput, specUncheckedUpdateWithoutQualificationsInput>
  }

  export type specCreateNestedOneWithoutPreviousWorksInput = {
    create?: XOR<specCreateWithoutPreviousWorksInput, specUncheckedCreateWithoutPreviousWorksInput>
    connectOrCreate?: specCreateOrConnectWithoutPreviousWorksInput
    connect?: specWhereUniqueInput
  }

  export type specUpdateOneRequiredWithoutPreviousWorksNestedInput = {
    create?: XOR<specCreateWithoutPreviousWorksInput, specUncheckedCreateWithoutPreviousWorksInput>
    connectOrCreate?: specCreateOrConnectWithoutPreviousWorksInput
    upsert?: specUpsertWithoutPreviousWorksInput
    connect?: specWhereUniqueInput
    update?: XOR<specUpdateWithoutPreviousWorksInput, specUncheckedUpdateWithoutPreviousWorksInput>
  }

  export type specCreateNestedOneWithoutDevelopmentExperiencesInput = {
    create?: XOR<specCreateWithoutDevelopmentExperiencesInput, specUncheckedCreateWithoutDevelopmentExperiencesInput>
    connectOrCreate?: specCreateOrConnectWithoutDevelopmentExperiencesInput
    connect?: specWhereUniqueInput
  }

  export type autoCalibrationCreateNestedOneWithoutDevelopmentExperiencesInput = {
    create?: XOR<autoCalibrationCreateWithoutDevelopmentExperiencesInput, autoCalibrationUncheckedCreateWithoutDevelopmentExperiencesInput>
    connectOrCreate?: autoCalibrationCreateOrConnectWithoutDevelopmentExperiencesInput
    connect?: autoCalibrationWhereUniqueInput
  }

  export type specUpdateOneRequiredWithoutDevelopmentExperiencesNestedInput = {
    create?: XOR<specCreateWithoutDevelopmentExperiencesInput, specUncheckedCreateWithoutDevelopmentExperiencesInput>
    connectOrCreate?: specCreateOrConnectWithoutDevelopmentExperiencesInput
    upsert?: specUpsertWithoutDevelopmentExperiencesInput
    connect?: specWhereUniqueInput
    update?: XOR<specUpdateWithoutDevelopmentExperiencesInput, specUncheckedUpdateWithoutDevelopmentExperiencesInput>
  }

  export type autoCalibrationUpdateOneRequiredWithoutDevelopmentExperiencesNestedInput = {
    create?: XOR<autoCalibrationCreateWithoutDevelopmentExperiencesInput, autoCalibrationUncheckedCreateWithoutDevelopmentExperiencesInput>
    connectOrCreate?: autoCalibrationCreateOrConnectWithoutDevelopmentExperiencesInput
    upsert?: autoCalibrationUpsertWithoutDevelopmentExperiencesInput
    connect?: autoCalibrationWhereUniqueInput
    update?: XOR<autoCalibrationUpdateWithoutDevelopmentExperiencesInput, autoCalibrationUncheckedUpdateWithoutDevelopmentExperiencesInput>
  }

  export type skillSummaryCreateNestedManyWithoutAutoCalibrationInput = {
    create?: XOR<Enumerable<skillSummaryCreateWithoutAutoCalibrationInput>, Enumerable<skillSummaryUncheckedCreateWithoutAutoCalibrationInput>>
    connectOrCreate?: Enumerable<skillSummaryCreateOrConnectWithoutAutoCalibrationInput>
    createMany?: skillSummaryCreateManyAutoCalibrationInputEnvelope
    connect?: Enumerable<skillSummaryWhereUniqueInput>
  }

  export type developmentExperienceCreateNestedManyWithoutAutoCalibrationInput = {
    create?: XOR<Enumerable<developmentExperienceCreateWithoutAutoCalibrationInput>, Enumerable<developmentExperienceUncheckedCreateWithoutAutoCalibrationInput>>
    connectOrCreate?: Enumerable<developmentExperienceCreateOrConnectWithoutAutoCalibrationInput>
    createMany?: developmentExperienceCreateManyAutoCalibrationInputEnvelope
    connect?: Enumerable<developmentExperienceWhereUniqueInput>
  }

  export type skillSummaryUncheckedCreateNestedManyWithoutAutoCalibrationInput = {
    create?: XOR<Enumerable<skillSummaryCreateWithoutAutoCalibrationInput>, Enumerable<skillSummaryUncheckedCreateWithoutAutoCalibrationInput>>
    connectOrCreate?: Enumerable<skillSummaryCreateOrConnectWithoutAutoCalibrationInput>
    createMany?: skillSummaryCreateManyAutoCalibrationInputEnvelope
    connect?: Enumerable<skillSummaryWhereUniqueInput>
  }

  export type developmentExperienceUncheckedCreateNestedManyWithoutAutoCalibrationInput = {
    create?: XOR<Enumerable<developmentExperienceCreateWithoutAutoCalibrationInput>, Enumerable<developmentExperienceUncheckedCreateWithoutAutoCalibrationInput>>
    connectOrCreate?: Enumerable<developmentExperienceCreateOrConnectWithoutAutoCalibrationInput>
    createMany?: developmentExperienceCreateManyAutoCalibrationInputEnvelope
    connect?: Enumerable<developmentExperienceWhereUniqueInput>
  }

  export type skillSummaryUpdateManyWithoutAutoCalibrationNestedInput = {
    create?: XOR<Enumerable<skillSummaryCreateWithoutAutoCalibrationInput>, Enumerable<skillSummaryUncheckedCreateWithoutAutoCalibrationInput>>
    connectOrCreate?: Enumerable<skillSummaryCreateOrConnectWithoutAutoCalibrationInput>
    upsert?: Enumerable<skillSummaryUpsertWithWhereUniqueWithoutAutoCalibrationInput>
    createMany?: skillSummaryCreateManyAutoCalibrationInputEnvelope
    set?: Enumerable<skillSummaryWhereUniqueInput>
    disconnect?: Enumerable<skillSummaryWhereUniqueInput>
    delete?: Enumerable<skillSummaryWhereUniqueInput>
    connect?: Enumerable<skillSummaryWhereUniqueInput>
    update?: Enumerable<skillSummaryUpdateWithWhereUniqueWithoutAutoCalibrationInput>
    updateMany?: Enumerable<skillSummaryUpdateManyWithWhereWithoutAutoCalibrationInput>
    deleteMany?: Enumerable<skillSummaryScalarWhereInput>
  }

  export type developmentExperienceUpdateManyWithoutAutoCalibrationNestedInput = {
    create?: XOR<Enumerable<developmentExperienceCreateWithoutAutoCalibrationInput>, Enumerable<developmentExperienceUncheckedCreateWithoutAutoCalibrationInput>>
    connectOrCreate?: Enumerable<developmentExperienceCreateOrConnectWithoutAutoCalibrationInput>
    upsert?: Enumerable<developmentExperienceUpsertWithWhereUniqueWithoutAutoCalibrationInput>
    createMany?: developmentExperienceCreateManyAutoCalibrationInputEnvelope
    set?: Enumerable<developmentExperienceWhereUniqueInput>
    disconnect?: Enumerable<developmentExperienceWhereUniqueInput>
    delete?: Enumerable<developmentExperienceWhereUniqueInput>
    connect?: Enumerable<developmentExperienceWhereUniqueInput>
    update?: Enumerable<developmentExperienceUpdateWithWhereUniqueWithoutAutoCalibrationInput>
    updateMany?: Enumerable<developmentExperienceUpdateManyWithWhereWithoutAutoCalibrationInput>
    deleteMany?: Enumerable<developmentExperienceScalarWhereInput>
  }

  export type skillSummaryUncheckedUpdateManyWithoutAutoCalibrationNestedInput = {
    create?: XOR<Enumerable<skillSummaryCreateWithoutAutoCalibrationInput>, Enumerable<skillSummaryUncheckedCreateWithoutAutoCalibrationInput>>
    connectOrCreate?: Enumerable<skillSummaryCreateOrConnectWithoutAutoCalibrationInput>
    upsert?: Enumerable<skillSummaryUpsertWithWhereUniqueWithoutAutoCalibrationInput>
    createMany?: skillSummaryCreateManyAutoCalibrationInputEnvelope
    set?: Enumerable<skillSummaryWhereUniqueInput>
    disconnect?: Enumerable<skillSummaryWhereUniqueInput>
    delete?: Enumerable<skillSummaryWhereUniqueInput>
    connect?: Enumerable<skillSummaryWhereUniqueInput>
    update?: Enumerable<skillSummaryUpdateWithWhereUniqueWithoutAutoCalibrationInput>
    updateMany?: Enumerable<skillSummaryUpdateManyWithWhereWithoutAutoCalibrationInput>
    deleteMany?: Enumerable<skillSummaryScalarWhereInput>
  }

  export type developmentExperienceUncheckedUpdateManyWithoutAutoCalibrationNestedInput = {
    create?: XOR<Enumerable<developmentExperienceCreateWithoutAutoCalibrationInput>, Enumerable<developmentExperienceUncheckedCreateWithoutAutoCalibrationInput>>
    connectOrCreate?: Enumerable<developmentExperienceCreateOrConnectWithoutAutoCalibrationInput>
    upsert?: Enumerable<developmentExperienceUpsertWithWhereUniqueWithoutAutoCalibrationInput>
    createMany?: developmentExperienceCreateManyAutoCalibrationInputEnvelope
    set?: Enumerable<developmentExperienceWhereUniqueInput>
    disconnect?: Enumerable<developmentExperienceWhereUniqueInput>
    delete?: Enumerable<developmentExperienceWhereUniqueInput>
    connect?: Enumerable<developmentExperienceWhereUniqueInput>
    update?: Enumerable<developmentExperienceUpdateWithWhereUniqueWithoutAutoCalibrationInput>
    updateMany?: Enumerable<developmentExperienceUpdateManyWithWhereWithoutAutoCalibrationInput>
    deleteMany?: Enumerable<developmentExperienceScalarWhereInput>
  }

  export type userCreateNestedOneWithoutRequestsInput = {
    create?: XOR<userCreateWithoutRequestsInput, userUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: userCreateOrConnectWithoutRequestsInput
    connect?: userWhereUniqueInput
  }

  export type adminCreateNestedOneWithoutRequestsInput = {
    create?: XOR<adminCreateWithoutRequestsInput, adminUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: adminCreateOrConnectWithoutRequestsInput
    connect?: adminWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<userCreateWithoutRequestsInput, userUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: userCreateOrConnectWithoutRequestsInput
    upsert?: userUpsertWithoutRequestsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutRequestsInput, userUncheckedUpdateWithoutRequestsInput>
  }

  export type adminUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<adminCreateWithoutRequestsInput, adminUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: adminCreateOrConnectWithoutRequestsInput
    upsert?: adminUpsertWithoutRequestsInput
    connect?: adminWhereUniqueInput
    update?: XOR<adminUpdateWithoutRequestsInput, adminUncheckedUpdateWithoutRequestsInput>
  }

  export type requestCreateNestedManyWithoutAdminInput = {
    create?: XOR<Enumerable<requestCreateWithoutAdminInput>, Enumerable<requestUncheckedCreateWithoutAdminInput>>
    connectOrCreate?: Enumerable<requestCreateOrConnectWithoutAdminInput>
    createMany?: requestCreateManyAdminInputEnvelope
    connect?: Enumerable<requestWhereUniqueInput>
  }

  export type requestUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<Enumerable<requestCreateWithoutAdminInput>, Enumerable<requestUncheckedCreateWithoutAdminInput>>
    connectOrCreate?: Enumerable<requestCreateOrConnectWithoutAdminInput>
    createMany?: requestCreateManyAdminInputEnvelope
    connect?: Enumerable<requestWhereUniqueInput>
  }

  export type requestUpdateManyWithoutAdminNestedInput = {
    create?: XOR<Enumerable<requestCreateWithoutAdminInput>, Enumerable<requestUncheckedCreateWithoutAdminInput>>
    connectOrCreate?: Enumerable<requestCreateOrConnectWithoutAdminInput>
    upsert?: Enumerable<requestUpsertWithWhereUniqueWithoutAdminInput>
    createMany?: requestCreateManyAdminInputEnvelope
    set?: Enumerable<requestWhereUniqueInput>
    disconnect?: Enumerable<requestWhereUniqueInput>
    delete?: Enumerable<requestWhereUniqueInput>
    connect?: Enumerable<requestWhereUniqueInput>
    update?: Enumerable<requestUpdateWithWhereUniqueWithoutAdminInput>
    updateMany?: Enumerable<requestUpdateManyWithWhereWithoutAdminInput>
    deleteMany?: Enumerable<requestScalarWhereInput>
  }

  export type requestUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<Enumerable<requestCreateWithoutAdminInput>, Enumerable<requestUncheckedCreateWithoutAdminInput>>
    connectOrCreate?: Enumerable<requestCreateOrConnectWithoutAdminInput>
    upsert?: Enumerable<requestUpsertWithWhereUniqueWithoutAdminInput>
    createMany?: requestCreateManyAdminInputEnvelope
    set?: Enumerable<requestWhereUniqueInput>
    disconnect?: Enumerable<requestWhereUniqueInput>
    delete?: Enumerable<requestWhereUniqueInput>
    connect?: Enumerable<requestWhereUniqueInput>
    update?: Enumerable<requestUpdateWithWhereUniqueWithoutAdminInput>
    updateMany?: Enumerable<requestUpdateManyWithWhereWithoutAdminInput>
    deleteMany?: Enumerable<requestScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type skillCreateWithoutUserInput = {
    InherentName: string
    InherentDescription: string
    numericalNumber: number
    numericalExplain: string
    updatedAt: Date | string
  }

  export type skillUncheckedCreateWithoutUserInput = {
    skillId?: number
    InherentName: string
    InherentDescription: string
    numericalNumber: number
    numericalExplain: string
    updatedAt: Date | string
  }

  export type skillCreateOrConnectWithoutUserInput = {
    where: skillWhereUniqueInput
    create: XOR<skillCreateWithoutUserInput, skillUncheckedCreateWithoutUserInput>
  }

  export type skillCreateManyUserInputEnvelope = {
    data: Enumerable<skillCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type skillPointCreateWithoutUserInput = {
    FR: number
    BK: number
    DB: number
    SBR: number
    AR: number
    TS: number
    COM: number
  }

  export type skillPointUncheckedCreateWithoutUserInput = {
    skillPointId?: number
    FR: number
    BK: number
    DB: number
    SBR: number
    AR: number
    TS: number
    COM: number
  }

  export type skillPointCreateOrConnectWithoutUserInput = {
    where: skillPointWhereUniqueInput
    create: XOR<skillPointCreateWithoutUserInput, skillPointUncheckedCreateWithoutUserInput>
  }

  export type skillPointCreateManyUserInputEnvelope = {
    data: Enumerable<skillPointCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type spaecialAbilityCreateWithoutUserInput = {
    skillList: string
    skillSelection: boolean
  }

  export type spaecialAbilityUncheckedCreateWithoutUserInput = {
    spaecialAbilityId?: number
    skillList: string
    skillSelection: boolean
  }

  export type spaecialAbilityCreateOrConnectWithoutUserInput = {
    where: spaecialAbilityWhereUniqueInput
    create: XOR<spaecialAbilityCreateWithoutUserInput, spaecialAbilityUncheckedCreateWithoutUserInput>
  }

  export type spaecialAbilityCreateManyUserInputEnvelope = {
    data: Enumerable<spaecialAbilityCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type specCreateWithoutUserInput = {
    github: string
    offHours: string
    createdAt: Date | string
    portfolios?: portfolioCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointCreateNestedManyWithoutSpecInput
    qualifications?: qualificationCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceCreateNestedManyWithoutSpecInput
  }

  export type specUncheckedCreateWithoutUserInput = {
    specId?: number
    github: string
    offHours: string
    createdAt: Date | string
    portfolios?: portfolioUncheckedCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryUncheckedCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointUncheckedCreateNestedManyWithoutSpecInput
    qualifications?: qualificationUncheckedCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkUncheckedCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceUncheckedCreateNestedManyWithoutSpecInput
  }

  export type specCreateOrConnectWithoutUserInput = {
    where: specWhereUniqueInput
    create: XOR<specCreateWithoutUserInput, specUncheckedCreateWithoutUserInput>
  }

  export type specCreateManyUserInputEnvelope = {
    data: Enumerable<specCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type requestCreateWithoutUserInput = {
    status: number
    adminComment: string
    engineerComment: string
    createdAt: Date | string
    resultedAt: Date | string
    admin: adminCreateNestedOneWithoutRequestsInput
  }

  export type requestUncheckedCreateWithoutUserInput = {
    applicationId?: number
    status: number
    adminComment: string
    engineerComment: string
    adminId: number
    createdAt: Date | string
    resultedAt: Date | string
  }

  export type requestCreateOrConnectWithoutUserInput = {
    where: requestWhereUniqueInput
    create: XOR<requestCreateWithoutUserInput, requestUncheckedCreateWithoutUserInput>
  }

  export type requestCreateManyUserInputEnvelope = {
    data: Enumerable<requestCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type skillUpsertWithWhereUniqueWithoutUserInput = {
    where: skillWhereUniqueInput
    update: XOR<skillUpdateWithoutUserInput, skillUncheckedUpdateWithoutUserInput>
    create: XOR<skillCreateWithoutUserInput, skillUncheckedCreateWithoutUserInput>
  }

  export type skillUpdateWithWhereUniqueWithoutUserInput = {
    where: skillWhereUniqueInput
    data: XOR<skillUpdateWithoutUserInput, skillUncheckedUpdateWithoutUserInput>
  }

  export type skillUpdateManyWithWhereWithoutUserInput = {
    where: skillScalarWhereInput
    data: XOR<skillUpdateManyMutationInput, skillUncheckedUpdateManyWithoutSkillsInput>
  }

  export type skillScalarWhereInput = {
    AND?: Enumerable<skillScalarWhereInput>
    OR?: Enumerable<skillScalarWhereInput>
    NOT?: Enumerable<skillScalarWhereInput>
    skillId?: IntFilter | number
    userId?: IntFilter | number
    InherentName?: StringFilter | string
    InherentDescription?: StringFilter | string
    numericalNumber?: IntFilter | number
    numericalExplain?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type skillPointUpsertWithWhereUniqueWithoutUserInput = {
    where: skillPointWhereUniqueInput
    update: XOR<skillPointUpdateWithoutUserInput, skillPointUncheckedUpdateWithoutUserInput>
    create: XOR<skillPointCreateWithoutUserInput, skillPointUncheckedCreateWithoutUserInput>
  }

  export type skillPointUpdateWithWhereUniqueWithoutUserInput = {
    where: skillPointWhereUniqueInput
    data: XOR<skillPointUpdateWithoutUserInput, skillPointUncheckedUpdateWithoutUserInput>
  }

  export type skillPointUpdateManyWithWhereWithoutUserInput = {
    where: skillPointScalarWhereInput
    data: XOR<skillPointUpdateManyMutationInput, skillPointUncheckedUpdateManyWithoutSkillPointsInput>
  }

  export type skillPointScalarWhereInput = {
    AND?: Enumerable<skillPointScalarWhereInput>
    OR?: Enumerable<skillPointScalarWhereInput>
    NOT?: Enumerable<skillPointScalarWhereInput>
    skillPointId?: IntFilter | number
    userId?: IntFilter | number
    FR?: IntFilter | number
    BK?: IntFilter | number
    DB?: IntFilter | number
    SBR?: IntFilter | number
    AR?: IntFilter | number
    TS?: IntFilter | number
    COM?: IntFilter | number
  }

  export type spaecialAbilityUpsertWithWhereUniqueWithoutUserInput = {
    where: spaecialAbilityWhereUniqueInput
    update: XOR<spaecialAbilityUpdateWithoutUserInput, spaecialAbilityUncheckedUpdateWithoutUserInput>
    create: XOR<spaecialAbilityCreateWithoutUserInput, spaecialAbilityUncheckedCreateWithoutUserInput>
  }

  export type spaecialAbilityUpdateWithWhereUniqueWithoutUserInput = {
    where: spaecialAbilityWhereUniqueInput
    data: XOR<spaecialAbilityUpdateWithoutUserInput, spaecialAbilityUncheckedUpdateWithoutUserInput>
  }

  export type spaecialAbilityUpdateManyWithWhereWithoutUserInput = {
    where: spaecialAbilityScalarWhereInput
    data: XOR<spaecialAbilityUpdateManyMutationInput, spaecialAbilityUncheckedUpdateManyWithoutSpecialAbilitiesInput>
  }

  export type spaecialAbilityScalarWhereInput = {
    AND?: Enumerable<spaecialAbilityScalarWhereInput>
    OR?: Enumerable<spaecialAbilityScalarWhereInput>
    NOT?: Enumerable<spaecialAbilityScalarWhereInput>
    spaecialAbilityId?: IntFilter | number
    userId?: IntFilter | number
    skillList?: StringFilter | string
    skillSelection?: BoolFilter | boolean
  }

  export type specUpsertWithWhereUniqueWithoutUserInput = {
    where: specWhereUniqueInput
    update: XOR<specUpdateWithoutUserInput, specUncheckedUpdateWithoutUserInput>
    create: XOR<specCreateWithoutUserInput, specUncheckedCreateWithoutUserInput>
  }

  export type specUpdateWithWhereUniqueWithoutUserInput = {
    where: specWhereUniqueInput
    data: XOR<specUpdateWithoutUserInput, specUncheckedUpdateWithoutUserInput>
  }

  export type specUpdateManyWithWhereWithoutUserInput = {
    where: specScalarWhereInput
    data: XOR<specUpdateManyMutationInput, specUncheckedUpdateManyWithoutSpecsInput>
  }

  export type specScalarWhereInput = {
    AND?: Enumerable<specScalarWhereInput>
    OR?: Enumerable<specScalarWhereInput>
    NOT?: Enumerable<specScalarWhereInput>
    specId?: IntFilter | number
    userId?: IntFilter | number
    github?: StringFilter | string
    offHours?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type requestUpsertWithWhereUniqueWithoutUserInput = {
    where: requestWhereUniqueInput
    update: XOR<requestUpdateWithoutUserInput, requestUncheckedUpdateWithoutUserInput>
    create: XOR<requestCreateWithoutUserInput, requestUncheckedCreateWithoutUserInput>
  }

  export type requestUpdateWithWhereUniqueWithoutUserInput = {
    where: requestWhereUniqueInput
    data: XOR<requestUpdateWithoutUserInput, requestUncheckedUpdateWithoutUserInput>
  }

  export type requestUpdateManyWithWhereWithoutUserInput = {
    where: requestScalarWhereInput
    data: XOR<requestUpdateManyMutationInput, requestUncheckedUpdateManyWithoutRequestsInput>
  }

  export type requestScalarWhereInput = {
    AND?: Enumerable<requestScalarWhereInput>
    OR?: Enumerable<requestScalarWhereInput>
    NOT?: Enumerable<requestScalarWhereInput>
    applicationId?: IntFilter | number
    userId?: IntFilter | number
    status?: IntFilter | number
    adminComment?: StringFilter | string
    engineerComment?: StringFilter | string
    adminId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    resultedAt?: DateTimeFilter | Date | string
  }

  export type userCreateWithoutSkillsInput = {
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skillPoints?: skillPointCreateNestedManyWithoutUserInput
    specialAbilities?: spaecialAbilityCreateNestedManyWithoutUserInput
    specs?: specCreateNestedManyWithoutUserInput
    requests?: requestCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSkillsInput = {
    userId?: number
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skillPoints?: skillPointUncheckedCreateNestedManyWithoutUserInput
    specialAbilities?: spaecialAbilityUncheckedCreateNestedManyWithoutUserInput
    specs?: specUncheckedCreateNestedManyWithoutUserInput
    requests?: requestUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSkillsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSkillsInput, userUncheckedCreateWithoutSkillsInput>
  }

  export type userUpsertWithoutSkillsInput = {
    update: XOR<userUpdateWithoutSkillsInput, userUncheckedUpdateWithoutSkillsInput>
    create: XOR<userCreateWithoutSkillsInput, userUncheckedCreateWithoutSkillsInput>
  }

  export type userUpdateWithoutSkillsInput = {
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillPoints?: skillPointUpdateManyWithoutUserNestedInput
    specialAbilities?: spaecialAbilityUpdateManyWithoutUserNestedInput
    specs?: specUpdateManyWithoutUserNestedInput
    requests?: requestUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSkillsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillPoints?: skillPointUncheckedUpdateManyWithoutUserNestedInput
    specialAbilities?: spaecialAbilityUncheckedUpdateManyWithoutUserNestedInput
    specs?: specUncheckedUpdateManyWithoutUserNestedInput
    requests?: requestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutSkillPointsInput = {
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skills?: skillCreateNestedManyWithoutUserInput
    specialAbilities?: spaecialAbilityCreateNestedManyWithoutUserInput
    specs?: specCreateNestedManyWithoutUserInput
    requests?: requestCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSkillPointsInput = {
    userId?: number
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skills?: skillUncheckedCreateNestedManyWithoutUserInput
    specialAbilities?: spaecialAbilityUncheckedCreateNestedManyWithoutUserInput
    specs?: specUncheckedCreateNestedManyWithoutUserInput
    requests?: requestUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSkillPointsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSkillPointsInput, userUncheckedCreateWithoutSkillPointsInput>
  }

  export type userUpsertWithoutSkillPointsInput = {
    update: XOR<userUpdateWithoutSkillPointsInput, userUncheckedUpdateWithoutSkillPointsInput>
    create: XOR<userCreateWithoutSkillPointsInput, userUncheckedCreateWithoutSkillPointsInput>
  }

  export type userUpdateWithoutSkillPointsInput = {
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: skillUpdateManyWithoutUserNestedInput
    specialAbilities?: spaecialAbilityUpdateManyWithoutUserNestedInput
    specs?: specUpdateManyWithoutUserNestedInput
    requests?: requestUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSkillPointsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: skillUncheckedUpdateManyWithoutUserNestedInput
    specialAbilities?: spaecialAbilityUncheckedUpdateManyWithoutUserNestedInput
    specs?: specUncheckedUpdateManyWithoutUserNestedInput
    requests?: requestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutSpecialAbilitiesInput = {
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skills?: skillCreateNestedManyWithoutUserInput
    skillPoints?: skillPointCreateNestedManyWithoutUserInput
    specs?: specCreateNestedManyWithoutUserInput
    requests?: requestCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSpecialAbilitiesInput = {
    userId?: number
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skills?: skillUncheckedCreateNestedManyWithoutUserInput
    skillPoints?: skillPointUncheckedCreateNestedManyWithoutUserInput
    specs?: specUncheckedCreateNestedManyWithoutUserInput
    requests?: requestUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSpecialAbilitiesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSpecialAbilitiesInput, userUncheckedCreateWithoutSpecialAbilitiesInput>
  }

  export type userUpsertWithoutSpecialAbilitiesInput = {
    update: XOR<userUpdateWithoutSpecialAbilitiesInput, userUncheckedUpdateWithoutSpecialAbilitiesInput>
    create: XOR<userCreateWithoutSpecialAbilitiesInput, userUncheckedCreateWithoutSpecialAbilitiesInput>
  }

  export type userUpdateWithoutSpecialAbilitiesInput = {
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: skillUpdateManyWithoutUserNestedInput
    skillPoints?: skillPointUpdateManyWithoutUserNestedInput
    specs?: specUpdateManyWithoutUserNestedInput
    requests?: requestUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSpecialAbilitiesInput = {
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: skillUncheckedUpdateManyWithoutUserNestedInput
    skillPoints?: skillPointUncheckedUpdateManyWithoutUserNestedInput
    specs?: specUncheckedUpdateManyWithoutUserNestedInput
    requests?: requestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutSpecsInput = {
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skills?: skillCreateNestedManyWithoutUserInput
    skillPoints?: skillPointCreateNestedManyWithoutUserInput
    specialAbilities?: spaecialAbilityCreateNestedManyWithoutUserInput
    requests?: requestCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSpecsInput = {
    userId?: number
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skills?: skillUncheckedCreateNestedManyWithoutUserInput
    skillPoints?: skillPointUncheckedCreateNestedManyWithoutUserInput
    specialAbilities?: spaecialAbilityUncheckedCreateNestedManyWithoutUserInput
    requests?: requestUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSpecsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSpecsInput, userUncheckedCreateWithoutSpecsInput>
  }

  export type portfolioCreateWithoutSpecInput = {
    heading: string
    url: string
  }

  export type portfolioUncheckedCreateWithoutSpecInput = {
    portfolioId?: number
    heading: string
    url: string
  }

  export type portfolioCreateOrConnectWithoutSpecInput = {
    where: portfolioWhereUniqueInput
    create: XOR<portfolioCreateWithoutSpecInput, portfolioUncheckedCreateWithoutSpecInput>
  }

  export type portfolioCreateManySpecInputEnvelope = {
    data: Enumerable<portfolioCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type skillSummaryCreateWithoutSpecInput = {
    autoCalibration: autoCalibrationCreateNestedOneWithoutSkillSummariesInput
  }

  export type skillSummaryUncheckedCreateWithoutSpecInput = {
    skillSummaryId?: number
    autoCalibrationId: number
  }

  export type skillSummaryCreateOrConnectWithoutSpecInput = {
    where: skillSummaryWhereUniqueInput
    create: XOR<skillSummaryCreateWithoutSpecInput, skillSummaryUncheckedCreateWithoutSpecInput>
  }

  export type skillSummaryCreateManySpecInputEnvelope = {
    data: Enumerable<skillSummaryCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type sellingPointCreateWithoutSpecInput = {
    title: string
    content: string
  }

  export type sellingPointUncheckedCreateWithoutSpecInput = {
    sellingPointId?: number
    title: string
    content: string
  }

  export type sellingPointCreateOrConnectWithoutSpecInput = {
    where: sellingPointWhereUniqueInput
    create: XOR<sellingPointCreateWithoutSpecInput, sellingPointUncheckedCreateWithoutSpecInput>
  }

  export type sellingPointCreateManySpecInputEnvelope = {
    data: Enumerable<sellingPointCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type qualificationCreateWithoutSpecInput = {
    credential: string
    acquisitionDate: string
  }

  export type qualificationUncheckedCreateWithoutSpecInput = {
    qualificationId?: number
    credential: string
    acquisitionDate: string
  }

  export type qualificationCreateOrConnectWithoutSpecInput = {
    where: qualificationWhereUniqueInput
    create: XOR<qualificationCreateWithoutSpecInput, qualificationUncheckedCreateWithoutSpecInput>
  }

  export type qualificationCreateManySpecInputEnvelope = {
    data: Enumerable<qualificationCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type previousWorkCreateWithoutSpecInput = {
    industry: string
    occupation: string
    JobDuties: string
  }

  export type previousWorkUncheckedCreateWithoutSpecInput = {
    previousWorkId?: number
    industry: string
    occupation: string
    JobDuties: string
  }

  export type previousWorkCreateOrConnectWithoutSpecInput = {
    where: previousWorkWhereUniqueInput
    create: XOR<previousWorkCreateWithoutSpecInput, previousWorkUncheckedCreateWithoutSpecInput>
  }

  export type previousWorkCreateManySpecInputEnvelope = {
    data: Enumerable<previousWorkCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type developmentExperienceCreateWithoutSpecInput = {
    startDate: string
    duration: string
    assignedTask: string
    teamSize: string
    totalProjectHeadcount: string
    projectName: string
    jobDuties: string
    img: string
    autoCalibration: autoCalibrationCreateNestedOneWithoutDevelopmentExperiencesInput
  }

  export type developmentExperienceUncheckedCreateWithoutSpecInput = {
    developmentExperienceId?: number
    startDate: string
    duration: string
    assignedTask: string
    teamSize: string
    totalProjectHeadcount: string
    projectName: string
    jobDuties: string
    img: string
    autoCalibrationId: number
  }

  export type developmentExperienceCreateOrConnectWithoutSpecInput = {
    where: developmentExperienceWhereUniqueInput
    create: XOR<developmentExperienceCreateWithoutSpecInput, developmentExperienceUncheckedCreateWithoutSpecInput>
  }

  export type developmentExperienceCreateManySpecInputEnvelope = {
    data: Enumerable<developmentExperienceCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutSpecsInput = {
    update: XOR<userUpdateWithoutSpecsInput, userUncheckedUpdateWithoutSpecsInput>
    create: XOR<userCreateWithoutSpecsInput, userUncheckedCreateWithoutSpecsInput>
  }

  export type userUpdateWithoutSpecsInput = {
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: skillUpdateManyWithoutUserNestedInput
    skillPoints?: skillPointUpdateManyWithoutUserNestedInput
    specialAbilities?: spaecialAbilityUpdateManyWithoutUserNestedInput
    requests?: requestUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSpecsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: skillUncheckedUpdateManyWithoutUserNestedInput
    skillPoints?: skillPointUncheckedUpdateManyWithoutUserNestedInput
    specialAbilities?: spaecialAbilityUncheckedUpdateManyWithoutUserNestedInput
    requests?: requestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type portfolioUpsertWithWhereUniqueWithoutSpecInput = {
    where: portfolioWhereUniqueInput
    update: XOR<portfolioUpdateWithoutSpecInput, portfolioUncheckedUpdateWithoutSpecInput>
    create: XOR<portfolioCreateWithoutSpecInput, portfolioUncheckedCreateWithoutSpecInput>
  }

  export type portfolioUpdateWithWhereUniqueWithoutSpecInput = {
    where: portfolioWhereUniqueInput
    data: XOR<portfolioUpdateWithoutSpecInput, portfolioUncheckedUpdateWithoutSpecInput>
  }

  export type portfolioUpdateManyWithWhereWithoutSpecInput = {
    where: portfolioScalarWhereInput
    data: XOR<portfolioUpdateManyMutationInput, portfolioUncheckedUpdateManyWithoutPortfoliosInput>
  }

  export type portfolioScalarWhereInput = {
    AND?: Enumerable<portfolioScalarWhereInput>
    OR?: Enumerable<portfolioScalarWhereInput>
    NOT?: Enumerable<portfolioScalarWhereInput>
    portfolioId?: IntFilter | number
    specId?: IntFilter | number
    heading?: StringFilter | string
    url?: StringFilter | string
  }

  export type skillSummaryUpsertWithWhereUniqueWithoutSpecInput = {
    where: skillSummaryWhereUniqueInput
    update: XOR<skillSummaryUpdateWithoutSpecInput, skillSummaryUncheckedUpdateWithoutSpecInput>
    create: XOR<skillSummaryCreateWithoutSpecInput, skillSummaryUncheckedCreateWithoutSpecInput>
  }

  export type skillSummaryUpdateWithWhereUniqueWithoutSpecInput = {
    where: skillSummaryWhereUniqueInput
    data: XOR<skillSummaryUpdateWithoutSpecInput, skillSummaryUncheckedUpdateWithoutSpecInput>
  }

  export type skillSummaryUpdateManyWithWhereWithoutSpecInput = {
    where: skillSummaryScalarWhereInput
    data: XOR<skillSummaryUpdateManyMutationInput, skillSummaryUncheckedUpdateManyWithoutSkillSummariesInput>
  }

  export type skillSummaryScalarWhereInput = {
    AND?: Enumerable<skillSummaryScalarWhereInput>
    OR?: Enumerable<skillSummaryScalarWhereInput>
    NOT?: Enumerable<skillSummaryScalarWhereInput>
    skillSummaryId?: IntFilter | number
    specId?: IntFilter | number
    autoCalibrationId?: IntFilter | number
  }

  export type sellingPointUpsertWithWhereUniqueWithoutSpecInput = {
    where: sellingPointWhereUniqueInput
    update: XOR<sellingPointUpdateWithoutSpecInput, sellingPointUncheckedUpdateWithoutSpecInput>
    create: XOR<sellingPointCreateWithoutSpecInput, sellingPointUncheckedCreateWithoutSpecInput>
  }

  export type sellingPointUpdateWithWhereUniqueWithoutSpecInput = {
    where: sellingPointWhereUniqueInput
    data: XOR<sellingPointUpdateWithoutSpecInput, sellingPointUncheckedUpdateWithoutSpecInput>
  }

  export type sellingPointUpdateManyWithWhereWithoutSpecInput = {
    where: sellingPointScalarWhereInput
    data: XOR<sellingPointUpdateManyMutationInput, sellingPointUncheckedUpdateManyWithoutSellingPointsInput>
  }

  export type sellingPointScalarWhereInput = {
    AND?: Enumerable<sellingPointScalarWhereInput>
    OR?: Enumerable<sellingPointScalarWhereInput>
    NOT?: Enumerable<sellingPointScalarWhereInput>
    sellingPointId?: IntFilter | number
    specId?: IntFilter | number
    title?: StringFilter | string
    content?: StringFilter | string
  }

  export type qualificationUpsertWithWhereUniqueWithoutSpecInput = {
    where: qualificationWhereUniqueInput
    update: XOR<qualificationUpdateWithoutSpecInput, qualificationUncheckedUpdateWithoutSpecInput>
    create: XOR<qualificationCreateWithoutSpecInput, qualificationUncheckedCreateWithoutSpecInput>
  }

  export type qualificationUpdateWithWhereUniqueWithoutSpecInput = {
    where: qualificationWhereUniqueInput
    data: XOR<qualificationUpdateWithoutSpecInput, qualificationUncheckedUpdateWithoutSpecInput>
  }

  export type qualificationUpdateManyWithWhereWithoutSpecInput = {
    where: qualificationScalarWhereInput
    data: XOR<qualificationUpdateManyMutationInput, qualificationUncheckedUpdateManyWithoutQualificationsInput>
  }

  export type qualificationScalarWhereInput = {
    AND?: Enumerable<qualificationScalarWhereInput>
    OR?: Enumerable<qualificationScalarWhereInput>
    NOT?: Enumerable<qualificationScalarWhereInput>
    qualificationId?: IntFilter | number
    specId?: IntFilter | number
    credential?: StringFilter | string
    acquisitionDate?: StringFilter | string
  }

  export type previousWorkUpsertWithWhereUniqueWithoutSpecInput = {
    where: previousWorkWhereUniqueInput
    update: XOR<previousWorkUpdateWithoutSpecInput, previousWorkUncheckedUpdateWithoutSpecInput>
    create: XOR<previousWorkCreateWithoutSpecInput, previousWorkUncheckedCreateWithoutSpecInput>
  }

  export type previousWorkUpdateWithWhereUniqueWithoutSpecInput = {
    where: previousWorkWhereUniqueInput
    data: XOR<previousWorkUpdateWithoutSpecInput, previousWorkUncheckedUpdateWithoutSpecInput>
  }

  export type previousWorkUpdateManyWithWhereWithoutSpecInput = {
    where: previousWorkScalarWhereInput
    data: XOR<previousWorkUpdateManyMutationInput, previousWorkUncheckedUpdateManyWithoutPreviousWorksInput>
  }

  export type previousWorkScalarWhereInput = {
    AND?: Enumerable<previousWorkScalarWhereInput>
    OR?: Enumerable<previousWorkScalarWhereInput>
    NOT?: Enumerable<previousWorkScalarWhereInput>
    previousWorkId?: IntFilter | number
    specId?: IntFilter | number
    industry?: StringFilter | string
    occupation?: StringFilter | string
    JobDuties?: StringFilter | string
  }

  export type developmentExperienceUpsertWithWhereUniqueWithoutSpecInput = {
    where: developmentExperienceWhereUniqueInput
    update: XOR<developmentExperienceUpdateWithoutSpecInput, developmentExperienceUncheckedUpdateWithoutSpecInput>
    create: XOR<developmentExperienceCreateWithoutSpecInput, developmentExperienceUncheckedCreateWithoutSpecInput>
  }

  export type developmentExperienceUpdateWithWhereUniqueWithoutSpecInput = {
    where: developmentExperienceWhereUniqueInput
    data: XOR<developmentExperienceUpdateWithoutSpecInput, developmentExperienceUncheckedUpdateWithoutSpecInput>
  }

  export type developmentExperienceUpdateManyWithWhereWithoutSpecInput = {
    where: developmentExperienceScalarWhereInput
    data: XOR<developmentExperienceUpdateManyMutationInput, developmentExperienceUncheckedUpdateManyWithoutDevelopmentExperiencesInput>
  }

  export type developmentExperienceScalarWhereInput = {
    AND?: Enumerable<developmentExperienceScalarWhereInput>
    OR?: Enumerable<developmentExperienceScalarWhereInput>
    NOT?: Enumerable<developmentExperienceScalarWhereInput>
    developmentExperienceId?: IntFilter | number
    specId?: IntFilter | number
    startDate?: StringFilter | string
    duration?: StringFilter | string
    assignedTask?: StringFilter | string
    teamSize?: StringFilter | string
    totalProjectHeadcount?: StringFilter | string
    projectName?: StringFilter | string
    jobDuties?: StringFilter | string
    img?: StringFilter | string
    autoCalibrationId?: IntFilter | number
  }

  export type specCreateWithoutPortfoliosInput = {
    github: string
    offHours: string
    createdAt: Date | string
    user: userCreateNestedOneWithoutSpecsInput
    skillSummaries?: skillSummaryCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointCreateNestedManyWithoutSpecInput
    qualifications?: qualificationCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceCreateNestedManyWithoutSpecInput
  }

  export type specUncheckedCreateWithoutPortfoliosInput = {
    specId?: number
    userId: number
    github: string
    offHours: string
    createdAt: Date | string
    skillSummaries?: skillSummaryUncheckedCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointUncheckedCreateNestedManyWithoutSpecInput
    qualifications?: qualificationUncheckedCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkUncheckedCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceUncheckedCreateNestedManyWithoutSpecInput
  }

  export type specCreateOrConnectWithoutPortfoliosInput = {
    where: specWhereUniqueInput
    create: XOR<specCreateWithoutPortfoliosInput, specUncheckedCreateWithoutPortfoliosInput>
  }

  export type specUpsertWithoutPortfoliosInput = {
    update: XOR<specUpdateWithoutPortfoliosInput, specUncheckedUpdateWithoutPortfoliosInput>
    create: XOR<specCreateWithoutPortfoliosInput, specUncheckedCreateWithoutPortfoliosInput>
  }

  export type specUpdateWithoutPortfoliosInput = {
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutSpecsNestedInput
    skillSummaries?: skillSummaryUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUpdateManyWithoutSpecNestedInput
  }

  export type specUncheckedUpdateWithoutPortfoliosInput = {
    specId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillSummaries?: skillSummaryUncheckedUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUncheckedUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUncheckedUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUncheckedUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type specCreateWithoutSkillSummariesInput = {
    github: string
    offHours: string
    createdAt: Date | string
    user: userCreateNestedOneWithoutSpecsInput
    portfolios?: portfolioCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointCreateNestedManyWithoutSpecInput
    qualifications?: qualificationCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceCreateNestedManyWithoutSpecInput
  }

  export type specUncheckedCreateWithoutSkillSummariesInput = {
    specId?: number
    userId: number
    github: string
    offHours: string
    createdAt: Date | string
    portfolios?: portfolioUncheckedCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointUncheckedCreateNestedManyWithoutSpecInput
    qualifications?: qualificationUncheckedCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkUncheckedCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceUncheckedCreateNestedManyWithoutSpecInput
  }

  export type specCreateOrConnectWithoutSkillSummariesInput = {
    where: specWhereUniqueInput
    create: XOR<specCreateWithoutSkillSummariesInput, specUncheckedCreateWithoutSkillSummariesInput>
  }

  export type autoCalibrationCreateWithoutSkillSummariesInput = {
    skill: string
    membership: number
    category: number
    FR: number
    CL: number
    ML: number
    QA: number
    JAVA: number
    PHP: number
    developmentExperiences?: developmentExperienceCreateNestedManyWithoutAutoCalibrationInput
  }

  export type autoCalibrationUncheckedCreateWithoutSkillSummariesInput = {
    autoCalibrationId?: number
    skill: string
    membership: number
    category: number
    FR: number
    CL: number
    ML: number
    QA: number
    JAVA: number
    PHP: number
    developmentExperiences?: developmentExperienceUncheckedCreateNestedManyWithoutAutoCalibrationInput
  }

  export type autoCalibrationCreateOrConnectWithoutSkillSummariesInput = {
    where: autoCalibrationWhereUniqueInput
    create: XOR<autoCalibrationCreateWithoutSkillSummariesInput, autoCalibrationUncheckedCreateWithoutSkillSummariesInput>
  }

  export type specUpsertWithoutSkillSummariesInput = {
    update: XOR<specUpdateWithoutSkillSummariesInput, specUncheckedUpdateWithoutSkillSummariesInput>
    create: XOR<specCreateWithoutSkillSummariesInput, specUncheckedCreateWithoutSkillSummariesInput>
  }

  export type specUpdateWithoutSkillSummariesInput = {
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutSpecsNestedInput
    portfolios?: portfolioUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUpdateManyWithoutSpecNestedInput
  }

  export type specUncheckedUpdateWithoutSkillSummariesInput = {
    specId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolios?: portfolioUncheckedUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUncheckedUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUncheckedUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUncheckedUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type autoCalibrationUpsertWithoutSkillSummariesInput = {
    update: XOR<autoCalibrationUpdateWithoutSkillSummariesInput, autoCalibrationUncheckedUpdateWithoutSkillSummariesInput>
    create: XOR<autoCalibrationCreateWithoutSkillSummariesInput, autoCalibrationUncheckedCreateWithoutSkillSummariesInput>
  }

  export type autoCalibrationUpdateWithoutSkillSummariesInput = {
    skill?: StringFieldUpdateOperationsInput | string
    membership?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    CL?: IntFieldUpdateOperationsInput | number
    ML?: IntFieldUpdateOperationsInput | number
    QA?: IntFieldUpdateOperationsInput | number
    JAVA?: IntFieldUpdateOperationsInput | number
    PHP?: IntFieldUpdateOperationsInput | number
    developmentExperiences?: developmentExperienceUpdateManyWithoutAutoCalibrationNestedInput
  }

  export type autoCalibrationUncheckedUpdateWithoutSkillSummariesInput = {
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
    skill?: StringFieldUpdateOperationsInput | string
    membership?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    CL?: IntFieldUpdateOperationsInput | number
    ML?: IntFieldUpdateOperationsInput | number
    QA?: IntFieldUpdateOperationsInput | number
    JAVA?: IntFieldUpdateOperationsInput | number
    PHP?: IntFieldUpdateOperationsInput | number
    developmentExperiences?: developmentExperienceUncheckedUpdateManyWithoutAutoCalibrationNestedInput
  }

  export type specCreateWithoutSellingPointsInput = {
    github: string
    offHours: string
    createdAt: Date | string
    user: userCreateNestedOneWithoutSpecsInput
    portfolios?: portfolioCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryCreateNestedManyWithoutSpecInput
    qualifications?: qualificationCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceCreateNestedManyWithoutSpecInput
  }

  export type specUncheckedCreateWithoutSellingPointsInput = {
    specId?: number
    userId: number
    github: string
    offHours: string
    createdAt: Date | string
    portfolios?: portfolioUncheckedCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryUncheckedCreateNestedManyWithoutSpecInput
    qualifications?: qualificationUncheckedCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkUncheckedCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceUncheckedCreateNestedManyWithoutSpecInput
  }

  export type specCreateOrConnectWithoutSellingPointsInput = {
    where: specWhereUniqueInput
    create: XOR<specCreateWithoutSellingPointsInput, specUncheckedCreateWithoutSellingPointsInput>
  }

  export type specUpsertWithoutSellingPointsInput = {
    update: XOR<specUpdateWithoutSellingPointsInput, specUncheckedUpdateWithoutSellingPointsInput>
    create: XOR<specCreateWithoutSellingPointsInput, specUncheckedCreateWithoutSellingPointsInput>
  }

  export type specUpdateWithoutSellingPointsInput = {
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutSpecsNestedInput
    portfolios?: portfolioUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUpdateManyWithoutSpecNestedInput
  }

  export type specUncheckedUpdateWithoutSellingPointsInput = {
    specId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolios?: portfolioUncheckedUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUncheckedUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUncheckedUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUncheckedUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type specCreateWithoutQualificationsInput = {
    github: string
    offHours: string
    createdAt: Date | string
    user: userCreateNestedOneWithoutSpecsInput
    portfolios?: portfolioCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceCreateNestedManyWithoutSpecInput
  }

  export type specUncheckedCreateWithoutQualificationsInput = {
    specId?: number
    userId: number
    github: string
    offHours: string
    createdAt: Date | string
    portfolios?: portfolioUncheckedCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryUncheckedCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointUncheckedCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkUncheckedCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceUncheckedCreateNestedManyWithoutSpecInput
  }

  export type specCreateOrConnectWithoutQualificationsInput = {
    where: specWhereUniqueInput
    create: XOR<specCreateWithoutQualificationsInput, specUncheckedCreateWithoutQualificationsInput>
  }

  export type specUpsertWithoutQualificationsInput = {
    update: XOR<specUpdateWithoutQualificationsInput, specUncheckedUpdateWithoutQualificationsInput>
    create: XOR<specCreateWithoutQualificationsInput, specUncheckedCreateWithoutQualificationsInput>
  }

  export type specUpdateWithoutQualificationsInput = {
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutSpecsNestedInput
    portfolios?: portfolioUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUpdateManyWithoutSpecNestedInput
  }

  export type specUncheckedUpdateWithoutQualificationsInput = {
    specId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolios?: portfolioUncheckedUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUncheckedUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUncheckedUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUncheckedUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type specCreateWithoutPreviousWorksInput = {
    github: string
    offHours: string
    createdAt: Date | string
    user: userCreateNestedOneWithoutSpecsInput
    portfolios?: portfolioCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointCreateNestedManyWithoutSpecInput
    qualifications?: qualificationCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceCreateNestedManyWithoutSpecInput
  }

  export type specUncheckedCreateWithoutPreviousWorksInput = {
    specId?: number
    userId: number
    github: string
    offHours: string
    createdAt: Date | string
    portfolios?: portfolioUncheckedCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryUncheckedCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointUncheckedCreateNestedManyWithoutSpecInput
    qualifications?: qualificationUncheckedCreateNestedManyWithoutSpecInput
    developmentExperiences?: developmentExperienceUncheckedCreateNestedManyWithoutSpecInput
  }

  export type specCreateOrConnectWithoutPreviousWorksInput = {
    where: specWhereUniqueInput
    create: XOR<specCreateWithoutPreviousWorksInput, specUncheckedCreateWithoutPreviousWorksInput>
  }

  export type specUpsertWithoutPreviousWorksInput = {
    update: XOR<specUpdateWithoutPreviousWorksInput, specUncheckedUpdateWithoutPreviousWorksInput>
    create: XOR<specCreateWithoutPreviousWorksInput, specUncheckedCreateWithoutPreviousWorksInput>
  }

  export type specUpdateWithoutPreviousWorksInput = {
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutSpecsNestedInput
    portfolios?: portfolioUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUpdateManyWithoutSpecNestedInput
  }

  export type specUncheckedUpdateWithoutPreviousWorksInput = {
    specId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolios?: portfolioUncheckedUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUncheckedUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUncheckedUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUncheckedUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type specCreateWithoutDevelopmentExperiencesInput = {
    github: string
    offHours: string
    createdAt: Date | string
    user: userCreateNestedOneWithoutSpecsInput
    portfolios?: portfolioCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointCreateNestedManyWithoutSpecInput
    qualifications?: qualificationCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkCreateNestedManyWithoutSpecInput
  }

  export type specUncheckedCreateWithoutDevelopmentExperiencesInput = {
    specId?: number
    userId: number
    github: string
    offHours: string
    createdAt: Date | string
    portfolios?: portfolioUncheckedCreateNestedManyWithoutSpecInput
    skillSummaries?: skillSummaryUncheckedCreateNestedManyWithoutSpecInput
    sellingPoints?: sellingPointUncheckedCreateNestedManyWithoutSpecInput
    qualifications?: qualificationUncheckedCreateNestedManyWithoutSpecInput
    previousWorks?: previousWorkUncheckedCreateNestedManyWithoutSpecInput
  }

  export type specCreateOrConnectWithoutDevelopmentExperiencesInput = {
    where: specWhereUniqueInput
    create: XOR<specCreateWithoutDevelopmentExperiencesInput, specUncheckedCreateWithoutDevelopmentExperiencesInput>
  }

  export type autoCalibrationCreateWithoutDevelopmentExperiencesInput = {
    skill: string
    membership: number
    category: number
    FR: number
    CL: number
    ML: number
    QA: number
    JAVA: number
    PHP: number
    skillSummaries?: skillSummaryCreateNestedManyWithoutAutoCalibrationInput
  }

  export type autoCalibrationUncheckedCreateWithoutDevelopmentExperiencesInput = {
    autoCalibrationId?: number
    skill: string
    membership: number
    category: number
    FR: number
    CL: number
    ML: number
    QA: number
    JAVA: number
    PHP: number
    skillSummaries?: skillSummaryUncheckedCreateNestedManyWithoutAutoCalibrationInput
  }

  export type autoCalibrationCreateOrConnectWithoutDevelopmentExperiencesInput = {
    where: autoCalibrationWhereUniqueInput
    create: XOR<autoCalibrationCreateWithoutDevelopmentExperiencesInput, autoCalibrationUncheckedCreateWithoutDevelopmentExperiencesInput>
  }

  export type specUpsertWithoutDevelopmentExperiencesInput = {
    update: XOR<specUpdateWithoutDevelopmentExperiencesInput, specUncheckedUpdateWithoutDevelopmentExperiencesInput>
    create: XOR<specCreateWithoutDevelopmentExperiencesInput, specUncheckedCreateWithoutDevelopmentExperiencesInput>
  }

  export type specUpdateWithoutDevelopmentExperiencesInput = {
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutSpecsNestedInput
    portfolios?: portfolioUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUpdateManyWithoutSpecNestedInput
  }

  export type specUncheckedUpdateWithoutDevelopmentExperiencesInput = {
    specId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolios?: portfolioUncheckedUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUncheckedUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUncheckedUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUncheckedUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type autoCalibrationUpsertWithoutDevelopmentExperiencesInput = {
    update: XOR<autoCalibrationUpdateWithoutDevelopmentExperiencesInput, autoCalibrationUncheckedUpdateWithoutDevelopmentExperiencesInput>
    create: XOR<autoCalibrationCreateWithoutDevelopmentExperiencesInput, autoCalibrationUncheckedCreateWithoutDevelopmentExperiencesInput>
  }

  export type autoCalibrationUpdateWithoutDevelopmentExperiencesInput = {
    skill?: StringFieldUpdateOperationsInput | string
    membership?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    CL?: IntFieldUpdateOperationsInput | number
    ML?: IntFieldUpdateOperationsInput | number
    QA?: IntFieldUpdateOperationsInput | number
    JAVA?: IntFieldUpdateOperationsInput | number
    PHP?: IntFieldUpdateOperationsInput | number
    skillSummaries?: skillSummaryUpdateManyWithoutAutoCalibrationNestedInput
  }

  export type autoCalibrationUncheckedUpdateWithoutDevelopmentExperiencesInput = {
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
    skill?: StringFieldUpdateOperationsInput | string
    membership?: IntFieldUpdateOperationsInput | number
    category?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    CL?: IntFieldUpdateOperationsInput | number
    ML?: IntFieldUpdateOperationsInput | number
    QA?: IntFieldUpdateOperationsInput | number
    JAVA?: IntFieldUpdateOperationsInput | number
    PHP?: IntFieldUpdateOperationsInput | number
    skillSummaries?: skillSummaryUncheckedUpdateManyWithoutAutoCalibrationNestedInput
  }

  export type skillSummaryCreateWithoutAutoCalibrationInput = {
    spec: specCreateNestedOneWithoutSkillSummariesInput
  }

  export type skillSummaryUncheckedCreateWithoutAutoCalibrationInput = {
    skillSummaryId?: number
    specId: number
  }

  export type skillSummaryCreateOrConnectWithoutAutoCalibrationInput = {
    where: skillSummaryWhereUniqueInput
    create: XOR<skillSummaryCreateWithoutAutoCalibrationInput, skillSummaryUncheckedCreateWithoutAutoCalibrationInput>
  }

  export type skillSummaryCreateManyAutoCalibrationInputEnvelope = {
    data: Enumerable<skillSummaryCreateManyAutoCalibrationInput>
    skipDuplicates?: boolean
  }

  export type developmentExperienceCreateWithoutAutoCalibrationInput = {
    startDate: string
    duration: string
    assignedTask: string
    teamSize: string
    totalProjectHeadcount: string
    projectName: string
    jobDuties: string
    img: string
    spec: specCreateNestedOneWithoutDevelopmentExperiencesInput
  }

  export type developmentExperienceUncheckedCreateWithoutAutoCalibrationInput = {
    developmentExperienceId?: number
    specId: number
    startDate: string
    duration: string
    assignedTask: string
    teamSize: string
    totalProjectHeadcount: string
    projectName: string
    jobDuties: string
    img: string
  }

  export type developmentExperienceCreateOrConnectWithoutAutoCalibrationInput = {
    where: developmentExperienceWhereUniqueInput
    create: XOR<developmentExperienceCreateWithoutAutoCalibrationInput, developmentExperienceUncheckedCreateWithoutAutoCalibrationInput>
  }

  export type developmentExperienceCreateManyAutoCalibrationInputEnvelope = {
    data: Enumerable<developmentExperienceCreateManyAutoCalibrationInput>
    skipDuplicates?: boolean
  }

  export type skillSummaryUpsertWithWhereUniqueWithoutAutoCalibrationInput = {
    where: skillSummaryWhereUniqueInput
    update: XOR<skillSummaryUpdateWithoutAutoCalibrationInput, skillSummaryUncheckedUpdateWithoutAutoCalibrationInput>
    create: XOR<skillSummaryCreateWithoutAutoCalibrationInput, skillSummaryUncheckedCreateWithoutAutoCalibrationInput>
  }

  export type skillSummaryUpdateWithWhereUniqueWithoutAutoCalibrationInput = {
    where: skillSummaryWhereUniqueInput
    data: XOR<skillSummaryUpdateWithoutAutoCalibrationInput, skillSummaryUncheckedUpdateWithoutAutoCalibrationInput>
  }

  export type skillSummaryUpdateManyWithWhereWithoutAutoCalibrationInput = {
    where: skillSummaryScalarWhereInput
    data: XOR<skillSummaryUpdateManyMutationInput, skillSummaryUncheckedUpdateManyWithoutSkillSummariesInput>
  }

  export type developmentExperienceUpsertWithWhereUniqueWithoutAutoCalibrationInput = {
    where: developmentExperienceWhereUniqueInput
    update: XOR<developmentExperienceUpdateWithoutAutoCalibrationInput, developmentExperienceUncheckedUpdateWithoutAutoCalibrationInput>
    create: XOR<developmentExperienceCreateWithoutAutoCalibrationInput, developmentExperienceUncheckedCreateWithoutAutoCalibrationInput>
  }

  export type developmentExperienceUpdateWithWhereUniqueWithoutAutoCalibrationInput = {
    where: developmentExperienceWhereUniqueInput
    data: XOR<developmentExperienceUpdateWithoutAutoCalibrationInput, developmentExperienceUncheckedUpdateWithoutAutoCalibrationInput>
  }

  export type developmentExperienceUpdateManyWithWhereWithoutAutoCalibrationInput = {
    where: developmentExperienceScalarWhereInput
    data: XOR<developmentExperienceUpdateManyMutationInput, developmentExperienceUncheckedUpdateManyWithoutDevelopmentExperiencesInput>
  }

  export type userCreateWithoutRequestsInput = {
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skills?: skillCreateNestedManyWithoutUserInput
    skillPoints?: skillPointCreateNestedManyWithoutUserInput
    specialAbilities?: spaecialAbilityCreateNestedManyWithoutUserInput
    specs?: specCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRequestsInput = {
    userId?: number
    email: string
    employeeNumber: number
    joinDate: string
    userName: string
    affiliation: string
    businessSituation: string
    password: string
    confirmPassword: string
    createdAt: Date | string
    updatedAt: Date | string
    skills?: skillUncheckedCreateNestedManyWithoutUserInput
    skillPoints?: skillPointUncheckedCreateNestedManyWithoutUserInput
    specialAbilities?: spaecialAbilityUncheckedCreateNestedManyWithoutUserInput
    specs?: specUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRequestsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRequestsInput, userUncheckedCreateWithoutRequestsInput>
  }

  export type adminCreateWithoutRequestsInput = {
    email: string
    password: string
    name: string
    createdAt: Date | string
  }

  export type adminUncheckedCreateWithoutRequestsInput = {
    adminId?: number
    email: string
    password: string
    name: string
    createdAt: Date | string
  }

  export type adminCreateOrConnectWithoutRequestsInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutRequestsInput, adminUncheckedCreateWithoutRequestsInput>
  }

  export type userUpsertWithoutRequestsInput = {
    update: XOR<userUpdateWithoutRequestsInput, userUncheckedUpdateWithoutRequestsInput>
    create: XOR<userCreateWithoutRequestsInput, userUncheckedCreateWithoutRequestsInput>
  }

  export type userUpdateWithoutRequestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: skillUpdateManyWithoutUserNestedInput
    skillPoints?: skillPointUpdateManyWithoutUserNestedInput
    specialAbilities?: spaecialAbilityUpdateManyWithoutUserNestedInput
    specs?: specUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRequestsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: IntFieldUpdateOperationsInput | number
    joinDate?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    affiliation?: StringFieldUpdateOperationsInput | string
    businessSituation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    confirmPassword?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: skillUncheckedUpdateManyWithoutUserNestedInput
    skillPoints?: skillPointUncheckedUpdateManyWithoutUserNestedInput
    specialAbilities?: spaecialAbilityUncheckedUpdateManyWithoutUserNestedInput
    specs?: specUncheckedUpdateManyWithoutUserNestedInput
  }

  export type adminUpsertWithoutRequestsInput = {
    update: XOR<adminUpdateWithoutRequestsInput, adminUncheckedUpdateWithoutRequestsInput>
    create: XOR<adminCreateWithoutRequestsInput, adminUncheckedCreateWithoutRequestsInput>
  }

  export type adminUpdateWithoutRequestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminUncheckedUpdateWithoutRequestsInput = {
    adminId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requestCreateWithoutAdminInput = {
    status: number
    adminComment: string
    engineerComment: string
    createdAt: Date | string
    resultedAt: Date | string
    user: userCreateNestedOneWithoutRequestsInput
  }

  export type requestUncheckedCreateWithoutAdminInput = {
    applicationId?: number
    userId: number
    status: number
    adminComment: string
    engineerComment: string
    createdAt: Date | string
    resultedAt: Date | string
  }

  export type requestCreateOrConnectWithoutAdminInput = {
    where: requestWhereUniqueInput
    create: XOR<requestCreateWithoutAdminInput, requestUncheckedCreateWithoutAdminInput>
  }

  export type requestCreateManyAdminInputEnvelope = {
    data: Enumerable<requestCreateManyAdminInput>
    skipDuplicates?: boolean
  }

  export type requestUpsertWithWhereUniqueWithoutAdminInput = {
    where: requestWhereUniqueInput
    update: XOR<requestUpdateWithoutAdminInput, requestUncheckedUpdateWithoutAdminInput>
    create: XOR<requestCreateWithoutAdminInput, requestUncheckedCreateWithoutAdminInput>
  }

  export type requestUpdateWithWhereUniqueWithoutAdminInput = {
    where: requestWhereUniqueInput
    data: XOR<requestUpdateWithoutAdminInput, requestUncheckedUpdateWithoutAdminInput>
  }

  export type requestUpdateManyWithWhereWithoutAdminInput = {
    where: requestScalarWhereInput
    data: XOR<requestUpdateManyMutationInput, requestUncheckedUpdateManyWithoutRequestsInput>
  }

  export type skillCreateManyUserInput = {
    skillId?: number
    InherentName: string
    InherentDescription: string
    numericalNumber: number
    numericalExplain: string
    updatedAt: Date | string
  }

  export type skillPointCreateManyUserInput = {
    skillPointId?: number
    FR: number
    BK: number
    DB: number
    SBR: number
    AR: number
    TS: number
    COM: number
  }

  export type spaecialAbilityCreateManyUserInput = {
    spaecialAbilityId?: number
    skillList: string
    skillSelection: boolean
  }

  export type specCreateManyUserInput = {
    specId?: number
    github: string
    offHours: string
    createdAt: Date | string
  }

  export type requestCreateManyUserInput = {
    applicationId?: number
    status: number
    adminComment: string
    engineerComment: string
    adminId: number
    createdAt: Date | string
    resultedAt: Date | string
  }

  export type skillUpdateWithoutUserInput = {
    InherentName?: StringFieldUpdateOperationsInput | string
    InherentDescription?: StringFieldUpdateOperationsInput | string
    numericalNumber?: IntFieldUpdateOperationsInput | number
    numericalExplain?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type skillUncheckedUpdateWithoutUserInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    InherentName?: StringFieldUpdateOperationsInput | string
    InherentDescription?: StringFieldUpdateOperationsInput | string
    numericalNumber?: IntFieldUpdateOperationsInput | number
    numericalExplain?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type skillUncheckedUpdateManyWithoutSkillsInput = {
    skillId?: IntFieldUpdateOperationsInput | number
    InherentName?: StringFieldUpdateOperationsInput | string
    InherentDescription?: StringFieldUpdateOperationsInput | string
    numericalNumber?: IntFieldUpdateOperationsInput | number
    numericalExplain?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type skillPointUpdateWithoutUserInput = {
    FR?: IntFieldUpdateOperationsInput | number
    BK?: IntFieldUpdateOperationsInput | number
    DB?: IntFieldUpdateOperationsInput | number
    SBR?: IntFieldUpdateOperationsInput | number
    AR?: IntFieldUpdateOperationsInput | number
    TS?: IntFieldUpdateOperationsInput | number
    COM?: IntFieldUpdateOperationsInput | number
  }

  export type skillPointUncheckedUpdateWithoutUserInput = {
    skillPointId?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    BK?: IntFieldUpdateOperationsInput | number
    DB?: IntFieldUpdateOperationsInput | number
    SBR?: IntFieldUpdateOperationsInput | number
    AR?: IntFieldUpdateOperationsInput | number
    TS?: IntFieldUpdateOperationsInput | number
    COM?: IntFieldUpdateOperationsInput | number
  }

  export type skillPointUncheckedUpdateManyWithoutSkillPointsInput = {
    skillPointId?: IntFieldUpdateOperationsInput | number
    FR?: IntFieldUpdateOperationsInput | number
    BK?: IntFieldUpdateOperationsInput | number
    DB?: IntFieldUpdateOperationsInput | number
    SBR?: IntFieldUpdateOperationsInput | number
    AR?: IntFieldUpdateOperationsInput | number
    TS?: IntFieldUpdateOperationsInput | number
    COM?: IntFieldUpdateOperationsInput | number
  }

  export type spaecialAbilityUpdateWithoutUserInput = {
    skillList?: StringFieldUpdateOperationsInput | string
    skillSelection?: BoolFieldUpdateOperationsInput | boolean
  }

  export type spaecialAbilityUncheckedUpdateWithoutUserInput = {
    spaecialAbilityId?: IntFieldUpdateOperationsInput | number
    skillList?: StringFieldUpdateOperationsInput | string
    skillSelection?: BoolFieldUpdateOperationsInput | boolean
  }

  export type spaecialAbilityUncheckedUpdateManyWithoutSpecialAbilitiesInput = {
    spaecialAbilityId?: IntFieldUpdateOperationsInput | number
    skillList?: StringFieldUpdateOperationsInput | string
    skillSelection?: BoolFieldUpdateOperationsInput | boolean
  }

  export type specUpdateWithoutUserInput = {
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolios?: portfolioUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUpdateManyWithoutSpecNestedInput
  }

  export type specUncheckedUpdateWithoutUserInput = {
    specId?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolios?: portfolioUncheckedUpdateManyWithoutSpecNestedInput
    skillSummaries?: skillSummaryUncheckedUpdateManyWithoutSpecNestedInput
    sellingPoints?: sellingPointUncheckedUpdateManyWithoutSpecNestedInput
    qualifications?: qualificationUncheckedUpdateManyWithoutSpecNestedInput
    previousWorks?: previousWorkUncheckedUpdateManyWithoutSpecNestedInput
    developmentExperiences?: developmentExperienceUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type specUncheckedUpdateManyWithoutSpecsInput = {
    specId?: IntFieldUpdateOperationsInput | number
    github?: StringFieldUpdateOperationsInput | string
    offHours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requestUpdateWithoutUserInput = {
    status?: IntFieldUpdateOperationsInput | number
    adminComment?: StringFieldUpdateOperationsInput | string
    engineerComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: adminUpdateOneRequiredWithoutRequestsNestedInput
  }

  export type requestUncheckedUpdateWithoutUserInput = {
    applicationId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    adminComment?: StringFieldUpdateOperationsInput | string
    engineerComment?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requestUncheckedUpdateManyWithoutRequestsInput = {
    applicationId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    adminComment?: StringFieldUpdateOperationsInput | string
    engineerComment?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type portfolioCreateManySpecInput = {
    portfolioId?: number
    heading: string
    url: string
  }

  export type skillSummaryCreateManySpecInput = {
    skillSummaryId?: number
    autoCalibrationId: number
  }

  export type sellingPointCreateManySpecInput = {
    sellingPointId?: number
    title: string
    content: string
  }

  export type qualificationCreateManySpecInput = {
    qualificationId?: number
    credential: string
    acquisitionDate: string
  }

  export type previousWorkCreateManySpecInput = {
    previousWorkId?: number
    industry: string
    occupation: string
    JobDuties: string
  }

  export type developmentExperienceCreateManySpecInput = {
    developmentExperienceId?: number
    startDate: string
    duration: string
    assignedTask: string
    teamSize: string
    totalProjectHeadcount: string
    projectName: string
    jobDuties: string
    img: string
    autoCalibrationId: number
  }

  export type portfolioUpdateWithoutSpecInput = {
    heading?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type portfolioUncheckedUpdateWithoutSpecInput = {
    portfolioId?: IntFieldUpdateOperationsInput | number
    heading?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type portfolioUncheckedUpdateManyWithoutPortfoliosInput = {
    portfolioId?: IntFieldUpdateOperationsInput | number
    heading?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type skillSummaryUpdateWithoutSpecInput = {
    autoCalibration?: autoCalibrationUpdateOneRequiredWithoutSkillSummariesNestedInput
  }

  export type skillSummaryUncheckedUpdateWithoutSpecInput = {
    skillSummaryId?: IntFieldUpdateOperationsInput | number
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
  }

  export type skillSummaryUncheckedUpdateManyWithoutSkillSummariesInput = {
    skillSummaryId?: IntFieldUpdateOperationsInput | number
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
  }

  export type sellingPointUpdateWithoutSpecInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type sellingPointUncheckedUpdateWithoutSpecInput = {
    sellingPointId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type sellingPointUncheckedUpdateManyWithoutSellingPointsInput = {
    sellingPointId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type qualificationUpdateWithoutSpecInput = {
    credential?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: StringFieldUpdateOperationsInput | string
  }

  export type qualificationUncheckedUpdateWithoutSpecInput = {
    qualificationId?: IntFieldUpdateOperationsInput | number
    credential?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: StringFieldUpdateOperationsInput | string
  }

  export type qualificationUncheckedUpdateManyWithoutQualificationsInput = {
    qualificationId?: IntFieldUpdateOperationsInput | number
    credential?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: StringFieldUpdateOperationsInput | string
  }

  export type previousWorkUpdateWithoutSpecInput = {
    industry?: StringFieldUpdateOperationsInput | string
    occupation?: StringFieldUpdateOperationsInput | string
    JobDuties?: StringFieldUpdateOperationsInput | string
  }

  export type previousWorkUncheckedUpdateWithoutSpecInput = {
    previousWorkId?: IntFieldUpdateOperationsInput | number
    industry?: StringFieldUpdateOperationsInput | string
    occupation?: StringFieldUpdateOperationsInput | string
    JobDuties?: StringFieldUpdateOperationsInput | string
  }

  export type previousWorkUncheckedUpdateManyWithoutPreviousWorksInput = {
    previousWorkId?: IntFieldUpdateOperationsInput | number
    industry?: StringFieldUpdateOperationsInput | string
    occupation?: StringFieldUpdateOperationsInput | string
    JobDuties?: StringFieldUpdateOperationsInput | string
  }

  export type developmentExperienceUpdateWithoutSpecInput = {
    startDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    assignedTask?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    totalProjectHeadcount?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jobDuties?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    autoCalibration?: autoCalibrationUpdateOneRequiredWithoutDevelopmentExperiencesNestedInput
  }

  export type developmentExperienceUncheckedUpdateWithoutSpecInput = {
    developmentExperienceId?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    assignedTask?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    totalProjectHeadcount?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jobDuties?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
  }

  export type developmentExperienceUncheckedUpdateManyWithoutDevelopmentExperiencesInput = {
    developmentExperienceId?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    assignedTask?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    totalProjectHeadcount?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jobDuties?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    autoCalibrationId?: IntFieldUpdateOperationsInput | number
  }

  export type skillSummaryCreateManyAutoCalibrationInput = {
    skillSummaryId?: number
    specId: number
  }

  export type developmentExperienceCreateManyAutoCalibrationInput = {
    developmentExperienceId?: number
    specId: number
    startDate: string
    duration: string
    assignedTask: string
    teamSize: string
    totalProjectHeadcount: string
    projectName: string
    jobDuties: string
    img: string
  }

  export type skillSummaryUpdateWithoutAutoCalibrationInput = {
    spec?: specUpdateOneRequiredWithoutSkillSummariesNestedInput
  }

  export type skillSummaryUncheckedUpdateWithoutAutoCalibrationInput = {
    skillSummaryId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
  }

  export type developmentExperienceUpdateWithoutAutoCalibrationInput = {
    startDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    assignedTask?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    totalProjectHeadcount?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jobDuties?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    spec?: specUpdateOneRequiredWithoutDevelopmentExperiencesNestedInput
  }

  export type developmentExperienceUncheckedUpdateWithoutAutoCalibrationInput = {
    developmentExperienceId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    startDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    assignedTask?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    totalProjectHeadcount?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jobDuties?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
  }

  export type requestCreateManyAdminInput = {
    applicationId?: number
    userId: number
    status: number
    adminComment: string
    engineerComment: string
    createdAt: Date | string
    resultedAt: Date | string
  }

  export type requestUpdateWithoutAdminInput = {
    status?: IntFieldUpdateOperationsInput | number
    adminComment?: StringFieldUpdateOperationsInput | string
    engineerComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutRequestsNestedInput
  }

  export type requestUncheckedUpdateWithoutAdminInput = {
    applicationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    adminComment?: StringFieldUpdateOperationsInput | string
    engineerComment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}